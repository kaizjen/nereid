/* EditBookmark.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	add_flush_callback,
	add_location,
	bind,
	binding_callbacks,
	create_component,
	destroy_component,
	detach_dev,
	dispatch_dev,
	element,
	init,
	insert_dev,
	mount_component,
	noop,
	safe_not_equal,
	set_data_dev,
	space,
	text,
	transition_in,
	transition_out,
	validate_slots
} from "nereid://.svelte/internal/index.mjs";

import { Button, ContentDialog, TextBox } from "../modules/fluent-svelte/index.js";
import { createEventDispatcher } from "nereid://.svelte/index.mjs";
const file = "EditBookmark.svelte";

// (17:0) <ContentDialog bind:open append={document.body} {title}>
function create_default_slot_2(ctx) {
	let textbox0;
	let updating_value;
	let br;
	let t_1;
	let textbox1;
	let updating_value_1;
	let current;

	function textbox0_value_binding(value) {
		/*textbox0_value_binding*/ ctx[10](value);
	}

	let textbox0_props = {
		placeholder: /*tt*/ ctx[5]('bookmark.name')
	};

	if (/*name*/ ctx[1] !== void 0) {
		textbox0_props.value = /*name*/ ctx[1];
	}

	textbox0 = new TextBox({ props: textbox0_props, $$inline: true });
	binding_callbacks.push(() => bind(textbox0, 'value', textbox0_value_binding));

	function textbox1_value_binding(value) {
		/*textbox1_value_binding*/ ctx[11](value);
	}

	let textbox1_props = {
		placeholder: /*tt*/ ctx[5]('bookmark.url')
	};

	if (/*url*/ ctx[2] !== void 0) {
		textbox1_props.value = /*url*/ ctx[2];
	}

	textbox1 = new TextBox({ props: textbox1_props, $$inline: true });
	binding_callbacks.push(() => bind(textbox1, 'value', textbox1_value_binding));

	const block = {
		c: function create() {
			create_component(textbox0.$$.fragment);
			br = element("br");
			t_1 = space();
			create_component(textbox1.$$.fragment);
			add_location(br, file, 17, 65, 497);
		},
		m: function mount(target, anchor) {
			mount_component(textbox0, target, anchor);
			insert_dev(target, br, anchor);
			insert_dev(target, t_1, anchor);
			mount_component(textbox1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textbox0_changes = {};
			if (dirty & /*tt*/ 32) textbox0_changes.placeholder = /*tt*/ ctx[5]('bookmark.name');

			if (!updating_value && dirty & /*name*/ 2) {
				updating_value = true;
				textbox0_changes.value = /*name*/ ctx[1];
				add_flush_callback(() => updating_value = false);
			}

			textbox0.$set(textbox0_changes);
			const textbox1_changes = {};
			if (dirty & /*tt*/ 32) textbox1_changes.placeholder = /*tt*/ ctx[5]('bookmark.url');

			if (!updating_value_1 && dirty & /*url*/ 4) {
				updating_value_1 = true;
				textbox1_changes.value = /*url*/ ctx[2];
				add_flush_callback(() => updating_value_1 = false);
			}

			textbox1.$set(textbox1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textbox0.$$.fragment, local);
			transition_in(textbox1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textbox0.$$.fragment, local);
			transition_out(textbox1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textbox0, detaching);
			if (detaching) detach_dev(br);
			if (detaching) detach_dev(t_1);
			destroy_component(textbox1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(17:0) <ContentDialog bind:open append={document.body} {title}>",
		ctx
	});

	return block;
}

// (21:4) <Button on:click={() => open = false}>
function create_default_slot_1(ctx) {
	let t_1_value = /*t*/ ctx[6]('common.cancel') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(21:4) <Button on:click={() => open = false}>",
		ctx
	});

	return block;
}

// (24:4) <Button variant="accent" on:click={() => dispatch('click', { name, url })}>
function create_default_slot(ctx) {
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(/*buttonText*/ ctx[4]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*buttonText*/ 16) set_data_dev(t_1, /*buttonText*/ ctx[4]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(24:4) <Button variant=\\\"accent\\\" on:click={() => dispatch('click', { name, url })}>",
		ctx
	});

	return block;
}

// (20:2) <svelte:fragment slot="footer">
function create_footer_slot(ctx) {
	let button0;
	let t_1;
	let button1;
	let current;

	button0 = new Button({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*click_handler*/ ctx[8]);

	button1 = new Button({
			props: {
				variant: "accent",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*click_handler_1*/ ctx[9]);

	const block = {
		c: function create() {
			create_component(button0.$$.fragment);
			t_1 = space();
			create_component(button1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(button0, target, anchor);
			insert_dev(target, t_1, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope, buttonText*/ 8208) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach_dev(t_1);
			destroy_component(button1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(20:2) <svelte:fragment slot=\\\"footer\\\">",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let contentdialog;
	let updating_open;
	let current;

	function contentdialog_open_binding(value) {
		/*contentdialog_open_binding*/ ctx[12](value);
	}

	let contentdialog_props = {
		append: document.body,
		title: /*title*/ ctx[3],
		$$slots: {
			footer: [create_footer_slot],
			default: [create_default_slot_2]
		},
		$$scope: { ctx }
	};

	if (/*open*/ ctx[0] !== void 0) {
		contentdialog_props.open = /*open*/ ctx[0];
	}

	contentdialog = new ContentDialog({
			props: contentdialog_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(contentdialog, 'open', contentdialog_open_binding));

	const block = {
		c: function create() {
			create_component(contentdialog.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(contentdialog, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const contentdialog_changes = {};
			if (dirty & /*title*/ 8) contentdialog_changes.title = /*title*/ ctx[3];

			if (dirty & /*$$scope, name, url, buttonText, open, tt*/ 8247) {
				contentdialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_open && dirty & /*open*/ 1) {
				updating_open = true;
				contentdialog_changes.open = /*open*/ ctx[0];
				add_flush_callback(() => updating_open = false);
			}

			contentdialog.$set(contentdialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(contentdialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(contentdialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(contentdialog, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('EditBookmark', slots, []);
	let { title = undefined } = $$props;
	let { buttonText } = $$props;
	let { open } = $$props;
	const { t } = window.nereid.i18n;
	let { tt } = $$props;
	const dispatch = createEventDispatcher();
	let { name = '' } = $$props;
	let { url = '' } = $$props;
	const writable_props = ['title', 'buttonText', 'open', 'tt', 'name', 'url'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditBookmark> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, open = false);
	const click_handler_1 = () => dispatch('click', { name, url });

	function textbox0_value_binding(value) {
		name = value;
		$$invalidate(1, name);
	}

	function textbox1_value_binding(value) {
		url = value;
		$$invalidate(2, url);
	}

	function contentdialog_open_binding(value) {
		open = value;
		$$invalidate(0, open);
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(3, title = $$props.title);
		if ('buttonText' in $$props) $$invalidate(4, buttonText = $$props.buttonText);
		if ('open' in $$props) $$invalidate(0, open = $$props.open);
		if ('tt' in $$props) $$invalidate(5, tt = $$props.tt);
		if ('name' in $$props) $$invalidate(1, name = $$props.name);
		if ('url' in $$props) $$invalidate(2, url = $$props.url);
	};

	$$self.$capture_state = () => ({
		Button,
		ContentDialog,
		TextBox,
		createEventDispatcher,
		title,
		buttonText,
		open,
		t,
		tt,
		dispatch,
		name,
		url
	});

	$$self.$inject_state = $$props => {
		if ('title' in $$props) $$invalidate(3, title = $$props.title);
		if ('buttonText' in $$props) $$invalidate(4, buttonText = $$props.buttonText);
		if ('open' in $$props) $$invalidate(0, open = $$props.open);
		if ('tt' in $$props) $$invalidate(5, tt = $$props.tt);
		if ('name' in $$props) $$invalidate(1, name = $$props.name);
		if ('url' in $$props) $$invalidate(2, url = $$props.url);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		open,
		name,
		url,
		title,
		buttonText,
		tt,
		t,
		dispatch,
		click_handler,
		click_handler_1,
		textbox0_value_binding,
		textbox1_value_binding,
		contentdialog_open_binding
	];
}

class EditBookmark extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			title: 3,
			buttonText: 4,
			open: 0,
			tt: 5,
			name: 1,
			url: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditBookmark",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*buttonText*/ ctx[4] === undefined && !('buttonText' in props)) {
			console.warn("<EditBookmark> was created without expected prop 'buttonText'");
		}

		if (/*open*/ ctx[0] === undefined && !('open' in props)) {
			console.warn("<EditBookmark> was created without expected prop 'open'");
		}

		if (/*tt*/ ctx[5] === undefined && !('tt' in props)) {
			console.warn("<EditBookmark> was created without expected prop 'tt'");
		}
	}

	get title() {
		throw new Error("<EditBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<EditBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buttonText() {
		throw new Error("<EditBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buttonText(value) {
		throw new Error("<EditBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		throw new Error("<EditBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<EditBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tt() {
		throw new Error("<EditBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tt(value) {
		throw new Error("<EditBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<EditBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<EditBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get url() {
		throw new Error("<EditBookmark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<EditBookmark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default EditBookmark;