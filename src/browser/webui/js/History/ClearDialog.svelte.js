/* ClearDialog.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	add_flush_callback,
	add_location,
	bind,
	binding_callbacks,
	check_outros,
	create_component,
	destroy_component,
	destroy_each,
	detach_dev,
	dispatch_dev,
	element,
	empty,
	group_outros,
	init,
	insert_dev,
	mount_component,
	noop,
	safe_not_equal,
	set_data_dev,
	space,
	text,
	transition_in,
	transition_out,
	validate_each_argument,
	validate_slots
} from "nereid://.svelte/internal/index.mjs";

import { Button, ContentDialog, RadioButton, TextBlock } from "../modules/fluent-svelte/index.js";
import { getContext } from "nereid://.svelte/index.mjs";
const file = "ClearDialog.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

// (64:2) <RadioButton bind:group value="page">
function create_default_slot_5(ctx) {
	let t_1_value = /*tt*/ ctx[4]('dialog.clearOnThisPage-button') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(64:2) <RadioButton bind:group value=\\\"page\\\">",
		ctx
	});

	return block;
}

// (68:2) <TextBlock variant="bodyStrong">
function create_default_slot_4(ctx) {
	let t0_value = /*tt*/ ctx[4]('dialog.timePeriod') + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(68:2) <TextBlock variant=\\\"bodyStrong\\\">",
		ctx
	});

	return block;
}

// (72:4) <RadioButton bind:group {value}>
function create_default_slot_3(ctx) {
	let t0_value = /*tt*/ ctx[4]('dialog.option-' + /*value*/ ctx[12]) + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(72:4) <RadioButton bind:group {value}>",
		ctx
	});

	return block;
}

// (71:2) {#each ['hour', 'day', 'week', 'all'] as value}
function create_each_block(ctx) {
	let radiobutton;
	let updating_group;
	let br;
	let current;

	function radiobutton_group_binding_1(value) {
		/*radiobutton_group_binding_1*/ ctx[9](value);
	}

	let radiobutton_props = {
		value: /*value*/ ctx[12],
		$$slots: { default: [create_default_slot_3] },
		$$scope: { ctx }
	};

	if (/*group*/ ctx[2] !== void 0) {
		radiobutton_props.group = /*group*/ ctx[2];
	}

	radiobutton = new RadioButton({ props: radiobutton_props, $$inline: true });
	binding_callbacks.push(() => bind(radiobutton, 'group', radiobutton_group_binding_1));

	const block = {
		c: function create() {
			create_component(radiobutton.$$.fragment);
			br = element("br");
			add_location(br, file, 73, 18, 1855);
		},
		m: function mount(target, anchor) {
			mount_component(radiobutton, target, anchor);
			insert_dev(target, br, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const radiobutton_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				radiobutton_changes.$$scope = { dirty, ctx };
			}

			if (!updating_group && dirty & /*group*/ 4) {
				updating_group = true;
				radiobutton_changes.group = /*group*/ ctx[2];
				add_flush_callback(() => updating_group = false);
			}

			radiobutton.$set(radiobutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radiobutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radiobutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radiobutton, detaching);
			if (detaching) detach_dev(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(71:2) {#each ['hour', 'day', 'week', 'all'] as value}",
		ctx
	});

	return block;
}

// (63:0) <ContentDialog bind:open append={document.body} title={tt('dialog.title')}>
function create_default_slot_2(ctx) {
	let radiobutton;
	let updating_group;
	let t0;
	let br0;
	let br1;
	let t1;
	let textblock;
	let br2;
	let t2;
	let each_1_anchor;
	let current;

	function radiobutton_group_binding(value) {
		/*radiobutton_group_binding*/ ctx[8](value);
	}

	let radiobutton_props = {
		value: "page",
		$$slots: { default: [create_default_slot_5] },
		$$scope: { ctx }
	};

	if (/*group*/ ctx[2] !== void 0) {
		radiobutton_props.group = /*group*/ ctx[2];
	}

	radiobutton = new RadioButton({ props: radiobutton_props, $$inline: true });
	binding_callbacks.push(() => bind(radiobutton, 'group', radiobutton_group_binding));

	textblock = new TextBlock({
			props: {
				variant: "bodyStrong",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let each_value = ['hour', 'day', 'week', 'all'];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < 4; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			create_component(radiobutton.$$.fragment);
			t0 = space();
			br0 = element("br");
			br1 = element("br");
			t1 = space();
			create_component(textblock.$$.fragment);
			br2 = element("br");
			t2 = space();

			for (let i = 0; i < 4; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			add_location(br0, file, 66, 2, 1615);
			add_location(br1, file, 66, 6, 1619);
			add_location(br2, file, 69, 14, 1706);
		},
		m: function mount(target, anchor) {
			mount_component(radiobutton, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, br0, anchor);
			insert_dev(target, br1, anchor);
			insert_dev(target, t1, anchor);
			mount_component(textblock, target, anchor);
			insert_dev(target, br2, anchor);
			insert_dev(target, t2, anchor);

			for (let i = 0; i < 4; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const radiobutton_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				radiobutton_changes.$$scope = { dirty, ctx };
			}

			if (!updating_group && dirty & /*group*/ 4) {
				updating_group = true;
				radiobutton_changes.group = /*group*/ ctx[2];
				add_flush_callback(() => updating_group = false);
			}

			radiobutton.$set(radiobutton_changes);
			const textblock_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				textblock_changes.$$scope = { dirty, ctx };
			}

			textblock.$set(textblock_changes);

			if (dirty & /*group, tt*/ 20) {
				each_value = ['hour', 'day', 'week', 'all'];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < 4; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = 4; i < 4; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radiobutton.$$.fragment, local);
			transition_in(textblock.$$.fragment, local);

			for (let i = 0; i < 4; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(radiobutton.$$.fragment, local);
			transition_out(textblock.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < 4; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radiobutton, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(br0);
			if (detaching) detach_dev(br1);
			if (detaching) detach_dev(t1);
			destroy_component(textblock, detaching);
			if (detaching) detach_dev(br2);
			if (detaching) detach_dev(t2);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(63:0) <ContentDialog bind:open append={document.body} title={tt('dialog.title')}>",
		ctx
	});

	return block;
}

// (78:4) <Button on:click={() => open = false}>
function create_default_slot_1(ctx) {
	let t_1_value = /*t*/ ctx[3]('common.cancel') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(78:4) <Button on:click={() => open = false}>",
		ctx
	});

	return block;
}

// (81:4) <Button on:click={clear} variant="accent" disabled={isLoading}>
function create_default_slot(ctx) {
	let t_1_value = (/*isLoading*/ ctx[1]
	? /*t*/ ctx[3]('common.loading')
	: /*tt*/ ctx[4]('dialog.clear-button')) + "";

	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*isLoading*/ 2 && t_1_value !== (t_1_value = (/*isLoading*/ ctx[1]
			? /*t*/ ctx[3]('common.loading')
			: /*tt*/ ctx[4]('dialog.clear-button')) + "")) set_data_dev(t_1, t_1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(81:4) <Button on:click={clear} variant=\\\"accent\\\" disabled={isLoading}>",
		ctx
	});

	return block;
}

// (77:2) <svelte:fragment slot="footer">
function create_footer_slot(ctx) {
	let button0;
	let t_1;
	let button1;
	let current;

	button0 = new Button({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*click_handler*/ ctx[7]);

	button1 = new Button({
			props: {
				variant: "accent",
				disabled: /*isLoading*/ ctx[1],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*clear*/ ctx[5]);

	const block = {
		c: function create() {
			create_component(button0.$$.fragment);
			t_1 = space();
			create_component(button1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(button0, target, anchor);
			insert_dev(target, t_1, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty & /*isLoading*/ 2) button1_changes.disabled = /*isLoading*/ ctx[1];

			if (dirty & /*$$scope, isLoading*/ 32770) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach_dev(t_1);
			destroy_component(button1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(77:2) <svelte:fragment slot=\\\"footer\\\">",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let contentdialog;
	let updating_open;
	let current;

	function contentdialog_open_binding(value) {
		/*contentdialog_open_binding*/ ctx[10](value);
	}

	let contentdialog_props = {
		append: document.body,
		title: /*tt*/ ctx[4]('dialog.title'),
		$$slots: {
			footer: [create_footer_slot],
			default: [create_default_slot_2]
		},
		$$scope: { ctx }
	};

	if (/*open*/ ctx[0] !== void 0) {
		contentdialog_props.open = /*open*/ ctx[0];
	}

	contentdialog = new ContentDialog({
			props: contentdialog_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(contentdialog, 'open', contentdialog_open_binding));

	const block = {
		c: function create() {
			create_component(contentdialog.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(contentdialog, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const contentdialog_changes = {};

			if (dirty & /*$$scope, isLoading, open, group*/ 32775) {
				contentdialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_open && dirty & /*open*/ 1) {
				updating_open = true;
				contentdialog_changes.open = /*open*/ ctx[0];
				add_flush_callback(() => updating_open = false);
			}

			contentdialog.$set(contentdialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(contentdialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(contentdialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(contentdialog, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ClearDialog', slots, []);
	let { open } = $$props;
	let { clearAllOnThisPage } = $$props;
	let isLoading = false;
	const { t } = window.nereid.i18n;

	function tt(str, ...args) {
		return t(`pages.history.${str}`, ...args);
	}

	const update = getContext('update');

	async function clear() {
		const HOURS = 60 * 60 * 1000;

		if (group == 'page') {
			$$invalidate(1, isLoading = true);
			await clearAllOnThisPage();
		} else {
			let timestamp;

			switch (group) {
				case 'hour':
					{
						timestamp = Date.now() - 1 * HOURS;
						break;
					}
				case 'day':
					{
						timestamp = Date.now() - 24 * HOURS;
						break;
					}
				case 'week':
					{
						timestamp = Date.now() - 7 * 24 * HOURS;
						break;
					}
				case 'all':
					{
						timestamp = 0;
						break;
					}
				default:
					throw "?";
			}

			$$invalidate(1, isLoading = true);

			const indexes = await window.nereid.userdata.history.find({
				type: 'date',
				compare: 'gt',
				date: timestamp
			});

			let i = 0;

			for (const index of indexes) {
				await window.nereid.userdata.history.delAt({ index: index - i });
				i++;
			}

			update();
		}

		$$invalidate(1, isLoading = false);
		$$invalidate(0, open = false);
	}

	let group = "page";
	const writable_props = ['open', 'clearAllOnThisPage'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClearDialog> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, open = false);

	function radiobutton_group_binding(value) {
		group = value;
		$$invalidate(2, group);
	}

	function radiobutton_group_binding_1(value) {
		group = value;
		$$invalidate(2, group);
	}

	function contentdialog_open_binding(value) {
		open = value;
		$$invalidate(0, open);
	}

	$$self.$$set = $$props => {
		if ('open' in $$props) $$invalidate(0, open = $$props.open);
		if ('clearAllOnThisPage' in $$props) $$invalidate(6, clearAllOnThisPage = $$props.clearAllOnThisPage);
	};

	$$self.$capture_state = () => ({
		Button,
		ContentDialog,
		RadioButton,
		TextBlock,
		getContext,
		open,
		clearAllOnThisPage,
		isLoading,
		t,
		tt,
		update,
		clear,
		group
	});

	$$self.$inject_state = $$props => {
		if ('open' in $$props) $$invalidate(0, open = $$props.open);
		if ('clearAllOnThisPage' in $$props) $$invalidate(6, clearAllOnThisPage = $$props.clearAllOnThisPage);
		if ('isLoading' in $$props) $$invalidate(1, isLoading = $$props.isLoading);
		if ('group' in $$props) $$invalidate(2, group = $$props.group);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		open,
		isLoading,
		group,
		t,
		tt,
		clear,
		clearAllOnThisPage,
		click_handler,
		radiobutton_group_binding,
		radiobutton_group_binding_1,
		contentdialog_open_binding
	];
}

class ClearDialog extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { open: 0, clearAllOnThisPage: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ClearDialog",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*open*/ ctx[0] === undefined && !('open' in props)) {
			console.warn("<ClearDialog> was created without expected prop 'open'");
		}

		if (/*clearAllOnThisPage*/ ctx[6] === undefined && !('clearAllOnThisPage' in props)) {
			console.warn("<ClearDialog> was created without expected prop 'clearAllOnThisPage'");
		}
	}

	get open() {
		throw new Error("<ClearDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<ClearDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clearAllOnThisPage() {
		throw new Error("<ClearDialog>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set clearAllOnThisPage(value) {
		throw new Error("<ClearDialog>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ClearDialog;