/* DataClearer.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	add_flush_callback,
	add_location,
	bind,
	binding_callbacks,
	component_subscribe,
	create_component,
	destroy_component,
	detach_dev,
	dispatch_dev,
	element,
	init,
	insert_dev,
	mount_component,
	noop,
	safe_not_equal,
	set_data_dev,
	set_store_value,
	space,
	text,
	transition_in,
	transition_out,
	validate_slots,
	validate_store
} from "nereid://.svelte/internal/index.mjs";

import { ContentDialog, Button, Checkbox, TextBlock } from "../../modules/fluent-svelte/index.js";
import { getContext } from "nereid://.svelte/internal/index.mjs";
const file = "DataClearer.svelte";

// (62:2) <Checkbox bind:checked={clear.cache}>
function create_default_slot_9(ctx) {
	let t_1_value = /*t*/ ctx[4]('pages.settings.privacy.clearData.dialog.cache') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(62:2) <Checkbox bind:checked={clear.cache}>",
		ctx
	});

	return block;
}

// (63:2) <Checkbox bind:checked={clear.cookies}>
function create_default_slot_8(ctx) {
	let t_1_value = /*t*/ ctx[4]('pages.settings.privacy.clearData.dialog.cookies') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(63:2) <Checkbox bind:checked={clear.cookies}>",
		ctx
	});

	return block;
}

// (64:2) <Checkbox bind:checked={clear.storages}>
function create_default_slot_7(ctx) {
	let t_1_value = /*t*/ ctx[4]('pages.settings.privacy.clearData.dialog.storages') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(64:2) <Checkbox bind:checked={clear.storages}>",
		ctx
	});

	return block;
}

// (65:2) <Checkbox bind:checked={clear.history}>
function create_default_slot_6(ctx) {
	let t_1_value = /*t*/ ctx[4]('pages.settings.privacy.clearData.dialog.history') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(65:2) <Checkbox bind:checked={clear.history}>",
		ctx
	});

	return block;
}

// (66:2) <Checkbox bind:checked={clear.downs}>
function create_default_slot_5(ctx) {
	let t_1_value = /*t*/ ctx[4]('pages.settings.privacy.clearData.dialog.downloads') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(66:2) <Checkbox bind:checked={clear.downs}>",
		ctx
	});

	return block;
}

// (67:2) <TextBlock variant="caption" style="color: gray;">
function create_default_slot_4(ctx) {
	let t_1_value = /*t*/ ctx[4]('pages.settings.privacy.clearData.dialog.notice') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(67:2) <TextBlock variant=\\\"caption\\\" style=\\\"color: gray;\\\">",
		ctx
	});

	return block;
}

// (70:2) <Checkbox bind:checked={clear.siteSettings}>
function create_default_slot_3(ctx) {
	let t_1_value = /*t*/ ctx[4]('pages.settings.privacy.clearData.dialog.permissions') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(70:2) <Checkbox bind:checked={clear.siteSettings}>",
		ctx
	});

	return block;
}

// (61:0) <ContentDialog size="max" title={t('pages.settings.privacy.clearData.dialog.title')} append={document.body} bind:open closable={false}>
function create_default_slot_2(ctx) {
	let checkbox0;
	let updating_checked;
	let br0;
	let t0;
	let checkbox1;
	let updating_checked_1;
	let br1;
	let t1;
	let checkbox2;
	let updating_checked_2;
	let br2;
	let t2;
	let checkbox3;
	let updating_checked_3;
	let br3;
	let t3;
	let checkbox4;
	let updating_checked_4;
	let br4;
	let t4;
	let textblock;
	let t5;
	let checkbox5;
	let updating_checked_5;
	let br5;
	let current;

	function checkbox0_checked_binding(value) {
		/*checkbox0_checked_binding*/ ctx[7](value);
	}

	let checkbox0_props = {
		$$slots: { default: [create_default_slot_9] },
		$$scope: { ctx }
	};

	if (/*clear*/ ctx[2].cache !== void 0) {
		checkbox0_props.checked = /*clear*/ ctx[2].cache;
	}

	checkbox0 = new Checkbox({ props: checkbox0_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox0, 'checked', checkbox0_checked_binding));

	function checkbox1_checked_binding(value) {
		/*checkbox1_checked_binding*/ ctx[8](value);
	}

	let checkbox1_props = {
		$$slots: { default: [create_default_slot_8] },
		$$scope: { ctx }
	};

	if (/*clear*/ ctx[2].cookies !== void 0) {
		checkbox1_props.checked = /*clear*/ ctx[2].cookies;
	}

	checkbox1 = new Checkbox({ props: checkbox1_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox1, 'checked', checkbox1_checked_binding));

	function checkbox2_checked_binding(value) {
		/*checkbox2_checked_binding*/ ctx[9](value);
	}

	let checkbox2_props = {
		$$slots: { default: [create_default_slot_7] },
		$$scope: { ctx }
	};

	if (/*clear*/ ctx[2].storages !== void 0) {
		checkbox2_props.checked = /*clear*/ ctx[2].storages;
	}

	checkbox2 = new Checkbox({ props: checkbox2_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox2, 'checked', checkbox2_checked_binding));

	function checkbox3_checked_binding(value) {
		/*checkbox3_checked_binding*/ ctx[10](value);
	}

	let checkbox3_props = {
		$$slots: { default: [create_default_slot_6] },
		$$scope: { ctx }
	};

	if (/*clear*/ ctx[2].history !== void 0) {
		checkbox3_props.checked = /*clear*/ ctx[2].history;
	}

	checkbox3 = new Checkbox({ props: checkbox3_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox3, 'checked', checkbox3_checked_binding));

	function checkbox4_checked_binding(value) {
		/*checkbox4_checked_binding*/ ctx[11](value);
	}

	let checkbox4_props = {
		$$slots: { default: [create_default_slot_5] },
		$$scope: { ctx }
	};

	if (/*clear*/ ctx[2].downs !== void 0) {
		checkbox4_props.checked = /*clear*/ ctx[2].downs;
	}

	checkbox4 = new Checkbox({ props: checkbox4_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox4, 'checked', checkbox4_checked_binding));

	textblock = new TextBlock({
			props: {
				variant: "caption",
				style: "color: gray;",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	function checkbox5_checked_binding(value) {
		/*checkbox5_checked_binding*/ ctx[12](value);
	}

	let checkbox5_props = {
		$$slots: { default: [create_default_slot_3] },
		$$scope: { ctx }
	};

	if (/*clear*/ ctx[2].siteSettings !== void 0) {
		checkbox5_props.checked = /*clear*/ ctx[2].siteSettings;
	}

	checkbox5 = new Checkbox({ props: checkbox5_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox5, 'checked', checkbox5_checked_binding));

	const block = {
		c: function create() {
			create_component(checkbox0.$$.fragment);
			br0 = element("br");
			t0 = space();
			create_component(checkbox1.$$.fragment);
			br1 = element("br");
			t1 = space();
			create_component(checkbox2.$$.fragment);
			br2 = element("br");
			t2 = space();
			create_component(checkbox3.$$.fragment);
			br3 = element("br");
			t3 = space();
			create_component(checkbox4.$$.fragment);
			br4 = element("br");
			t4 = space();
			create_component(textblock.$$.fragment);
			t5 = space();
			create_component(checkbox5.$$.fragment);
			br5 = element("br");
			add_location(br0, file, 61, 102, 1629);
			add_location(br1, file, 62, 106, 1741);
			add_location(br2, file, 63, 108, 1855);
			add_location(br3, file, 64, 106, 1967);
			add_location(br4, file, 65, 106, 2079);
			add_location(br5, file, 69, 115, 2329);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox0, target, anchor);
			insert_dev(target, br0, anchor);
			insert_dev(target, t0, anchor);
			mount_component(checkbox1, target, anchor);
			insert_dev(target, br1, anchor);
			insert_dev(target, t1, anchor);
			mount_component(checkbox2, target, anchor);
			insert_dev(target, br2, anchor);
			insert_dev(target, t2, anchor);
			mount_component(checkbox3, target, anchor);
			insert_dev(target, br3, anchor);
			insert_dev(target, t3, anchor);
			mount_component(checkbox4, target, anchor);
			insert_dev(target, br4, anchor);
			insert_dev(target, t4, anchor);
			mount_component(textblock, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(checkbox5, target, anchor);
			insert_dev(target, br5, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox0_changes = {};

			if (dirty & /*$$scope*/ 131072) {
				checkbox0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_checked && dirty & /*clear*/ 4) {
				updating_checked = true;
				checkbox0_changes.checked = /*clear*/ ctx[2].cache;
				add_flush_callback(() => updating_checked = false);
			}

			checkbox0.$set(checkbox0_changes);
			const checkbox1_changes = {};

			if (dirty & /*$$scope*/ 131072) {
				checkbox1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_checked_1 && dirty & /*clear*/ 4) {
				updating_checked_1 = true;
				checkbox1_changes.checked = /*clear*/ ctx[2].cookies;
				add_flush_callback(() => updating_checked_1 = false);
			}

			checkbox1.$set(checkbox1_changes);
			const checkbox2_changes = {};

			if (dirty & /*$$scope*/ 131072) {
				checkbox2_changes.$$scope = { dirty, ctx };
			}

			if (!updating_checked_2 && dirty & /*clear*/ 4) {
				updating_checked_2 = true;
				checkbox2_changes.checked = /*clear*/ ctx[2].storages;
				add_flush_callback(() => updating_checked_2 = false);
			}

			checkbox2.$set(checkbox2_changes);
			const checkbox3_changes = {};

			if (dirty & /*$$scope*/ 131072) {
				checkbox3_changes.$$scope = { dirty, ctx };
			}

			if (!updating_checked_3 && dirty & /*clear*/ 4) {
				updating_checked_3 = true;
				checkbox3_changes.checked = /*clear*/ ctx[2].history;
				add_flush_callback(() => updating_checked_3 = false);
			}

			checkbox3.$set(checkbox3_changes);
			const checkbox4_changes = {};

			if (dirty & /*$$scope*/ 131072) {
				checkbox4_changes.$$scope = { dirty, ctx };
			}

			if (!updating_checked_4 && dirty & /*clear*/ 4) {
				updating_checked_4 = true;
				checkbox4_changes.checked = /*clear*/ ctx[2].downs;
				add_flush_callback(() => updating_checked_4 = false);
			}

			checkbox4.$set(checkbox4_changes);
			const textblock_changes = {};

			if (dirty & /*$$scope*/ 131072) {
				textblock_changes.$$scope = { dirty, ctx };
			}

			textblock.$set(textblock_changes);
			const checkbox5_changes = {};

			if (dirty & /*$$scope*/ 131072) {
				checkbox5_changes.$$scope = { dirty, ctx };
			}

			if (!updating_checked_5 && dirty & /*clear*/ 4) {
				updating_checked_5 = true;
				checkbox5_changes.checked = /*clear*/ ctx[2].siteSettings;
				add_flush_callback(() => updating_checked_5 = false);
			}

			checkbox5.$set(checkbox5_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox0.$$.fragment, local);
			transition_in(checkbox1.$$.fragment, local);
			transition_in(checkbox2.$$.fragment, local);
			transition_in(checkbox3.$$.fragment, local);
			transition_in(checkbox4.$$.fragment, local);
			transition_in(textblock.$$.fragment, local);
			transition_in(checkbox5.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox0.$$.fragment, local);
			transition_out(checkbox1.$$.fragment, local);
			transition_out(checkbox2.$$.fragment, local);
			transition_out(checkbox3.$$.fragment, local);
			transition_out(checkbox4.$$.fragment, local);
			transition_out(textblock.$$.fragment, local);
			transition_out(checkbox5.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox0, detaching);
			if (detaching) detach_dev(br0);
			if (detaching) detach_dev(t0);
			destroy_component(checkbox1, detaching);
			if (detaching) detach_dev(br1);
			if (detaching) detach_dev(t1);
			destroy_component(checkbox2, detaching);
			if (detaching) detach_dev(br2);
			if (detaching) detach_dev(t2);
			destroy_component(checkbox3, detaching);
			if (detaching) detach_dev(br3);
			if (detaching) detach_dev(t3);
			destroy_component(checkbox4, detaching);
			if (detaching) detach_dev(br4);
			if (detaching) detach_dev(t4);
			destroy_component(textblock, detaching);
			if (detaching) detach_dev(t5);
			destroy_component(checkbox5, detaching);
			if (detaching) detach_dev(br5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(61:0) <ContentDialog size=\\\"max\\\" title={t('pages.settings.privacy.clearData.dialog.title')} append={document.body} bind:open closable={false}>",
		ctx
	});

	return block;
}

// (73:4) <Button on:click={() => open = false}>
function create_default_slot_1(ctx) {
	let t_1_value = /*t*/ ctx[4]('common.cancel') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(73:4) <Button on:click={() => open = false}>",
		ctx
	});

	return block;
}

// (74:4) <Button on:click={clearSelected} variant="accent" disabled={isLoading}>
function create_default_slot(ctx) {
	let t_1_value = (/*isLoading*/ ctx[1]
	? /*t*/ ctx[4]('common.loading')
	: /*t*/ ctx[4]('pages.settings.privacy.clearData.dialog.clear-button')) + "";

	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*isLoading*/ 2 && t_1_value !== (t_1_value = (/*isLoading*/ ctx[1]
			? /*t*/ ctx[4]('common.loading')
			: /*t*/ ctx[4]('pages.settings.privacy.clearData.dialog.clear-button')) + "")) set_data_dev(t_1, t_1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(74:4) <Button on:click={clearSelected} variant=\\\"accent\\\" disabled={isLoading}>",
		ctx
	});

	return block;
}

// (72:2) <svelte:fragment slot="footer">
function create_footer_slot(ctx) {
	let button0;
	let t_1;
	let button1;
	let current;

	button0 = new Button({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*click_handler*/ ctx[6]);

	button1 = new Button({
			props: {
				variant: "accent",
				disabled: /*isLoading*/ ctx[1],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*clearSelected*/ ctx[5]);

	const block = {
		c: function create() {
			create_component(button0.$$.fragment);
			t_1 = space();
			create_component(button1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(button0, target, anchor);
			insert_dev(target, t_1, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button0_changes = {};

			if (dirty & /*$$scope*/ 131072) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty & /*isLoading*/ 2) button1_changes.disabled = /*isLoading*/ ctx[1];

			if (dirty & /*$$scope, isLoading*/ 131074) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach_dev(t_1);
			destroy_component(button1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(72:2) <svelte:fragment slot=\\\"footer\\\">",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let contentdialog;
	let updating_open;
	let current;

	function contentdialog_open_binding(value) {
		/*contentdialog_open_binding*/ ctx[13](value);
	}

	let contentdialog_props = {
		size: "max",
		title: /*t*/ ctx[4]('pages.settings.privacy.clearData.dialog.title'),
		append: document.body,
		closable: false,
		$$slots: {
			footer: [create_footer_slot],
			default: [create_default_slot_2]
		},
		$$scope: { ctx }
	};

	if (/*open*/ ctx[0] !== void 0) {
		contentdialog_props.open = /*open*/ ctx[0];
	}

	contentdialog = new ContentDialog({
			props: contentdialog_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(contentdialog, 'open', contentdialog_open_binding));

	const block = {
		c: function create() {
			create_component(contentdialog.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(contentdialog, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const contentdialog_changes = {};

			if (dirty & /*$$scope, isLoading, open, clear*/ 131079) {
				contentdialog_changes.$$scope = { dirty, ctx };
			}

			if (!updating_open && dirty & /*open*/ 1) {
				updating_open = true;
				contentdialog_changes.open = /*open*/ ctx[0];
				add_flush_callback(() => updating_open = false);
			}

			contentdialog.$set(contentdialog_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(contentdialog.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(contentdialog.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(contentdialog, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $config;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('DataClearer', slots, []);
	let { open = false } = $$props;
	const { session, userdata } = window.nereid;
	const config = getContext('config');
	validate_store(config, 'config');
	component_subscribe($$self, config, value => $$invalidate(14, $config = value));
	const { t } = window.nereid.i18n;
	let isLoading = false;

	let clear = {
		cache: true,
		cookies: true,
		storages: false,
		history: false,
		downs: false,
		siteSettings: false
	};

	async function clearSelected() {
		$$invalidate(1, isLoading = true);
		let clearObj = {};

		if (clear.cache) {
			clearObj.appcache = true;
			clearObj.shadercache = true;
			clearObj.cachestorage = true;
		}

		if (clear.cookies) {
			clearObj.cookies = true;
		}

		if (clear.storages) {
			clearObj.filesystem = true;
			clearObj.indexdb = true;
			clearObj.localstorage = true;
			clearObj.websql = true;
		}

		await session.clearData(clearObj);

		if (clear.history) {
			userdata.history.set([]);
		}

		if (clear.downs) {
			let dls = await userdata.downloads.get();

			dls.forEach((_, i) => {
				userdata.downloads.delete(i);
			});
		}

		if (clear.siteSettings) {
			set_store_value(config, $config.privacy.sitePermissions = {}, $config);
			userdata.config.set({ privacy: $config.privacy });
		}

		$$invalidate(1, isLoading = false);
		$$invalidate(0, open = false);
	}

	const writable_props = ['open'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DataClearer> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, open = false);

	function checkbox0_checked_binding(value) {
		if ($$self.$$.not_equal(clear.cache, value)) {
			clear.cache = value;
			$$invalidate(2, clear);
		}
	}

	function checkbox1_checked_binding(value) {
		if ($$self.$$.not_equal(clear.cookies, value)) {
			clear.cookies = value;
			$$invalidate(2, clear);
		}
	}

	function checkbox2_checked_binding(value) {
		if ($$self.$$.not_equal(clear.storages, value)) {
			clear.storages = value;
			$$invalidate(2, clear);
		}
	}

	function checkbox3_checked_binding(value) {
		if ($$self.$$.not_equal(clear.history, value)) {
			clear.history = value;
			$$invalidate(2, clear);
		}
	}

	function checkbox4_checked_binding(value) {
		if ($$self.$$.not_equal(clear.downs, value)) {
			clear.downs = value;
			$$invalidate(2, clear);
		}
	}

	function checkbox5_checked_binding(value) {
		if ($$self.$$.not_equal(clear.siteSettings, value)) {
			clear.siteSettings = value;
			$$invalidate(2, clear);
		}
	}

	function contentdialog_open_binding(value) {
		open = value;
		$$invalidate(0, open);
	}

	$$self.$$set = $$props => {
		if ('open' in $$props) $$invalidate(0, open = $$props.open);
	};

	$$self.$capture_state = () => ({
		ContentDialog,
		Button,
		Checkbox,
		TextBlock,
		getContext,
		open,
		session,
		userdata,
		config,
		t,
		isLoading,
		clear,
		clearSelected,
		$config
	});

	$$self.$inject_state = $$props => {
		if ('open' in $$props) $$invalidate(0, open = $$props.open);
		if ('isLoading' in $$props) $$invalidate(1, isLoading = $$props.isLoading);
		if ('clear' in $$props) $$invalidate(2, clear = $$props.clear);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		open,
		isLoading,
		clear,
		config,
		t,
		clearSelected,
		click_handler,
		checkbox0_checked_binding,
		checkbox1_checked_binding,
		checkbox2_checked_binding,
		checkbox3_checked_binding,
		checkbox4_checked_binding,
		checkbox5_checked_binding,
		contentdialog_open_binding
	];
}

class DataClearer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { open: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DataClearer",
			options,
			id: create_fragment.name
		});
	}

	get open() {
		throw new Error("<DataClearer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<DataClearer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default DataClearer;