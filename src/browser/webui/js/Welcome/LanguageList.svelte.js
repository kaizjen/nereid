/* LanguageList.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	add_flush_callback,
	bind,
	binding_callbacks,
	check_outros,
	create_component,
	destroy_component,
	detach_dev,
	dispatch_dev,
	empty,
	globals,
	group_outros,
	init,
	insert_dev,
	mount_component,
	safe_not_equal,
	space,
	text,
	transition_in,
	transition_out,
	validate_slots
} from "nereid://.svelte/internal/index.mjs";

const { console: console_1 } = globals;
import { AutoSuggestBox, RadioButton, TextBlock } from "../modules/fluent-svelte/index.js";
import Codes from "../modules/iso-639-1/src/index.js";
const file = "LanguageList.svelte";

// (42:0) {#if error}
function create_if_block(ctx) {
	let textblock;
	let current;

	textblock = new TextBlock({
			props: {
				variant: "bodyStrong",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(textblock.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(textblock, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textblock.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textblock.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textblock, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(42:0) {#if error}",
		ctx
	});

	return block;
}

// (43:2) <TextBlock variant="bodyStrong">
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Invalid or unsupported language");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(43:2) <TextBlock variant=\\\"bodyStrong\\\">",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let autosuggestbox;
	let updating_value;
	let t;
	let if_block_anchor;
	let current;

	function autosuggestbox_value_binding(value) {
		/*autosuggestbox_value_binding*/ ctx[6](value);
	}

	let autosuggestbox_props = {
		items: /*languages*/ ctx[2].map(Codes.getNativeName).filter(uniq)
	};

	if (/*value*/ ctx[0] !== void 0) {
		autosuggestbox_props.value = /*value*/ ctx[0];
	}

	autosuggestbox = new AutoSuggestBox({
			props: autosuggestbox_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(autosuggestbox, 'value', autosuggestbox_value_binding));
	let if_block = /*error*/ ctx[1] && create_if_block(ctx);

	const block = {
		c: function create() {
			create_component(autosuggestbox.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(autosuggestbox, target, anchor);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const autosuggestbox_changes = {};

			if (!updating_value && dirty & /*value*/ 1) {
				updating_value = true;
				autosuggestbox_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			autosuggestbox.$set(autosuggestbox_changes);

			if (/*error*/ ctx[1]) {
				if (if_block) {
					if (dirty & /*error*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(autosuggestbox.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(autosuggestbox.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(autosuggestbox, detaching);
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function uniq(value, index, self) {
	return self.indexOf(value) === index;
}

function instance($$self, $$props, $$invalidate) {
	let value_proxy;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('LanguageList', slots, []);
	let { selected } = $$props;
	let { onlyAvailable = false } = $$props;

	const languages = onlyAvailable
	? window.nereid.i18n.getAvailableTranslations()
	: Codes.getAllCodes();

	let value = Codes.getNativeName(selected);
	let error = false;
	const writable_props = ['selected', 'onlyAvailable'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<LanguageList> was created with unknown prop '${key}'`);
	});

	function autosuggestbox_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('selected' in $$props) $$invalidate(3, selected = $$props.selected);
		if ('onlyAvailable' in $$props) $$invalidate(4, onlyAvailable = $$props.onlyAvailable);
	};

	$$self.$capture_state = () => ({
		AutoSuggestBox,
		RadioButton,
		TextBlock,
		Codes,
		selected,
		onlyAvailable,
		languages,
		value,
		error,
		uniq,
		value_proxy
	});

	$$self.$inject_state = $$props => {
		if ('selected' in $$props) $$invalidate(3, selected = $$props.selected);
		if ('onlyAvailable' in $$props) $$invalidate(4, onlyAvailable = $$props.onlyAvailable);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('error' in $$props) $$invalidate(1, error = $$props.error);
		if ('value_proxy' in $$props) $$invalidate(5, value_proxy = $$props.value_proxy);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			$: $$invalidate(5, value_proxy = value ?? ''); // sometimes <AutoSuggestBox> gives null
		}

		if ($$self.$$.dirty & /*value_proxy, selected*/ 40) {
			$: {
				if (!Codes.getCode(value_proxy)) {
					$$invalidate(1, error = true);
				} else {
					$$invalidate(3, selected = Codes.getCode(value_proxy));
					$$invalidate(1, error = false);
				}

				if (!languages.includes(selected)) {
					console.log('%o no inc %o', languages, selected);
					$$invalidate(1, error = true);
				}
			}
		}
	};

	return [
		value,
		error,
		languages,
		selected,
		onlyAvailable,
		value_proxy,
		autosuggestbox_value_binding
	];
}

class LanguageList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { selected: 3, onlyAvailable: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LanguageList",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*selected*/ ctx[3] === undefined && !('selected' in props)) {
			console_1.warn("<LanguageList> was created without expected prop 'selected'");
		}
	}

	get selected() {
		throw new Error("<LanguageList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<LanguageList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onlyAvailable() {
		throw new Error("<LanguageList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onlyAvailable(value) {
		throw new Error("<LanguageList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default LanguageList;