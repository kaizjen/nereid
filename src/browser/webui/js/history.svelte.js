/* history.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	add_flush_callback,
	add_location,
	append_dev,
	append_styles,
	attr_dev,
	bind,
	binding_callbacks,
	check_outros,
	create_component,
	destroy_component,
	destroy_each,
	detach_dev,
	dispatch_dev,
	element,
	empty,
	globals,
	group_outros,
	handle_promise,
	init,
	insert_dev,
	mount_component,
	noop,
	safe_not_equal,
	space,
	text,
	transition_in,
	transition_out,
	update_await_block_branch,
	validate_each_argument,
	validate_slots
} from "nereid://.svelte/internal/index.mjs";

const { Object: Object_1 } = globals;
import { IconButton, Button, ProgressRing } from "./modules/fluent-svelte/index.js";
import { setContext } from "nereid://.svelte/index.mjs";
import Header from "./common/Header.svelte.js";
import ByDate from "./History/ByDate.svelte.js";
import ClearDialog from "./History/ClearDialog.svelte.js";
import * as Icons from "./icons.js";
const file = "history.svelte";

function add_css(target) {
	append_styles(target, "svelte-11br7ho", "header.svelte-11br7ho{position:fixed;width:100%;top:0;backdrop-filter:blur(4px)}.container.svelte-11br7ho{display:flex;justify-content:center;align-items:center;margin-top:85px}main.svelte-11br7ho{width:24cm}.action-bar.svelte-11br7ho{display:flex;padding:8px;justify-content:space-between}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGlzdG9yeS5zdmVsdGUiLCJzb3VyY2VzIjpbImhpc3Rvcnkuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzdHlsZT5cclxuICBoZWFkZXIge1xyXG4gICAgcG9zaXRpb246IGZpeGVkO1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICB0b3A6IDA7XHJcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoNHB4KTtcclxuICB9XHJcbiAgLmNvbnRhaW5lciB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgbWFyZ2luLXRvcDogODVweDtcclxuICB9XHJcbiAgbWFpbiB7XHJcbiAgICB3aWR0aDogMjRjbTtcclxuICB9XHJcblxyXG4gIC5hY3Rpb24tYmFyIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBwYWRkaW5nOiA4cHg7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcbiAgfVxyXG48L3N0eWxlPlxyXG48c2NyaXB0PlxyXG4gIGltcG9ydCB7IEljb25CdXR0b24sIEJ1dHRvbiwgUHJvZ3Jlc3NSaW5nIH0gZnJvbSBcImZsdWVudC1zdmVsdGVcIjtcclxuICBpbXBvcnQgeyBzZXRDb250ZXh0IH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG4gIGltcG9ydCBIZWFkZXIgZnJvbSBcIi4vY29tbW9uL0hlYWRlci5zdmVsdGVcIjtcclxuICBpbXBvcnQgQnlEYXRlIGZyb20gXCIuL0hpc3RvcnkvQnlEYXRlLnN2ZWx0ZVwiO1xyXG4gIGltcG9ydCBDbGVhckRpYWxvZyBmcm9tIFwiLi9IaXN0b3J5L0NsZWFyRGlhbG9nLnN2ZWx0ZVwiO1xyXG4gIGltcG9ydCAqIGFzIEljb25zIGZyb20gXCIuL2ljb25zLmpzXCI7XHJcblxyXG4gIGNvbnN0IHsgdCB9ID0gd2luZG93Lm5lcmVpZC5pMThuO1xyXG4gIGZ1bmN0aW9uIHR0KHN0ciwgLi4uYXJncykge1xyXG4gICAgcmV0dXJuIHQoYHBhZ2VzLmhpc3RvcnkuJHtzdHJ9YCwgLi4uYXJncylcclxuICB9XHJcblxyXG4gIGNvbnN0IGZtdCA9IEludGwuRGF0ZVRpbWVGb3JtYXQoKVxyXG5cclxuICBjb25zdCBFTlRSSUVTX0JZX1BBR0UgPSA1MDtcclxuICBsZXQgY3VycmVudFBhZ2UgPSAwO1xyXG4gIFxyXG4gIGxldCBlbnRyaWVzID0gW107XHJcbiAgbGV0IHByb21pc2U7XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZShhc3luYyh5KSA9PiB7XHJcbiAgICAgIGxldCB1bmZpbHRlcmVkID0gYXdhaXQgd2luZG93Lm5lcmVpZC51c2VyZGF0YS5oaXN0b3J5LmdldCh7IGVudHJpZXM6IEVOVFJJRVNfQllfUEFHRSwgb2Zmc2V0OiBFTlRSSUVTX0JZX1BBR0UgKiBjdXJyZW50UGFnZSB9KVxyXG4gICAgICBlbnRyaWVzID0gdW5maWx0ZXJlZFxyXG4gICAgICAgIC5maWx0ZXIobyA9PiAhIW8pIC8vIGN1cnJlbnQgaW1wbCByZXR1cm5zIGFsd2F5cyB0aGUgYW1vdW50IHNwZWNpZmllZCBieSBcImVudHJpZXNcIlxyXG4gICAgICAgIC5tYXAoKGUsIGkpID0+IHtcclxuICAgICAgICAgIGUub3JpZ2luYWxJbmRleCA9IChFTlRSSUVTX0JZX1BBR0UgKiBjdXJyZW50UGFnZSkgKyBpO1xyXG4gICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgfSlcclxuICAgICAgO1xyXG4gICAgICB5KCk7XHJcblxyXG4gICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKGFzeW5jKCkgPT4ge1xyXG4gICAgICAgIGxldCBuZXh0ID0gYXdhaXQgd2luZG93Lm5lcmVpZC51c2VyZGF0YS5oaXN0b3J5LmdldCh7IGVudHJpZXM6IDEsIG9mZnNldDogRU5UUklFU19CWV9QQUdFICogKGN1cnJlbnRQYWdlICsgMSkgfSlcclxuICAgICAgICBpZiAobmV4dFswXSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGVuZFJlYWNoZWQgPSB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGxldCBlbmRSZWFjaGVkID0gZmFsc2U7XHJcbiAgY29uc3QgcGFnZSA9IHtcclxuICAgIGZ3ZCgpIHtcclxuICAgICAgaWYgKGVuZFJlYWNoZWQpIHJldHVybjtcclxuXHJcbiAgICAgIGN1cnJlbnRQYWdlICs9IDE7XHJcbiAgICAgIHVwZGF0ZSgpXHJcbiAgICB9LFxyXG4gICAgYmFjaygpIHtcclxuICAgICAgaWYgKGN1cnJlbnRQYWdlID09IDApIHJldHVybjtcclxuXHJcbiAgICAgIGN1cnJlbnRQYWdlIC09IDE7XHJcbiAgICAgIGVuZFJlYWNoZWQgPSBmYWxzZTtcclxuICAgICAgdXBkYXRlKClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxldCBlbnRyaWVzQnlEYXRlID0ge307XHJcbiAgZnVuY3Rpb24gdXBkYXRlRW50cmllc0J5RGF0ZSgpIHtcclxuICAgIGVudHJpZXNCeURhdGUgPSB7fTtcclxuICAgIGVudHJpZXMuZm9yRWFjaCgoZSwgaSkgPT4ge1xyXG4gICAgICBjb25zdCBkYXkgPSBmbXQuZm9ybWF0KGUudGltZXN0YW1wKTtcclxuICAgICAgY29uc3QgZGF0ZUtleSA9IChuZXcgRGF0ZShkYXkpKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICBpZiAoZGF0ZUtleSBpbiBlbnRyaWVzQnlEYXRlKSB7XHJcbiAgICAgICAgZW50cmllc0J5RGF0ZVtkYXRlS2V5XS5wdXNoKGUpXHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVudHJpZXNCeURhdGVbZGF0ZUtleV0gPSBbIGUgXVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuICAkOiB7ZW50cmllczsgdXBkYXRlRW50cmllc0J5RGF0ZSgpfVxyXG5cclxuICB1cGRhdGUoKVxyXG5cclxuICBzZXRDb250ZXh0KCd1cGRhdGUnLCB1cGRhdGUpXHJcblxyXG4gIGxldCBvcGVuID0gZmFsc2U7XHJcblxyXG4gIGFzeW5jIGZ1bmN0aW9uIGNsZWFyQWxsT25UaGlzUGFnZSgpIHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGZvciAoY29uc3QgeyBvcmlnaW5hbEluZGV4IH0gb2YgZW50cmllcykge1xyXG4gICAgICBhd2FpdCBuZXJlaWQudXNlcmRhdGEuaGlzdG9yeS5kZWxBdCh7IGluZGV4OiBvcmlnaW5hbEluZGV4IC0gaSB9KVxyXG4gICAgICAvLyBuZWVkIHRvIHN1YnRyYWN0IGBpYCBiZWNhdXNlIHdoZW4geW91IGRlbGV0ZSBhIGguIGVudHJ5LCBhbGwgb3RoZXIgaW5kZXhlcyBzaGlmdFxyXG4gICAgICBpKys7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoKTtcclxuICB9XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN2ZWx0ZTpoZWFkPlxyXG4gIDx0aXRsZT57dCgnY29tbW9uLmhpc3RvcnknKX08L3RpdGxlPlxyXG48L3N2ZWx0ZTpoZWFkPlxyXG5cclxuPENsZWFyRGlhbG9nIGJpbmQ6b3BlbiB7Y2xlYXJBbGxPblRoaXNQYWdlfSAvPlxyXG48aGVhZGVyPlxyXG4gIDxIZWFkZXIgbmFtZT1cImhpc3RvcnlcIj5cclxuICAgIDxJY29ucy5IaXN0b3J5IC8+XHJcbiAgPC9IZWFkZXI+XHJcbjwvaGVhZGVyPlxyXG48ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XHJcbiAgPG1haW4+XHJcbiAgICA8ZGl2IGNsYXNzPVwiYWN0aW9uLWJhclwiPlxyXG4gICAgICA8ZGl2PlxyXG4gICAgICAgIDxJY29uQnV0dG9uIG9uOmNsaWNrPXtwYWdlLmJhY2t9IHN0eWxlPVwib3BhY2l0eToge2N1cnJlbnRQYWdlID09IDAgPyBcIjAuNVwiIDogXCIxXCJ9O1wiPlxyXG4gICAgICAgICAgPEljb25zLkFycm93QmFjayB0aXRsZT17dCgnbmF2aWdhdGlvbi5iYWNrJyl9IC8+XHJcbiAgICAgICAgPC9JY29uQnV0dG9uPlxyXG4gICAgICAgIDxJY29uQnV0dG9uIG9uOmNsaWNrPXtwYWdlLmZ3ZH0gc3R5bGU9XCJvcGFjaXR5OiB7ZW5kUmVhY2hlZCA/IFwiMC41XCIgOiBcIjFcIn07XCI+XHJcbiAgICAgICAgICA8SWNvbnMuQXJyb3dGd2QgdGl0bGU9e3QoJ25hdmlnYXRpb24uZm9yd2FyZCcpfSAvPlxyXG4gICAgICAgIDwvSWNvbkJ1dHRvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxCdXR0b24gb246Y2xpY2s9eygpID0+IG9wZW4gPSB0cnVlfT5cclxuICAgICAgICB7dHQoJ2J1dHRvbi1jbGVhcicpfVxyXG4gICAgICA8L0J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG4gICAgeyNhd2FpdCBwcm9taXNlfVxyXG4gICAgICA8UHJvZ3Jlc3NSaW5nIC8+XHJcbiAgICB7OnRoZW4gX31cclxuICAgICAgeyNlYWNoIE9iamVjdC5rZXlzKGVudHJpZXNCeURhdGUpIGFzIGRhdGV9XHJcbiAgICAgICAgPEJ5RGF0ZSB7ZGF0ZX0gZW50cmllcz17ZW50cmllc0J5RGF0ZVtkYXRlXX0gLz5cclxuICAgICAgezplbHNlfVxyXG4gICAgICAgIHt0dCgnZW1wdHknKX1cclxuICAgICAgey9lYWNofVxyXG4gICAgezpjYXRjaH1cclxuICAgICAgRXJyb3IhXHJcbiAgICB7L2F3YWl0fVxyXG4gIDwvbWFpbj5cclxuPC9kaXY+Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNFLE1BQU0sZUFBQyxDQUFDLEFBQ04sUUFBUSxDQUFFLEtBQUssQ0FDZixLQUFLLENBQUUsSUFBSSxDQUNYLEdBQUcsQ0FBRSxDQUFDLENBQ04sZUFBZSxDQUFFLEtBQUssR0FBRyxDQUFDLEFBQzVCLENBQUMsQUFDRCxVQUFVLGVBQUMsQ0FBQyxBQUNWLE9BQU8sQ0FBRSxJQUFJLENBQ2IsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsVUFBVSxDQUFFLElBQUksQUFDbEIsQ0FBQyxBQUNELElBQUksZUFBQyxDQUFDLEFBQ0osS0FBSyxDQUFFLElBQUksQUFDYixDQUFDLEFBRUQsV0FBVyxlQUFDLENBQUMsQUFDWCxPQUFPLENBQUUsSUFBSSxDQUNiLE9BQU8sQ0FBRSxHQUFHLENBQ1osZUFBZSxDQUFFLGFBQWEsQUFDaEMsQ0FBQyJ9 */");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	return child_ctx;
}

// (123:2) <Header name="history">
function create_default_slot_3(ctx) {
	let icons_history;
	let current;
	icons_history = new Icons.History({ $$inline: true });

	const block = {
		c: function create() {
			create_component(icons_history.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icons_history, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icons_history.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icons_history.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icons_history, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(123:2) <Header name=\\\"history\\\">",
		ctx
	});

	return block;
}

// (131:8) <IconButton on:click={page.back} style="opacity: {currentPage == 0 ? "0.5" : "1"};">
function create_default_slot_2(ctx) {
	let icons_arrowback;
	let current;

	icons_arrowback = new Icons.ArrowBack({
			props: { title: /*t*/ ctx[5]('navigation.back') },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icons_arrowback.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icons_arrowback, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icons_arrowback.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icons_arrowback.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icons_arrowback, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(131:8) <IconButton on:click={page.back} style=\\\"opacity: {currentPage == 0 ? \\\"0.5\\\" : \\\"1\\\"};\\\">",
		ctx
	});

	return block;
}

// (134:8) <IconButton on:click={page.fwd} style="opacity: {endReached ? "0.5" : "1"};">
function create_default_slot_1(ctx) {
	let icons_arrowfwd;
	let current;

	icons_arrowfwd = new Icons.ArrowFwd({
			props: {
				title: /*t*/ ctx[5]('navigation.forward')
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icons_arrowfwd.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icons_arrowfwd, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icons_arrowfwd.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icons_arrowfwd.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icons_arrowfwd, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(134:8) <IconButton on:click={page.fwd} style=\\\"opacity: {endReached ? \\\"0.5\\\" : \\\"1\\\"};\\\">",
		ctx
	});

	return block;
}

// (138:6) <Button on:click={() => open = true}>
function create_default_slot(ctx) {
	let t_1_value = /*tt*/ ctx[6]('button-clear') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(138:6) <Button on:click={() => open = true}>",
		ctx
	});

	return block;
}

// (150:4) {:catch}
function create_catch_block(ctx) {
	let t_1;

	const block = {
		c: function create() {
			t_1 = text("Error!");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_catch_block.name,
		type: "catch",
		source: "(150:4) {:catch}",
		ctx
	});

	return block;
}

// (144:4) {:then _}
function create_then_block(ctx) {
	let each_1_anchor;
	let current;
	let each_value = Object.keys(/*entriesByDate*/ ctx[3]);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let each_1_else = null;

	if (!each_value.length) {
		each_1_else = create_else_block(ctx);
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();

			if (each_1_else) {
				each_1_else.c();
			}
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);

			if (each_1_else) {
				each_1_else.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*Object, entriesByDate, tt*/ 72) {
				each_value = Object.keys(/*entriesByDate*/ ctx[3]);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();

				if (!each_value.length && each_1_else) {
					each_1_else.p(ctx, dirty);
				} else if (!each_value.length) {
					each_1_else = create_else_block(ctx);
					each_1_else.c();
					each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
				} else if (each_1_else) {
					each_1_else.d(1);
					each_1_else = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
			if (each_1_else) each_1_else.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_then_block.name,
		type: "then",
		source: "(144:4) {:then _}",
		ctx
	});

	return block;
}

// (147:6) {:else}
function create_else_block(ctx) {
	let t_1_value = /*tt*/ ctx[6]('empty') + "";
	let t_1;

	const block = {
		c: function create() {
			t_1 = text(t_1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t_1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(147:6) {:else}",
		ctx
	});

	return block;
}

// (145:6) {#each Object.keys(entriesByDate) as date}
function create_each_block(ctx) {
	let bydate;
	let current;

	bydate = new ByDate({
			props: {
				date: /*date*/ ctx[16],
				entries: /*entriesByDate*/ ctx[3][/*date*/ ctx[16]]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(bydate.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(bydate, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const bydate_changes = {};
			if (dirty & /*entriesByDate*/ 8) bydate_changes.date = /*date*/ ctx[16];
			if (dirty & /*entriesByDate*/ 8) bydate_changes.entries = /*entriesByDate*/ ctx[3][/*date*/ ctx[16]];
			bydate.$set(bydate_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(bydate.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(bydate.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(bydate, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(145:6) {#each Object.keys(entriesByDate) as date}",
		ctx
	});

	return block;
}

// (142:20)         <ProgressRing />      {:then _}
function create_pending_block(ctx) {
	let progressring;
	let current;
	progressring = new ProgressRing({ $$inline: true });

	const block = {
		c: function create() {
			create_component(progressring.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(progressring, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(progressring.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(progressring.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(progressring, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_pending_block.name,
		type: "pending",
		source: "(142:20)         <ProgressRing />      {:then _}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let title_value;
	let t0;
	let cleardialog;
	let updating_open;
	let t1;
	let header1;
	let header0;
	let t2;
	let div2;
	let main;
	let div1;
	let div0;
	let iconbutton0;
	let t3;
	let iconbutton1;
	let t4;
	let button;
	let t5;
	let promise_1;
	let current;
	document.title = title_value = /*t*/ ctx[5]('common.history');

	function cleardialog_open_binding(value) {
		/*cleardialog_open_binding*/ ctx[10](value);
	}

	let cleardialog_props = {
		clearAllOnThisPage: /*clearAllOnThisPage*/ ctx[8]
	};

	if (/*open*/ ctx[4] !== void 0) {
		cleardialog_props.open = /*open*/ ctx[4];
	}

	cleardialog = new ClearDialog({ props: cleardialog_props, $$inline: true });
	binding_callbacks.push(() => bind(cleardialog, 'open', cleardialog_open_binding));

	header0 = new Header({
			props: {
				name: "history",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton0 = new IconButton({
			props: {
				style: "opacity: " + (/*currentPage*/ ctx[0] == 0 ? "0.5" : "1") + ";",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton0.$on("click", /*page*/ ctx[7].back);

	iconbutton1 = new IconButton({
			props: {
				style: "opacity: " + (/*endReached*/ ctx[2] ? "0.5" : "1") + ";",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton1.$on("click", /*page*/ ctx[7].fwd);

	button = new Button({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[11]);

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: true,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 15,
		blocks: [,,,]
	};

	handle_promise(promise_1 = /*promise*/ ctx[1], info);

	const block = {
		c: function create() {
			t0 = space();
			create_component(cleardialog.$$.fragment);
			t1 = space();
			header1 = element("header");
			create_component(header0.$$.fragment);
			t2 = space();
			div2 = element("div");
			main = element("main");
			div1 = element("div");
			div0 = element("div");
			create_component(iconbutton0.$$.fragment);
			t3 = space();
			create_component(iconbutton1.$$.fragment);
			t4 = space();
			create_component(button.$$.fragment);
			t5 = space();
			info.block.c();
			attr_dev(header1, "class", "svelte-11br7ho");
			add_location(header1, file, 121, 0, 2886);
			add_location(div0, file, 129, 6, 3041);
			attr_dev(div1, "class", "action-bar svelte-11br7ho");
			add_location(div1, file, 128, 4, 3009);
			attr_dev(main, "class", "svelte-11br7ho");
			add_location(main, file, 127, 2, 2997);
			attr_dev(div2, "class", "container svelte-11br7ho");
			add_location(div2, file, 126, 0, 2970);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			mount_component(cleardialog, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, header1, anchor);
			mount_component(header0, header1, null);
			insert_dev(target, t2, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, main);
			append_dev(main, div1);
			append_dev(div1, div0);
			mount_component(iconbutton0, div0, null);
			append_dev(div0, t3);
			mount_component(iconbutton1, div0, null);
			append_dev(div1, t4);
			mount_component(button, div1, null);
			append_dev(main, t5);
			info.block.m(main, info.anchor = null);
			info.mount = () => main;
			info.anchor = null;
			current = true;
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;

			if ((!current || dirty & /*t*/ 32) && title_value !== (title_value = /*t*/ ctx[5]('common.history'))) {
				document.title = title_value;
			}

			const cleardialog_changes = {};

			if (!updating_open && dirty & /*open*/ 16) {
				updating_open = true;
				cleardialog_changes.open = /*open*/ ctx[4];
				add_flush_callback(() => updating_open = false);
			}

			cleardialog.$set(cleardialog_changes);
			const header0_changes = {};

			if (dirty & /*$$scope*/ 524288) {
				header0_changes.$$scope = { dirty, ctx };
			}

			header0.$set(header0_changes);
			const iconbutton0_changes = {};
			if (dirty & /*currentPage*/ 1) iconbutton0_changes.style = "opacity: " + (/*currentPage*/ ctx[0] == 0 ? "0.5" : "1") + ";";

			if (dirty & /*$$scope*/ 524288) {
				iconbutton0_changes.$$scope = { dirty, ctx };
			}

			iconbutton0.$set(iconbutton0_changes);
			const iconbutton1_changes = {};
			if (dirty & /*endReached*/ 4) iconbutton1_changes.style = "opacity: " + (/*endReached*/ ctx[2] ? "0.5" : "1") + ";";

			if (dirty & /*$$scope*/ 524288) {
				iconbutton1_changes.$$scope = { dirty, ctx };
			}

			iconbutton1.$set(iconbutton1_changes);
			const button_changes = {};

			if (dirty & /*$$scope*/ 524288) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			info.ctx = ctx;

			if (dirty & /*promise*/ 2 && promise_1 !== (promise_1 = /*promise*/ ctx[1]) && handle_promise(promise_1, info)) {
				
			} else {
				update_await_block_branch(info, ctx, dirty);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cleardialog.$$.fragment, local);
			transition_in(header0.$$.fragment, local);
			transition_in(iconbutton0.$$.fragment, local);
			transition_in(iconbutton1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			transition_in(info.block);
			current = true;
		},
		o: function outro(local) {
			transition_out(cleardialog.$$.fragment, local);
			transition_out(header0.$$.fragment, local);
			transition_out(iconbutton0.$$.fragment, local);
			transition_out(iconbutton1.$$.fragment, local);
			transition_out(button.$$.fragment, local);

			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			destroy_component(cleardialog, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(header1);
			destroy_component(header0);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div2);
			destroy_component(iconbutton0);
			destroy_component(iconbutton1);
			destroy_component(button);
			info.block.d();
			info.token = null;
			info = null;
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const ENTRIES_BY_PAGE = 50;

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('History', slots, []);
	const { t } = window.nereid.i18n;

	function tt(str, ...args) {
		return t(`pages.history.${str}`, ...args);
	}

	const fmt = Intl.DateTimeFormat();
	let currentPage = 0;
	let entries = [];
	let promise;

	function update() {
		$$invalidate(1, promise = new Promise(async y => {
				let unfiltered = await window.nereid.userdata.history.get({
					entries: ENTRIES_BY_PAGE,
					offset: ENTRIES_BY_PAGE * currentPage
				});

				$$invalidate(9, entries = unfiltered.filter(o => !!o).map((e, i) => {
					e.originalIndex = ENTRIES_BY_PAGE * currentPage + i; // current impl returns always the amount specified by "entries"
					return e;
				}));

				y();

				requestIdleCallback(async () => {
					let next = await window.nereid.userdata.history.get({
						entries: 1,
						offset: ENTRIES_BY_PAGE * (currentPage + 1)
					});

					if (next[0] == undefined) {
						$$invalidate(2, endReached = true);
					}
				});
			}));
	}

	let endReached = false;

	const page = {
		fwd() {
			if (endReached) return;
			$$invalidate(0, currentPage += 1);
			update();
		},
		back() {
			if (currentPage == 0) return;
			$$invalidate(0, currentPage -= 1);
			$$invalidate(2, endReached = false);
			update();
		}
	};

	let entriesByDate = {};

	function updateEntriesByDate() {
		$$invalidate(3, entriesByDate = {});

		entries.forEach((e, i) => {
			const day = fmt.format(e.timestamp);
			const dateKey = new Date(day).getTime();

			if (dateKey in entriesByDate) {
				entriesByDate[dateKey].push(e);
			} else {
				$$invalidate(3, entriesByDate[dateKey] = [e], entriesByDate);
			}
		});
	}

	update();
	setContext('update', update);
	let open = false;

	async function clearAllOnThisPage() {
		let i = 0;

		for (const { originalIndex } of entries) {
			await nereid.userdata.history.delAt({ index: originalIndex - i });

			// need to subtract `i` because when you delete a h. entry, all other indexes shift
			i++;
		}

		update();
	}

	const writable_props = [];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<History> was created with unknown prop '${key}'`);
	});

	function cleardialog_open_binding(value) {
		open = value;
		$$invalidate(4, open);
	}

	const click_handler = () => $$invalidate(4, open = true);

	$$self.$capture_state = () => ({
		IconButton,
		Button,
		ProgressRing,
		setContext,
		Header,
		ByDate,
		ClearDialog,
		Icons,
		t,
		tt,
		fmt,
		ENTRIES_BY_PAGE,
		currentPage,
		entries,
		promise,
		update,
		endReached,
		page,
		entriesByDate,
		updateEntriesByDate,
		open,
		clearAllOnThisPage
	});

	$$self.$inject_state = $$props => {
		if ('currentPage' in $$props) $$invalidate(0, currentPage = $$props.currentPage);
		if ('entries' in $$props) $$invalidate(9, entries = $$props.entries);
		if ('promise' in $$props) $$invalidate(1, promise = $$props.promise);
		if ('endReached' in $$props) $$invalidate(2, endReached = $$props.endReached);
		if ('entriesByDate' in $$props) $$invalidate(3, entriesByDate = $$props.entriesByDate);
		if ('open' in $$props) $$invalidate(4, open = $$props.open);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*entries*/ 512) {
			$: {
				entries;
				updateEntriesByDate();
			}
		}
	};

	return [
		currentPage,
		promise,
		endReached,
		entriesByDate,
		open,
		t,
		tt,
		page,
		clearAllOnThisPage,
		entries,
		cleardialog_open_binding,
		click_handler
	];
}

class History extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "History",
			options,
			id: create_fragment.name
		});
	}
}

export default History;