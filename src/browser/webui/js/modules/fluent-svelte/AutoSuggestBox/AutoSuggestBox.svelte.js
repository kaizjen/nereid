/* AutoSuggestBox.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	add_flush_callback,
	add_location,
	append_dev,
	append_styles,
	assign,
	attr_dev,
	bind,
	binding_callbacks,
	bubble,
	check_outros,
	compute_rest_props,
	create_component,
	create_slot,
	destroy_component,
	detach_dev,
	dispatch_dev,
	element,
	exclude_internal_props,
	get_all_dirty_from_scope,
	get_slot_changes,
	get_spread_object,
	get_spread_update,
	group_outros,
	init,
	insert_dev,
	mount_component,
	outro_and_destroy_block,
	safe_not_equal,
	set_data_dev,
	space,
	text,
	transition_in,
	transition_out,
	update_keyed_each,
	update_slot_base,
	validate_each_argument,
	validate_each_keys,
	validate_slots
} from "nereid://.svelte/internal/index.mjs";

import { createEventDispatcher } from "nereid://.svelte/index.mjs";
import { uid } from "../internal.js";
import TextBox from "../TextBox/TextBox.svelte.js";
import ListItem from "../ListItem/ListItem.svelte.js";
const file = "AutoSuggestBox.svelte";

function add_css(target) {
	append_styles(target, "svelte-11bcpbh", ".auto-suggest-box-flyout.svelte-11bcpbh{background-clip:padding-box;background-color:var(--fds-solid-background-quarternary);border:1px solid var(--fds-surface-stroke-flyout);border-end-end-radius:0;border-end-start-radius:0;border-radius:var(--fds-overlay-corner-radius);box-shadow:var(--fds-flyout-shadow);box-sizing:border-box;color:var(--fds-text-primary);inline-size:calc(100% + 2px);inset-block-start:calc(100% + 1px);inset-inline-start:-1px;margin:0;max-block-size:472px;overflow:auto;padding:0;padding-block:2px;position:absolute;z-index:100}.auto-suggest-item-wrapper.svelte-11bcpbh{display:block}.auto-suggest-box.open{background-color:var(--fds-control-fill-input-active)!important}.auto-suggest-box.open .text-box-underline:after{border-bottom:2px solid var(--fds-accent-default);content:\"\"}.auto-suggest-box.open input::-moz-placeholder{color:var(--fds-text-tertiary)}.auto-suggest-box.open input:-ms-input-placeholder{color:var(--fds-text-tertiary)}.auto-suggest-box.open input::placeholder{color:var(--fds-text-tertiary)}.auto-suggest-box.open .text-box-underline{border-bottom-left-radius:0;border-bottom-right-radius:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXV0b1N1Z2dlc3RCb3guc3ZlbHRlIiwic291cmNlcyI6WyJBdXRvU3VnZ2VzdEJveC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCA+aW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG5pbXBvcnQgeyB1aWQgfSBmcm9tIFwiLi4vaW50ZXJuYWxcIjtcclxuaW1wb3J0IFRleHRCb3ggZnJvbSBcIi4uL1RleHRCb3gvVGV4dEJveC5zdmVsdGVcIjtcclxuaW1wb3J0IExpc3RJdGVtIGZyb20gXCIuLi9MaXN0SXRlbS9MaXN0SXRlbS5zdmVsdGVcIjtcclxuLyoqIEBleHRlbmRzIHtcIi4uL1RleHRCb3gvVGV4dEJveC5zdmVsdGVcIn0gKi9cclxuLyoqIFRoZSBpbnB1dCdzIGN1cnJlbnQgdmFsdWUuICovXHJcbmV4cG9ydCBsZXQgdmFsdWUgPSBcIlwiO1xyXG4vKiogQXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgYmUgc3VnZ2VzdGVkIHRvIHRoZSB1c2VyIGFzIG9wdGlvbnMuICovXHJcbmV4cG9ydCBsZXQgaXRlbXMgPSBbXTtcclxuLyoqIFRoZSBjdXJyZW50IHZpc2liaWxpdHkgc3RhdGUgb2YgdGhlIHN1Z2dlc3Rpb24gZmx5b3V0LiAqL1xyXG5leHBvcnQgbGV0IG9wZW4gPSBmYWxzZTtcclxuLyoqIEJpbmRhYmxlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbS4gKi9cclxuZXhwb3J0IGxldCBzZWxlY3Rpb24gPSAwO1xyXG4vKiogQmluZGFibGUgYXJyYXkgb2YgY3VycmVudGx5IHN1Z2dlc3RlZCBpdGVtcy4gKi9cclxuZXhwb3J0IGxldCBtYXRjaGVzID0gW107XHJcbi8qKiBTcGVjaWZpZXMgYSBjdXN0b20gY2xhc3MgbmFtZSBmb3IgdGhlIGNvbXBvbmVudC4gKi9cclxubGV0IGNsYXNzTmFtZSA9IFwiXCI7XHJcbmV4cG9ydCB7IGNsYXNzTmFtZSBhcyBjbGFzcyB9O1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIGlucHV0IGVsZW1lbnQuICovXHJcbmV4cG9ydCBsZXQgaW5wdXRFbGVtZW50ID0gbnVsbDtcclxuLyoqIE9idGFpbnMgYSBib3VuZCBET00gcmVmZXJlbmNlIHRvIHRoZSBBdXRvU3VnZ2VzdEJveCdzIGNvbnRhaW5lciBlbGVtZW50LiAqL1xyXG5leHBvcnQgbGV0IGNvbnRhaW5lckVsZW1lbnQgPSBudWxsO1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIEF1dG9TdWdnZXN0Qm94J3MgYnV0dG9ucyBjb250YWluZXIgZWxlbWVudC4gKi9cclxuZXhwb3J0IGxldCBidXR0b25zQ29udGFpbmVyRWxlbWVudCA9IG51bGw7XHJcbi8qKiBPYnRhaW5zIGEgYm91bmQgRE9NIHJlZmVyZW5jZSB0byB0aGUgQXV0b1N1Z2dlc3RCb3gncyBjbGVhciBidXR0b24gZWxlbWVudC4gT25seSBhdmFpbGFibGUgaWYgYGNsZWFyQnV0dG9uYCBpcyBzZXQgdG8gdHJ1ZSwgYHJlYWRvbmx5YCBpcyBzZXQgdG8gZmFsc2UsIGFuZCBhIGB2YWx1ZWAgaXMgcHJlc2VudC4gKi9cclxuZXhwb3J0IGxldCBjbGVhckJ1dHRvbkVsZW1lbnQgPSBudWxsO1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIEF1dG9TdWdnZXN0Qm94J3Mgc2VhcmNoIGJ1dHRvbiBlbGVtZW50LiBPbmx5IGF2YWlsYWJsZSBpZiBgdHlwZWAgaXMgc2V0IHRvIGBzZWFyY2hgLiAqL1xyXG5leHBvcnQgbGV0IHNlYXJjaEJ1dHRvbkVsZW1lbnQgPSBudWxsO1xyXG5leHBvcnQgbGV0IGZseW91dEVsZW1lbnQgPSBudWxsO1xyXG5sZXQgZm9jdXNlZCA9IGZhbHNlO1xyXG5sZXQgdHlwZWRWYWx1ZSA9IFwiXCI7XHJcbmNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XHJcbmNvbnN0IGZseW91dElkID0gdWlkKFwiZmRzLWF1dG8tc3VnZ2VzdC1mbHlvdXQtXCIpO1xyXG4kOiBtYXRjaGVzID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHR5cGVkVmFsdWUudG9Mb3dlckNhc2UoKSkpO1xyXG4kOiBzZWxlY3Rpb24sIGRpc3BhdGNoU2VsZWN0KCk7XHJcbmZ1bmN0aW9uIGRpc3BhdGNoU2VsZWN0KCkge1xyXG4gICAgZGlzcGF0Y2goXCJzZWxlY3RcIiwge1xyXG4gICAgICAgIGl0ZW06IGl0ZW1zW3NlbGVjdGlvbl0sXHJcbiAgICAgICAgaW5kZXg6IHNlbGVjdGlvblxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlSW5wdXQoKSB7XHJcbiAgICB0eXBlZFZhbHVlID0gaW5wdXRFbGVtZW50LnZhbHVlO1xyXG4gICAgaWYgKGZvY3VzZWQgJiYgdmFsdWUgJiYgaXRlbXMubGVuZ3RoID4gMClcclxuICAgICAgICBvcGVuID0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XHJcbiAgICBjb25zdCB7IGtleSB9ID0gZXZlbnQ7XHJcbiAgICBpZiAob3BlbiAmJiBtYXRjaGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBpZiAoa2V5ID09PSBcIkFycm93RG93blwiKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGlvbisrO1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uID4gbWF0Y2hlcy5sZW5ndGggLSAxKVxyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIkFycm93VXBcIikge1xyXG4gICAgICAgICAgICBzZWxlY3Rpb24tLTtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiA8IDApXHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBtYXRjaGVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJFbnRlclwiIHx8IGtleSA9PT0gXCJFc2NhcGVcIikge1xyXG4gICAgICAgICAgICBvcGVuID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXkgPT09IFwiRW50ZXJcIiB8fCBrZXkgPT09IFwiQXJyb3dEb3duXCIgfHwga2V5ID09PSBcIkFycm93VXBcIikge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IG1hdGNoZXNbc2VsZWN0aW9uXTtcclxuICAgICAgICAgICAgZmx5b3V0RWxlbWVudCA9PT0gbnVsbCB8fCBmbHlvdXRFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmbHlvdXRFbGVtZW50LmNoaWxkcmVuW3NlbGVjdGlvbl0uc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogXCJuZWFyZXN0XCIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoIW9wZW4gJiYgbWF0Y2hlcy5sZW5ndGggPiAwICYmIChrZXkgPT09IFwiQXJyb3dEb3duXCIgfHwga2V5ID09PSBcIkFycm93VXBcIikpIHtcclxuICAgICAgICBvcGVuID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cblxuPFRleHRCb3hcblx0dHlwZT1cInNlYXJjaFwiXG5cdGNsYXNzPVwiYXV0by1zdWdnZXN0LWJveCB7b3BlbiAmJiBtYXRjaGVzLmxlbmd0aCA+IDAgPyAnb3BlbicgOiAnJ30ge2NsYXNzTmFtZX1cIlxuXHRhcmlhLWF1dG9jb21wbGV0ZT1cImxpc3RcIlxuXHRhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9e29wZW4gJiYgbWF0Y2hlcy5sZW5ndGggPiAwXG5cdFx0PyBgJHtmbHlvdXRJZH0taXRlbS0ke2l0ZW1zLmluZGV4T2YobWF0Y2hlc1tzZWxlY3Rpb25dKX1gXG5cdFx0OiBcIlwifVxuXHRhcmlhLWV4cGFuZGVkPXtvcGVuICYmIG1hdGNoZXMubGVuZ3RoID4gMH1cblx0YXJpYS1jb250cm9scz17Zmx5b3V0SWR9XG5cdG9uOnNlYXJjaD17KCkgPT4ge1xuXHRcdGlmIChvcGVuICYmIG1hdGNoZXMubGVuZ3RoID4gMCkgdmFsdWUgPSBtYXRjaGVzW3NlbGVjdGlvbl07XG5cdH19XG5cdG9uOnNlYXJjaFxuXHRvbjppbnB1dFxuXHRvbjppbnB1dD17aGFuZGxlSW5wdXR9XG5cdG9uOm91dGVybW91c2Vkb3duPXsoKSA9PiAob3BlbiA9IGZhbHNlKX1cblx0b246Zm9jdXM9eygpID0+IChmb2N1c2VkID0gdHJ1ZSl9XG5cdG9uOmZvY3VzXG5cdG9uOmJsdXI9eygpID0+IChmb2N1c2VkID0gZmFsc2UpfVxuXHRvbjpibHVyXG5cdG9uOmtleWRvd249e2hhbmRsZUtleURvd259XG5cdG9uOmtleWRvd25cblx0b246Y2hhbmdlXG5cdG9uOmJlZm9yZWlucHV0XG5cdG9uOmNsaWNrXG5cdG9uOmRibGNsaWNrXG5cdG9uOmNvbnRleHRtZW51XG5cdG9uOm1vdXNlZG93blxuXHRvbjptb3VzZXVwXG5cdG9uOm1vdXNlb3ZlclxuXHRvbjptb3VzZW91dFxuXHRvbjptb3VzZWVudGVyXG5cdG9uOm1vdXNlbGVhdmVcblx0b246a2V5cHJlc3Ncblx0b246a2V5dXBcblx0b246Y2xlYXI9eygpID0+IHtcblx0XHR0eXBlZFZhbHVlID0gXCJcIjtcblx0XHRpZiAoaXRlbXMubGVuZ3RoID4gMCkgb3BlbiA9IHRydWU7XG5cdH19XG5cdG9uOmNsZWFyXG5cdGJpbmQ6aW5wdXRFbGVtZW50XG5cdGJpbmQ6Y29udGFpbmVyRWxlbWVudFxuXHRiaW5kOmNsZWFyQnV0dG9uRWxlbWVudFxuXHRiaW5kOnNlYXJjaEJ1dHRvbkVsZW1lbnRcblx0YmluZDpidXR0b25zQ29udGFpbmVyRWxlbWVudFxuXHRiaW5kOnZhbHVlXG5cdHsuLi4kJHJlc3RQcm9wc31cbj5cblx0eyNpZiBvcGVuICYmIG1hdGNoZXMubGVuZ3RoID4gMH1cblx0XHQ8dWwgaWQ9e2ZseW91dElkfSByb2xlPVwibGlzdGJveFwiIGNsYXNzPVwiYXV0by1zdWdnZXN0LWJveC1mbHlvdXRcIiBiaW5kOnRoaXM9e2ZseW91dEVsZW1lbnR9PlxuXHRcdFx0eyNlYWNoIG1hdGNoZXMgYXMgaXRlbSwgaW5kZXggKGl0ZW0pfVxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYXV0by1zdWdnZXN0LWl0ZW0td3JhcHBlclwiPlxuXHRcdFx0XHRcdDxzbG90XG5cdFx0XHRcdFx0XHRuYW1lPVwiaXRlbS10ZW1wbGF0ZVwiXG5cdFx0XHRcdFx0XHRpZD1cIntmbHlvdXRJZH0taXRlbS17aW5kZXh9XCJcblx0XHRcdFx0XHRcdHt2YWx1ZX1cblx0XHRcdFx0XHRcdHttYXRjaGVzfVxuXHRcdFx0XHRcdFx0e3NlbGVjdGlvbn1cblx0XHRcdFx0XHRcdHtpdGVtfVxuXHRcdFx0XHRcdFx0e2luZGV4fVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxMaXN0SXRlbVxuXHRcdFx0XHRcdFx0XHR0YWJpbmRleD17LTF9XG5cdFx0XHRcdFx0XHRcdGlkPVwie2ZseW91dElkfS1pdGVtLXtpbmRleH1cIlxuXHRcdFx0XHRcdFx0XHRyb2xlPVwib3B0aW9uXCJcblx0XHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG1hdGNoZXNbc2VsZWN0aW9uXTtcblx0XHRcdFx0XHRcdFx0XHRzZWxlY3Rpb24gPSBpbmRleDtcblx0XHRcdFx0XHRcdFx0XHRvcGVuID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0XHRcdHNlbGVjdGVkPXtzZWxlY3Rpb24gPT09IGluZGV4fT57aXRlbX08L0xpc3RJdGVtXG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0PC9zbG90PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdHsvZWFjaH1cblx0XHQ8L3VsPlxuXHR7L2lmfVxuXG5cdDxzbG90IC8+XG5cdDxzbG90IG5hbWU9XCJidXR0b25zXCIgc2xvdD1cImJ1dHRvbnNcIiAvPlxuPC9UZXh0Qm94PlxuXG48c3R5bGUgPi5hdXRvLXN1Z2dlc3QtYm94LWZseW91dHtiYWNrZ3JvdW5kLWNsaXA6cGFkZGluZy1ib3g7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtc29saWQtYmFja2dyb3VuZC1xdWFydGVybmFyeSk7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mZHMtc3VyZmFjZS1zdHJva2UtZmx5b3V0KTtib3JkZXItZW5kLWVuZC1yYWRpdXM6MDtib3JkZXItZW5kLXN0YXJ0LXJhZGl1czowO2JvcmRlci1yYWRpdXM6dmFyKC0tZmRzLW92ZXJsYXktY29ybmVyLXJhZGl1cyk7Ym94LXNoYWRvdzp2YXIoLS1mZHMtZmx5b3V0LXNoYWRvdyk7Ym94LXNpemluZzpib3JkZXItYm94O2NvbG9yOnZhcigtLWZkcy10ZXh0LXByaW1hcnkpO2lubGluZS1zaXplOmNhbGMoMTAwJSArIDJweCk7aW5zZXQtYmxvY2stc3RhcnQ6Y2FsYygxMDAlICsgMXB4KTtpbnNldC1pbmxpbmUtc3RhcnQ6LTFweDttYXJnaW46MDttYXgtYmxvY2stc2l6ZTo0NzJweDtvdmVyZmxvdzphdXRvO3BhZGRpbmc6MDtwYWRkaW5nLWJsb2NrOjJweDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjEwMH0uYXV0by1zdWdnZXN0LWl0ZW0td3JhcHBlcntkaXNwbGF5OmJsb2NrfTpnbG9iYWwoLmF1dG8tc3VnZ2VzdC1ib3gub3Blbil7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtY29udHJvbC1maWxsLWlucHV0LWFjdGl2ZSkhaW1wb3J0YW50fTpnbG9iYWwoLmF1dG8tc3VnZ2VzdC1ib3gub3BlbikgOmdsb2JhbCgudGV4dC1ib3gtdW5kZXJsaW5lOmFmdGVyKXtib3JkZXItYm90dG9tOjJweCBzb2xpZCB2YXIoLS1mZHMtYWNjZW50LWRlZmF1bHQpO2NvbnRlbnQ6XCJcIn06Z2xvYmFsKC5hdXRvLXN1Z2dlc3QtYm94Lm9wZW4pIDpnbG9iYWwoaW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXIpe2NvbG9yOnZhcigtLWZkcy10ZXh0LXRlcnRpYXJ5KX06Z2xvYmFsKC5hdXRvLXN1Z2dlc3QtYm94Lm9wZW4pIDpnbG9iYWwoaW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVyKXtjb2xvcjp2YXIoLS1mZHMtdGV4dC10ZXJ0aWFyeSl9Omdsb2JhbCguYXV0by1zdWdnZXN0LWJveC5vcGVuKSA6Z2xvYmFsKGlucHV0OjpwbGFjZWhvbGRlcil7Y29sb3I6dmFyKC0tZmRzLXRleHQtdGVydGlhcnkpfTpnbG9iYWwoLmF1dG8tc3VnZ2VzdC1ib3gub3BlbikgOmdsb2JhbCgudGV4dC1ib3gtdW5kZXJsaW5lKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MH08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTRKUSx1Q0FBd0IsQ0FBQyxnQkFBZ0IsV0FBVyxDQUFDLGlCQUFpQixJQUFJLGtDQUFrQyxDQUFDLENBQUMsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksMkJBQTJCLENBQUMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLHdCQUF3QixDQUFDLENBQUMsY0FBYyxJQUFJLDJCQUEyQixDQUFDLENBQUMsV0FBVyxJQUFJLG1CQUFtQixDQUFDLENBQUMsV0FBVyxVQUFVLENBQUMsTUFBTSxJQUFJLGtCQUFrQixDQUFDLENBQUMsWUFBWSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsa0JBQWtCLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLGVBQWUsS0FBSyxDQUFDLFNBQVMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLGNBQWMsR0FBRyxDQUFDLFNBQVMsUUFBUSxDQUFDLFFBQVEsR0FBRyxDQUFDLHlDQUEwQixDQUFDLFFBQVEsS0FBSyxDQUFDLEFBQVEsc0JBQXNCLEFBQUMsQ0FBQyxpQkFBaUIsSUFBSSwrQkFBK0IsQ0FBQyxVQUFVLENBQUMsQUFBUSxzQkFBc0IsQUFBQyxDQUFDLEFBQVEseUJBQXlCLEFBQUMsQ0FBQyxjQUFjLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxvQkFBb0IsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLEFBQVEsc0JBQXNCLEFBQUMsQ0FBQyxBQUFRLHVCQUF1QixBQUFDLENBQUMsTUFBTSxJQUFJLG1CQUFtQixDQUFDLENBQUMsQUFBUSxzQkFBc0IsQUFBQyxDQUFDLEFBQVEsMkJBQTJCLEFBQUMsQ0FBQyxNQUFNLElBQUksbUJBQW1CLENBQUMsQ0FBQyxBQUFRLHNCQUFzQixBQUFDLENBQUMsQUFBUSxrQkFBa0IsQUFBQyxDQUFDLE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxDQUFDLEFBQVEsc0JBQXNCLEFBQUMsQ0FBQyxBQUFRLG1CQUFtQixBQUFDLENBQUMsMEJBQTBCLENBQUMsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDIn0= */");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[54] = list[i];
	child_ctx[56] = i;
	return child_ctx;
}

const get_item_template_slot_changes = dirty => ({
	id: dirty[0] & /*matches*/ 8,
	value: dirty[0] & /*value*/ 2,
	matches: dirty[0] & /*matches*/ 8,
	selection: dirty[0] & /*selection*/ 1,
	item: dirty[0] & /*matches*/ 8,
	index: dirty[0] & /*matches*/ 8
});

const get_item_template_slot_context = ctx => ({
	id: "" + (/*flyoutId*/ ctx[14] + "-item-" + /*index*/ ctx[56]),
	value: /*value*/ ctx[1],
	matches: /*matches*/ ctx[3],
	selection: /*selection*/ ctx[0],
	item: /*item*/ ctx[54],
	index: /*index*/ ctx[56]
});

const get_buttons_slot_changes = dirty => ({});
const get_buttons_slot_context = ctx => ({ slot: "buttons" });

// (123:1) {#if open && matches.length > 0}
function create_if_block(ctx) {
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*matches*/ ctx[3];
	validate_each_argument(each_value);
	const get_key = ctx => /*item*/ ctx[54];
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(ul, "id", /*flyoutId*/ ctx[14]);
			attr_dev(ul, "role", "listbox");
			attr_dev(ul, "class", "auto-suggest-box-flyout svelte-11bcpbh");
			add_location(ul, file, 123, 2, 4089);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			/*ul_binding*/ ctx[20](ul);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*flyoutId, matches, selection, value, open*/ 16399 | dirty[1] & /*$$scope*/ 1048576) {
				each_value = /*matches*/ ctx[3];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*ul_binding*/ ctx[20](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(123:1) {#if open && matches.length > 0}",
		ctx
	});

	return block;
}

// (136:6) <ListItem        tabindex={-1}        id="{flyoutId}-item-{index}"        role="option"        on:click={() => {         value = matches[selection];         selection = index;         open = false;        }}        selected={selection === index}>
function create_default_slot_1(ctx) {
	let t_value = /*item*/ ctx[54] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*matches*/ 8 && t_value !== (t_value = /*item*/ ctx[54] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(136:6) <ListItem        tabindex={-1}        id=\\\"{flyoutId}-item-{index}\\\"        role=\\\"option\\\"        on:click={() => {         value = matches[selection];         selection = index;         open = false;        }}        selected={selection === index}>",
		ctx
	});

	return block;
}

// (135:6)        
function fallback_block(ctx) {
	let listitem;
	let current;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[19](/*index*/ ctx[56]);
	}

	listitem = new ListItem({
			props: {
				tabindex: -1,
				id: "" + (/*flyoutId*/ ctx[14] + "-item-" + /*index*/ ctx[56]),
				role: "option",
				selected: /*selection*/ ctx[0] === /*index*/ ctx[56],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	listitem.$on("click", click_handler_1);

	const block = {
		c: function create() {
			create_component(listitem.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(listitem, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const listitem_changes = {};
			if (dirty[0] & /*matches*/ 8) listitem_changes.id = "" + (/*flyoutId*/ ctx[14] + "-item-" + /*index*/ ctx[56]);
			if (dirty[0] & /*selection, matches*/ 9) listitem_changes.selected = /*selection*/ ctx[0] === /*index*/ ctx[56];

			if (dirty[0] & /*matches*/ 8 | dirty[1] & /*$$scope*/ 1048576) {
				listitem_changes.$$scope = { dirty, ctx };
			}

			listitem.$set(listitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(listitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(listitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(listitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(135:6)        ",
		ctx
	});

	return block;
}

// (125:3) {#each matches as item, index (item)}
function create_each_block(key_1, ctx) {
	let div;
	let t;
	let current;
	const item_template_slot_template = /*#slots*/ ctx[18]["item-template"];
	const item_template_slot = create_slot(item_template_slot_template, ctx, /*$$scope*/ ctx[51], get_item_template_slot_context);
	const item_template_slot_or_fallback = item_template_slot || fallback_block(ctx);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div = element("div");
			if (item_template_slot_or_fallback) item_template_slot_or_fallback.c();
			t = space();
			attr_dev(div, "class", "auto-suggest-item-wrapper svelte-11bcpbh");
			add_location(div, file, 125, 4, 4226);
			this.first = div;
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (item_template_slot_or_fallback) {
				item_template_slot_or_fallback.m(div, null);
			}

			append_dev(div, t);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (item_template_slot) {
				if (item_template_slot.p && (!current || dirty[0] & /*matches, value, selection*/ 11 | dirty[1] & /*$$scope*/ 1048576)) {
					update_slot_base(
						item_template_slot,
						item_template_slot_template,
						ctx,
						/*$$scope*/ ctx[51],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[51])
						: get_slot_changes(item_template_slot_template, /*$$scope*/ ctx[51], dirty, get_item_template_slot_changes),
						get_item_template_slot_context
					);
				}
			} else {
				if (item_template_slot_or_fallback && item_template_slot_or_fallback.p && (!current || dirty[0] & /*matches, selection, value, open*/ 15)) {
					item_template_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item_template_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item_template_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (item_template_slot_or_fallback) item_template_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(125:3) {#each matches as item, index (item)}",
		ctx
	});

	return block;
}

// (75:0) <TextBox  type="search"  class="auto-suggest-box {open && matches.length > 0 ? 'open' : ''} {className}"  aria-autocomplete="list"  aria-activedescendant={open && matches.length > 0   ? `${flyoutId}-item-${items.indexOf(matches[selection])}`   : ""}  aria-expanded={open && matches.length > 0}  aria-controls={flyoutId}  on:search={() => {   if (open && matches.length > 0) value = matches[selection];  }}  on:search  on:input  on:input={handleInput}  on:outermousedown={() => (open = false)}  on:focus={() => (focused = true)}  on:focus  on:blur={() => (focused = false)}  on:blur  on:keydown={handleKeyDown}  on:keydown  on:change  on:beforeinput  on:click  on:dblclick  on:contextmenu  on:mousedown  on:mouseup  on:mouseover  on:mouseout  on:mouseenter  on:mouseleave  on:keypress  on:keyup  on:clear={() => {   typedValue = "";   if (items.length > 0) open = true;  }}  on:clear  bind:inputElement  bind:containerElement  bind:clearButtonElement  bind:searchButtonElement  bind:buttonsContainerElement  bind:value  {...$$restProps} >
function create_default_slot(ctx) {
	let t;
	let current;
	let if_block = /*open*/ ctx[2] && /*matches*/ ctx[3].length > 0 && create_if_block(ctx);
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[51], null);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*open*/ ctx[2] && /*matches*/ ctx[3].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*open, matches*/ 12) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 1048576)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[51],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[51])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[51], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(75:0) <TextBox  type=\\\"search\\\"  class=\\\"auto-suggest-box {open && matches.length > 0 ? 'open' : ''} {className}\\\"  aria-autocomplete=\\\"list\\\"  aria-activedescendant={open && matches.length > 0   ? `${flyoutId}-item-${items.indexOf(matches[selection])}`   : \\\"\\\"}  aria-expanded={open && matches.length > 0}  aria-controls={flyoutId}  on:search={() => {   if (open && matches.length > 0) value = matches[selection];  }}  on:search  on:input  on:input={handleInput}  on:outermousedown={() => (open = false)}  on:focus={() => (focused = true)}  on:focus  on:blur={() => (focused = false)}  on:blur  on:keydown={handleKeyDown}  on:keydown  on:change  on:beforeinput  on:click  on:dblclick  on:contextmenu  on:mousedown  on:mouseup  on:mouseover  on:mouseout  on:mouseenter  on:mouseleave  on:keypress  on:keyup  on:clear={() => {   typedValue = \\\"\\\";   if (items.length > 0) open = true;  }}  on:clear  bind:inputElement  bind:containerElement  bind:clearButtonElement  bind:searchButtonElement  bind:buttonsContainerElement  bind:value  {...$$restProps} >",
		ctx
	});

	return block;
}

// (154:1) 
function create_buttons_slot(ctx) {
	let current;
	const buttons_slot_template = /*#slots*/ ctx[18].buttons;
	const buttons_slot = create_slot(buttons_slot_template, ctx, /*$$scope*/ ctx[51], get_buttons_slot_context);

	const block = {
		c: function create() {
			if (buttons_slot) buttons_slot.c();
		},
		m: function mount(target, anchor) {
			if (buttons_slot) {
				buttons_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (buttons_slot) {
				if (buttons_slot.p && (!current || dirty[1] & /*$$scope*/ 1048576)) {
					update_slot_base(
						buttons_slot,
						buttons_slot_template,
						ctx,
						/*$$scope*/ ctx[51],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[51])
						: get_slot_changes(buttons_slot_template, /*$$scope*/ ctx[51], dirty, get_buttons_slot_changes),
						get_buttons_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(buttons_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(buttons_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (buttons_slot) buttons_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_buttons_slot.name,
		type: "slot",
		source: "(154:1) ",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let textbox;
	let updating_inputElement;
	let updating_containerElement;
	let updating_clearButtonElement;
	let updating_searchButtonElement;
	let updating_buttonsContainerElement;
	let updating_value;
	let current;

	const textbox_spread_levels = [
		{ type: "search" },
		{
			class: "auto-suggest-box " + (/*open*/ ctx[2] && /*matches*/ ctx[3].length > 0
			? 'open'
			: '') + " " + /*className*/ ctx[11]
		},
		{ "aria-autocomplete": "list" },
		{
			"aria-activedescendant": /*open*/ ctx[2] && /*matches*/ ctx[3].length > 0
			? `${/*flyoutId*/ ctx[14]}-item-${/*items*/ ctx[10].indexOf(/*matches*/ ctx[3][/*selection*/ ctx[0]])}`
			: ""
		},
		{
			"aria-expanded": /*open*/ ctx[2] && /*matches*/ ctx[3].length > 0
		},
		{ "aria-controls": /*flyoutId*/ ctx[14] },
		/*$$restProps*/ ctx[17]
	];

	function textbox_inputElement_binding(value) {
		/*textbox_inputElement_binding*/ ctx[21](value);
	}

	function textbox_containerElement_binding(value) {
		/*textbox_containerElement_binding*/ ctx[22](value);
	}

	function textbox_clearButtonElement_binding(value) {
		/*textbox_clearButtonElement_binding*/ ctx[23](value);
	}

	function textbox_searchButtonElement_binding(value) {
		/*textbox_searchButtonElement_binding*/ ctx[24](value);
	}

	function textbox_buttonsContainerElement_binding(value) {
		/*textbox_buttonsContainerElement_binding*/ ctx[25](value);
	}

	function textbox_value_binding(value) {
		/*textbox_value_binding*/ ctx[26](value);
	}

	let textbox_props = {
		$$slots: {
			buttons: [create_buttons_slot],
			default: [create_default_slot]
		},
		$$scope: { ctx }
	};

	for (let i = 0; i < textbox_spread_levels.length; i += 1) {
		textbox_props = assign(textbox_props, textbox_spread_levels[i]);
	}

	if (/*inputElement*/ ctx[4] !== void 0) {
		textbox_props.inputElement = /*inputElement*/ ctx[4];
	}

	if (/*containerElement*/ ctx[5] !== void 0) {
		textbox_props.containerElement = /*containerElement*/ ctx[5];
	}

	if (/*clearButtonElement*/ ctx[7] !== void 0) {
		textbox_props.clearButtonElement = /*clearButtonElement*/ ctx[7];
	}

	if (/*searchButtonElement*/ ctx[8] !== void 0) {
		textbox_props.searchButtonElement = /*searchButtonElement*/ ctx[8];
	}

	if (/*buttonsContainerElement*/ ctx[6] !== void 0) {
		textbox_props.buttonsContainerElement = /*buttonsContainerElement*/ ctx[6];
	}

	if (/*value*/ ctx[1] !== void 0) {
		textbox_props.value = /*value*/ ctx[1];
	}

	textbox = new TextBox({ props: textbox_props, $$inline: true });
	binding_callbacks.push(() => bind(textbox, 'inputElement', textbox_inputElement_binding));
	binding_callbacks.push(() => bind(textbox, 'containerElement', textbox_containerElement_binding));
	binding_callbacks.push(() => bind(textbox, 'clearButtonElement', textbox_clearButtonElement_binding));
	binding_callbacks.push(() => bind(textbox, 'searchButtonElement', textbox_searchButtonElement_binding));
	binding_callbacks.push(() => bind(textbox, 'buttonsContainerElement', textbox_buttonsContainerElement_binding));
	binding_callbacks.push(() => bind(textbox, 'value', textbox_value_binding));
	textbox.$on("search", /*search_handler_1*/ ctx[27]);
	textbox.$on("search", /*search_handler*/ ctx[28]);
	textbox.$on("input", /*input_handler*/ ctx[29]);
	textbox.$on("input", /*handleInput*/ ctx[15]);
	textbox.$on("outermousedown", /*outermousedown_handler*/ ctx[30]);
	textbox.$on("focus", /*focus_handler_1*/ ctx[31]);
	textbox.$on("focus", /*focus_handler*/ ctx[32]);
	textbox.$on("blur", /*blur_handler_1*/ ctx[33]);
	textbox.$on("blur", /*blur_handler*/ ctx[34]);
	textbox.$on("keydown", /*handleKeyDown*/ ctx[16]);
	textbox.$on("keydown", /*keydown_handler*/ ctx[35]);
	textbox.$on("change", /*change_handler*/ ctx[36]);
	textbox.$on("beforeinput", /*beforeinput_handler*/ ctx[37]);
	textbox.$on("click", /*click_handler*/ ctx[38]);
	textbox.$on("dblclick", /*dblclick_handler*/ ctx[39]);
	textbox.$on("contextmenu", /*contextmenu_handler*/ ctx[40]);
	textbox.$on("mousedown", /*mousedown_handler*/ ctx[41]);
	textbox.$on("mouseup", /*mouseup_handler*/ ctx[42]);
	textbox.$on("mouseover", /*mouseover_handler*/ ctx[43]);
	textbox.$on("mouseout", /*mouseout_handler*/ ctx[44]);
	textbox.$on("mouseenter", /*mouseenter_handler*/ ctx[45]);
	textbox.$on("mouseleave", /*mouseleave_handler*/ ctx[46]);
	textbox.$on("keypress", /*keypress_handler*/ ctx[47]);
	textbox.$on("keyup", /*keyup_handler*/ ctx[48]);
	textbox.$on("clear", /*clear_handler_1*/ ctx[49]);
	textbox.$on("clear", /*clear_handler*/ ctx[50]);

	const block = {
		c: function create() {
			create_component(textbox.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(textbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textbox_changes = (dirty[0] & /*open, matches, className, flyoutId, items, selection, $$restProps*/ 150541)
			? get_spread_update(textbox_spread_levels, [
					textbox_spread_levels[0],
					dirty[0] & /*open, matches, className*/ 2060 && {
						class: "auto-suggest-box " + (/*open*/ ctx[2] && /*matches*/ ctx[3].length > 0
						? 'open'
						: '') + " " + /*className*/ ctx[11]
					},
					textbox_spread_levels[2],
					dirty[0] & /*open, matches, flyoutId, items, selection*/ 17421 && {
						"aria-activedescendant": /*open*/ ctx[2] && /*matches*/ ctx[3].length > 0
						? `${/*flyoutId*/ ctx[14]}-item-${/*items*/ ctx[10].indexOf(/*matches*/ ctx[3][/*selection*/ ctx[0]])}`
						: ""
					},
					dirty[0] & /*open, matches*/ 12 && {
						"aria-expanded": /*open*/ ctx[2] && /*matches*/ ctx[3].length > 0
					},
					dirty[0] & /*flyoutId*/ 16384 && { "aria-controls": /*flyoutId*/ ctx[14] },
					dirty[0] & /*$$restProps*/ 131072 && get_spread_object(/*$$restProps*/ ctx[17])
				])
			: {};

			if (dirty[0] & /*flyoutElement, matches, selection, value, open*/ 527 | dirty[1] & /*$$scope*/ 1048576) {
				textbox_changes.$$scope = { dirty, ctx };
			}

			if (!updating_inputElement && dirty[0] & /*inputElement*/ 16) {
				updating_inputElement = true;
				textbox_changes.inputElement = /*inputElement*/ ctx[4];
				add_flush_callback(() => updating_inputElement = false);
			}

			if (!updating_containerElement && dirty[0] & /*containerElement*/ 32) {
				updating_containerElement = true;
				textbox_changes.containerElement = /*containerElement*/ ctx[5];
				add_flush_callback(() => updating_containerElement = false);
			}

			if (!updating_clearButtonElement && dirty[0] & /*clearButtonElement*/ 128) {
				updating_clearButtonElement = true;
				textbox_changes.clearButtonElement = /*clearButtonElement*/ ctx[7];
				add_flush_callback(() => updating_clearButtonElement = false);
			}

			if (!updating_searchButtonElement && dirty[0] & /*searchButtonElement*/ 256) {
				updating_searchButtonElement = true;
				textbox_changes.searchButtonElement = /*searchButtonElement*/ ctx[8];
				add_flush_callback(() => updating_searchButtonElement = false);
			}

			if (!updating_buttonsContainerElement && dirty[0] & /*buttonsContainerElement*/ 64) {
				updating_buttonsContainerElement = true;
				textbox_changes.buttonsContainerElement = /*buttonsContainerElement*/ ctx[6];
				add_flush_callback(() => updating_buttonsContainerElement = false);
			}

			if (!updating_value && dirty[0] & /*value*/ 2) {
				updating_value = true;
				textbox_changes.value = /*value*/ ctx[1];
				add_flush_callback(() => updating_value = false);
			}

			textbox.$set(textbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"value","items","open","selection","matches","class","inputElement","containerElement","buttonsContainerElement","clearButtonElement","searchButtonElement","flyoutElement"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AutoSuggestBox', slots, ['buttons','item-template','default']);
	let { value = "" } = $$props;
	let { items = [] } = $$props;
	let { open = false } = $$props;
	let { selection = 0 } = $$props;
	let { matches = [] } = $$props;
	let { class: className = "" } = $$props;
	let { inputElement = null } = $$props;
	let { containerElement = null } = $$props;
	let { buttonsContainerElement = null } = $$props;
	let { clearButtonElement = null } = $$props;
	let { searchButtonElement = null } = $$props;
	let { flyoutElement = null } = $$props;
	let focused = false;
	let typedValue = "";
	const dispatch = createEventDispatcher();
	const flyoutId = uid("fds-auto-suggest-flyout-");

	function dispatchSelect() {
		dispatch("select", { item: items[selection], index: selection });
	}

	function handleInput() {
		$$invalidate(12, typedValue = inputElement.value);
		if (focused && value && items.length > 0) $$invalidate(2, open = true);
	}

	function handleKeyDown(event) {
		const { key } = event;

		if (open && matches.length > 0) {
			if (key === "ArrowDown") {
				$$invalidate(0, selection++, selection);
				if (selection > matches.length - 1) $$invalidate(0, selection = 0);
			} else if (key === "ArrowUp") {
				$$invalidate(0, selection--, selection);
				if (selection < 0) $$invalidate(0, selection = matches.length - 1);
			} else if (key === "Enter" || key === "Escape") {
				$$invalidate(2, open = false);
			}

			if (key === "Enter" || key === "ArrowDown" || key === "ArrowUp") {
				event.preventDefault();
				$$invalidate(1, value = matches[selection]);

				flyoutElement === null || flyoutElement === void 0
				? void 0
				: flyoutElement.children[selection].scrollIntoView({ block: "nearest" });
			}
		} else if (!open && matches.length > 0 && (key === "ArrowDown" || key === "ArrowUp")) {
			$$invalidate(2, open = true);
		}
	}

	const click_handler_1 = index => {
		$$invalidate(1, value = matches[selection]);
		$$invalidate(0, selection = index);
		$$invalidate(2, open = false);
	};

	function ul_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			flyoutElement = $$value;
			$$invalidate(9, flyoutElement);
		});
	}

	function textbox_inputElement_binding(value) {
		inputElement = value;
		$$invalidate(4, inputElement);
	}

	function textbox_containerElement_binding(value) {
		containerElement = value;
		$$invalidate(5, containerElement);
	}

	function textbox_clearButtonElement_binding(value) {
		clearButtonElement = value;
		$$invalidate(7, clearButtonElement);
	}

	function textbox_searchButtonElement_binding(value) {
		searchButtonElement = value;
		$$invalidate(8, searchButtonElement);
	}

	function textbox_buttonsContainerElement_binding(value) {
		buttonsContainerElement = value;
		$$invalidate(6, buttonsContainerElement);
	}

	function textbox_value_binding(value$1) {
		value = value$1;
		$$invalidate(1, value);
	}

	const search_handler_1 = () => {
		if (open && matches.length > 0) $$invalidate(1, value = matches[selection]);
	};

	function search_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	const outermousedown_handler = () => $$invalidate(2, open = false);
	const focus_handler_1 = () => $$invalidate(13, focused = true);

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	const blur_handler_1 = () => $$invalidate(13, focused = false);

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeinput_handler(event) {
		bubble.call(this, $$self, event);
	}

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function dblclick_handler(event) {
		bubble.call(this, $$self, event);
	}

	function contextmenu_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mousedown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseup_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseover_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseout_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keypress_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keyup_handler(event) {
		bubble.call(this, $$self, event);
	}

	const clear_handler_1 = () => {
		$$invalidate(12, typedValue = "");
		if (items.length > 0) $$invalidate(2, open = true);
	};

	function clear_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('value' in $$new_props) $$invalidate(1, value = $$new_props.value);
		if ('items' in $$new_props) $$invalidate(10, items = $$new_props.items);
		if ('open' in $$new_props) $$invalidate(2, open = $$new_props.open);
		if ('selection' in $$new_props) $$invalidate(0, selection = $$new_props.selection);
		if ('matches' in $$new_props) $$invalidate(3, matches = $$new_props.matches);
		if ('class' in $$new_props) $$invalidate(11, className = $$new_props.class);
		if ('inputElement' in $$new_props) $$invalidate(4, inputElement = $$new_props.inputElement);
		if ('containerElement' in $$new_props) $$invalidate(5, containerElement = $$new_props.containerElement);
		if ('buttonsContainerElement' in $$new_props) $$invalidate(6, buttonsContainerElement = $$new_props.buttonsContainerElement);
		if ('clearButtonElement' in $$new_props) $$invalidate(7, clearButtonElement = $$new_props.clearButtonElement);
		if ('searchButtonElement' in $$new_props) $$invalidate(8, searchButtonElement = $$new_props.searchButtonElement);
		if ('flyoutElement' in $$new_props) $$invalidate(9, flyoutElement = $$new_props.flyoutElement);
		if ('$$scope' in $$new_props) $$invalidate(51, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		uid,
		TextBox,
		ListItem,
		value,
		items,
		open,
		selection,
		matches,
		className,
		inputElement,
		containerElement,
		buttonsContainerElement,
		clearButtonElement,
		searchButtonElement,
		flyoutElement,
		focused,
		typedValue,
		dispatch,
		flyoutId,
		dispatchSelect,
		handleInput,
		handleKeyDown
	});

	$$self.$inject_state = $$new_props => {
		if ('value' in $$props) $$invalidate(1, value = $$new_props.value);
		if ('items' in $$props) $$invalidate(10, items = $$new_props.items);
		if ('open' in $$props) $$invalidate(2, open = $$new_props.open);
		if ('selection' in $$props) $$invalidate(0, selection = $$new_props.selection);
		if ('matches' in $$props) $$invalidate(3, matches = $$new_props.matches);
		if ('className' in $$props) $$invalidate(11, className = $$new_props.className);
		if ('inputElement' in $$props) $$invalidate(4, inputElement = $$new_props.inputElement);
		if ('containerElement' in $$props) $$invalidate(5, containerElement = $$new_props.containerElement);
		if ('buttonsContainerElement' in $$props) $$invalidate(6, buttonsContainerElement = $$new_props.buttonsContainerElement);
		if ('clearButtonElement' in $$props) $$invalidate(7, clearButtonElement = $$new_props.clearButtonElement);
		if ('searchButtonElement' in $$props) $$invalidate(8, searchButtonElement = $$new_props.searchButtonElement);
		if ('flyoutElement' in $$props) $$invalidate(9, flyoutElement = $$new_props.flyoutElement);
		if ('focused' in $$props) $$invalidate(13, focused = $$new_props.focused);
		if ('typedValue' in $$props) $$invalidate(12, typedValue = $$new_props.typedValue);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*items, typedValue*/ 5120) {
			$: $$invalidate(3, matches = items.filter(item => item.toLowerCase().includes(typedValue.toLowerCase())));
		}

		if ($$self.$$.dirty[0] & /*selection*/ 1) {
			$: (selection, dispatchSelect());
		}
	};

	return [
		selection,
		value,
		open,
		matches,
		inputElement,
		containerElement,
		buttonsContainerElement,
		clearButtonElement,
		searchButtonElement,
		flyoutElement,
		items,
		className,
		typedValue,
		focused,
		flyoutId,
		handleInput,
		handleKeyDown,
		$$restProps,
		slots,
		click_handler_1,
		ul_binding,
		textbox_inputElement_binding,
		textbox_containerElement_binding,
		textbox_clearButtonElement_binding,
		textbox_searchButtonElement_binding,
		textbox_buttonsContainerElement_binding,
		textbox_value_binding,
		search_handler_1,
		search_handler,
		input_handler,
		outermousedown_handler,
		focus_handler_1,
		focus_handler,
		blur_handler_1,
		blur_handler,
		keydown_handler,
		change_handler,
		beforeinput_handler,
		click_handler,
		dblclick_handler,
		contextmenu_handler,
		mousedown_handler,
		mouseup_handler,
		mouseover_handler,
		mouseout_handler,
		mouseenter_handler,
		mouseleave_handler,
		keypress_handler,
		keyup_handler,
		clear_handler_1,
		clear_handler,
		$$scope
	];
}

class AutoSuggestBox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				value: 1,
				items: 10,
				open: 2,
				selection: 0,
				matches: 3,
				class: 11,
				inputElement: 4,
				containerElement: 5,
				buttonsContainerElement: 6,
				clearButtonElement: 7,
				searchButtonElement: 8,
				flyoutElement: 9
			},
			add_css,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AutoSuggestBox",
			options,
			id: create_fragment.name
		});
	}

	get value() {
		throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selection() {
		throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selection(value) {
		throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get matches() {
		throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set matches(value) {
		throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputElement() {
		throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputElement(value) {
		throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get containerElement() {
		throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set containerElement(value) {
		throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buttonsContainerElement() {
		throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buttonsContainerElement(value) {
		throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clearButtonElement() {
		throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set clearButtonElement(value) {
		throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchButtonElement() {
		throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchButtonElement(value) {
		throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flyoutElement() {
		throw new Error("<AutoSuggestBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flyoutElement(value) {
		throw new Error("<AutoSuggestBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default AutoSuggestBox;