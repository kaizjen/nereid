/* CalendarView.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	action_destroyer,
	add_location,
	add_render_callback,
	append_dev,
	append_styles,
	assign,
	attr_dev,
	binding_callbacks,
	check_outros,
	compute_rest_props,
	create_component,
	create_in_transition,
	create_out_transition,
	destroy_component,
	destroy_each,
	detach_dev,
	dispatch_dev,
	element as element_1,
	empty,
	exclude_internal_props,
	get_spread_update,
	group_outros,
	init,
	insert_dev,
	listen_dev,
	mount_component,
	noop,
	prop_dev,
	run_all,
	safe_not_equal,
	set_attributes,
	set_data_dev,
	space,
	svg_element,
	text,
	toggle_class,
	transition_in,
	transition_out,
	validate_each_argument,
	validate_slots
} from "nereid://.svelte/internal/index.mjs";

import { createEventDispatcher, onMount, tick } from "nereid://.svelte/index.mjs";
import { fly } from "nereid://.svelte/transition/index.mjs";
import { circOut } from "nereid://.svelte/easing/index.mjs";
import { get_current_component } from "nereid://.svelte/internal/index.mjs";
import { createEventForwarder, getCSSDuration } from "../internal.js";
import CalendarViewItem from "./CalendarViewItem.svelte.js";
const file = "CalendarView.svelte";

function add_css(target) {
	append_styles(target, "svelte-2np5h6", ".calendar-view.svelte-2np5h6.svelte-2np5h6{background-clip:padding-box;background-color:var(--fds-solid-background-quarternary);block-size:347px;border:1px solid var(--fds-surface-stroke-flyout);border-radius:var(--fds-control-corner-radius);color:var(--fds-text-primary);display:inline-flex;flex-direction:column;font-family:var(--fds-font-family-text);inline-size:300px;position:relative;text-align:start;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.calendar-view.floating.svelte-2np5h6.svelte-2np5h6{border-radius:var(--fds-overlay-corner-radius);box-shadow:var(--fds-flyout-shadow)}.calendar-view-header.svelte-2np5h6.svelte-2np5h6,.calendar-view-pagination-controls.svelte-2np5h6.svelte-2np5h6{align-items:center;display:flex}.calendar-view-pagination-controls.svelte-2np5h6 button.svelte-2np5h6{-webkit-margin-start:4px;inline-size:30px;margin-inline-start:4px;padding:0}.calendar-view-header.svelte-2np5h6.svelte-2np5h6{-webkit-border-after:1px solid var(--fds-card-stroke-default);border-block-end:1px solid var(--fds-card-stroke-default);box-sizing:border-box;inline-size:100%;padding:7px}.calendar-view-header.svelte-2np5h6 button.svelte-2np5h6{align-items:center;background-color:var(--fds-subtle-fill-transparent);border:none;border-radius:var(--fds-control-corner-radius);color:var(--fds-text-primary);display:flex;font-family:var(--fds-font-family-text);font-size:14px;font-weight:600;justify-content:center;line-height:20px;min-block-size:32px;outline:none;padding:0}.calendar-view-header.svelte-2np5h6 button.svelte-2np5h6:focus-visible{box-shadow:var(--fds-focus-stroke)}.calendar-view-header.svelte-2np5h6 button.svelte-2np5h6:hover{background-color:var(--fds-subtle-fill-secondary)}.calendar-view-header.svelte-2np5h6 button.svelte-2np5h6:active{background-color:var(--fds-subtle-fill-tertiary);color:var(--fds-text-secondary)}.calendar-view-header.svelte-2np5h6 button.svelte-2np5h6:disabled{background-color:var(--fds-sutble-fill-disabled);color:var(--fds-text-disabled)}.calendar-view-header.svelte-2np5h6 button:disabled svg.svelte-2np5h6{color:var(--fds-control-strong-fill-disabled)}.calendar-view-header.svelte-2np5h6 button svg.svelte-2np5h6{fill:currentColor;block-size:auto;color:var(--fds-control-strong-fill-default);inline-size:16px}.calendar-view-header-text.svelte-2np5h6.svelte-2np5h6{flex:1 1 auto}.calendar-view-header-text.svelte-2np5h6 button.svelte-2np5h6{flex:1 1 auto;inline-size:100%;justify-content:flex-start;padding-inline:9px}.calendar-view-table.svelte-2np5h6.svelte-2np5h6{block-size:calc(100% - 6px);box-sizing:border-box;display:block;font-size:14px;inline-size:calc(100% - 6px);inset:0;margin:3px;overflow:hidden;position:absolute}.calendar-view-table-wrapper.svelte-2np5h6.svelte-2np5h6{background-color:var(--fds-layer-on-acrylic-background-default);block-size:298px;contain:layout;inline-size:298px;overflow:hidden;position:relative}.calendar-view-table.view-months.svelte-2np5h6.svelte-2np5h6,.calendar-view-table.view-years.svelte-2np5h6.svelte-2np5h6{block-size:calc(100% - 22px);inline-size:calc(100% - 22px);margin:11px}.calendar-view-table.view-months.svelte-2np5h6 tr.svelte-2np5h6,.calendar-view-table.view-years.svelte-2np5h6 tr.svelte-2np5h6{grid-gap:17.3333333333px;-webkit-margin-after:17.3333333333px;grid-template-columns:repeat(4,1fr);margin-block-end:17.3333333333px}.calendar-view-table.svelte-2np5h6 td.svelte-2np5h6,.calendar-view-table.svelte-2np5h6 th.svelte-2np5h6{padding:0}.calendar-view-table.svelte-2np5h6 th.svelte-2np5h6{align-items:center;block-size:40px;display:flex;font-size:13px;font-weight:600;justify-content:center;text-align:center}.calendar-view-table.svelte-2np5h6 tbody.svelte-2np5h6,.calendar-view-table.svelte-2np5h6 thead.svelte-2np5h6{display:flex;flex-direction:column;inline-size:100%}.calendar-view-table.svelte-2np5h6 tbody.svelte-2np5h6,.calendar-view-table.svelte-2np5h6 thead tr.svelte-2np5h6{background-color:var(--fds-solid-background-quarternary);box-shadow:inset 0 0 0 100vmax var(--fds-layer-on-acrylic-background-default)}.calendar-view-table.svelte-2np5h6 thead.svelte-2np5h6{position:relative;z-index:1}.calendar-view-table.svelte-2np5h6 tbody.svelte-2np5h6{inset-block-end:0;inset-inline-start:0;position:absolute}.calendar-view-table.svelte-2np5h6 tbody tr.svelte-2np5h6:last-child{-webkit-margin-after:0;margin-block-end:0}.calendar-view-table.svelte-2np5h6 tr.svelte-2np5h6{grid-gap:2px;-webkit-margin-after:2px;display:grid;grid-template-columns:repeat(7,1fr);inline-size:100%;margin-block-end:2px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsZW5kYXJWaWV3LnN2ZWx0ZSIsInNvdXJjZXMiOlsiQ2FsZW5kYXJWaWV3LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0ID5pbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIsIG9uTW91bnQsIHRpY2sgfSBmcm9tIFwic3ZlbHRlXCI7XHJcbmltcG9ydCB7IGZseSB9IGZyb20gXCJzdmVsdGUvdHJhbnNpdGlvblwiO1xyXG5pbXBvcnQgeyBjaXJjT3V0IH0gZnJvbSBcInN2ZWx0ZS9lYXNpbmdcIjtcclxuaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSBcInN2ZWx0ZS9pbnRlcm5hbFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVFdmVudEZvcndhcmRlciwgZ2V0Q1NTRHVyYXRpb24gfSBmcm9tIFwiLi4vaW50ZXJuYWxcIjtcclxuaW1wb3J0IENhbGVuZGFyVmlld0l0ZW0gZnJvbSBcIi4vQ2FsZW5kYXJWaWV3SXRlbS5zdmVsdGVcIjtcclxuLyoqIExvY2FsZSBjb2RlIHVzZWQgZm9yIHNwZWNpZnlpbmcgdGhlIGxhbmd1YWdlIG9mIHRoZSBjYWxlbmRhci4gSWYgdW5zZXQsIHRoZSBsb2NhbGUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGluZmVycmVkIGZyb20gYG5hdmlnYXRvci5sYW5ndWFnZWAuICovXHJcbmV4cG9ydCBsZXQgbG9jYWxlID0gdW5kZWZpbmVkO1xyXG4vKiogRGV0ZXJtaW5lcyBpZiBtdWx0aXBsZSBkYXRlcyBjYW4gYmUgbWFudWFsbHkgc2VsZWN0ZWQgYnkgdGhlIHVzZXIuICovXHJcbmV4cG9ydCBsZXQgbXVsdGlwbGUgPSBmYWxzZTtcclxuLyoqIENvbnRyb2xzIHdoZXRoZXIgaGVhZGVyIHRleHQgd2lsbCBiZSBzaG93biBhYm92ZSBpdGVtcyByZXByZXNlbnRpbmcgdGhlIGZpcnN0IGRheSBvZiBhIG1vbnRoIG9yIHRoZSBmaXJzdCBtb250aCBvZiBhIHllYXIuICovXHJcbmV4cG9ydCBsZXQgaGVhZGVycyA9IGZhbHNlO1xyXG4vKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjYWxlbmRhciBkYXRlKHMpLiAqL1xyXG5leHBvcnQgbGV0IHZhbHVlID0gbnVsbDtcclxuLyoqIEFycmF5IG9mIHNwZWNpZmljYWxseSBleGNsdWRlZCBkYXRlcyB0aGF0IGNhbm5vdCBiZSBzZWxlY3RlZCBieSB0aGUgdXNlci4gKi9cclxuZXhwb3J0IGxldCBibGFja291dCA9IHVuZGVmaW5lZDtcclxuLyoqIFRoZSBtaW5pbXVtIGRhdGUgdGhhdCBjYW4gYmUgbWFudWFsbHkgc2VsZWN0ZWQgYnkgdGhlIHVzZXIuICovXHJcbmV4cG9ydCBsZXQgbWluID0gdW5kZWZpbmVkO1xyXG4vKiogVGhlIG1heGltdW0gZGF0ZSB0aGF0IGNhbiBiZSBtYW51YWxseSBzZWxlY3RlZCBieSB0aGUgdXNlci4gKi9cclxuZXhwb3J0IGxldCBtYXggPSB1bmRlZmluZWQ7XHJcbi8qKiBUaGUgc2VsZWN0aW9uIHZpZXcgdGhhdCB0aGUgY2FsZW5kYXIgd2lsbCBzdGFydCBpbi4gVmlld3MgY2FuIGJlIG1hbnVhbGx5IGNoYW5nZWQgYnkgdGhlIHVzZXIgd2hlbiBjbGlja2luZyB0aGUgY2FsZW5kYXIncyBoZWFkZXIuICovXHJcbmV4cG9ydCBsZXQgdmlldyA9IFwiZGF5c1wiO1xyXG4vKiogTnVtYmVyIHJlcHJlc2VudGluZyB0aGUgZGF5IHRoYXQgdGhlIGNhbGVuZGFyIHdlZWsgc3RhcnRzIG9uLiAwIGlzIHN1bmRheSwgNiBpcyBzYXR1cmRheS4gKi9cclxuZXhwb3J0IGxldCB3ZWVrU3RhcnQgPSAwO1xyXG4vKiogSU5URVJOQUwgVVNFIE9OTFk6IEFwcGxpZXMgZmx5b3V0IHN0eWxlcyB0byB0aGUgb3V0ZXIgQ2FsZW5kYXJWaWV3IGNvbnRhaW5lci4gKi9cclxuZXhwb3J0IGxldCBfX2Zsb2F0aW5nID0gZmFsc2U7XHJcbi8qKiBTcGVjaWZpZXMgYSBjdXN0b20gY2xhc3MgbmFtZSBmb3IgdGhlIGNhbGVuZGFyJ3Mgb3V0ZXIgY29udGFpbmVyIGVsZW1lbnQuICovXHJcbmxldCBjbGFzc05hbWUgPSBcIlwiO1xyXG5leHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcclxuLyoqIE9idGFpbnMgYSBib3VuZCBET00gcmVmZXJlbmNlIHRvIHRoZSBjYWxlbmRhcidzIG91dGVyIGNvbnRhaW5lciBlbGVtZW50LiAqL1xyXG5leHBvcnQgbGV0IGVsZW1lbnQgPSBudWxsO1xyXG5jb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xyXG5jb25zdCBmb3J3YXJkRXZlbnRzID0gY3JlYXRlRXZlbnRGb3J3YXJkZXIoZ2V0X2N1cnJlbnRfY29tcG9uZW50KCksIFtcImNoYW5nZVwiXSk7XHJcbmNvbnN0IGJvZHlFbGVtZW50QmluZGluZyA9IG5vZGUgPT4gKGJvZHlFbGVtZW50ID0gbm9kZSk7IC8vIGJpbmQ6dGhpcyBicmVha3Mgd2l0aCBvdXIgcGFnZSB0cmFuc2l0aW9uIGZvciBzb21lIHJlYXNvblxyXG5sZXQgaGVhZGVyID0gXCJcIjtcclxubGV0IHZpZXdBbmltYXRpb25EaXJlY3Rpb24gPSBcIm5ldXRyYWxcIjtcclxubGV0IHBhZ2VBbmltYXRpb25EaXJlY3Rpb24gPSBcIm5ldXRyYWxcIjtcclxubGV0IHBhZ2VBbmltYXRpb25EdXJhdGlvbiA9IDA7XHJcbmxldCBib2R5RWxlbWVudCA9IG51bGw7XHJcbmxldCBmaXJzdFZhbHVlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVswXSA6IHZhbHVlO1xyXG5sZXQgcGFnZSA9ICghbWluIHx8IGZpcnN0VmFsdWUgPj0gbWluKSAmJiAoIW1heCB8fCBmaXJzdFZhbHVlIDwgbWF4KVxyXG4gICAgPyBuZXcgRGF0ZSgoZmlyc3RWYWx1ZSAhPT0gbnVsbCAmJiBmaXJzdFZhbHVlICE9PSB2b2lkIDAgPyBmaXJzdFZhbHVlIDogbmV3IERhdGUoKSkuZ2V0RnVsbFllYXIoKSwgKGZpcnN0VmFsdWUgIT09IG51bGwgJiYgZmlyc3RWYWx1ZSAhPT0gdm9pZCAwID8gZmlyc3RWYWx1ZSA6IG5ldyBEYXRlKCkpLmdldE1vbnRoKCksIDEpXHJcbiAgICA6IGZpcnN0VmFsdWUgPCBtaW5cclxuICAgICAgICA/IG5ldyBEYXRlKG1pbi5nZXRGdWxsWWVhcigpLCBtaW4uZ2V0TW9udGgoKSwgMSlcclxuICAgICAgICA6IG5ldyBEYXRlKG1heC5nZXRGdWxsWWVhcigpLCBtYXguZ2V0TW9udGgoKSwgMSk7XHJcbiQ6IGZpcnN0VmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzBdIDogdmFsdWU7XHJcbiQ6IHZpZXcsIHVwZGF0ZVBhZ2UoMCk7XHJcbiQ6IG5leHRQYWdlID0gZ2V0UGFnZUJ5T2Zmc2V0KDEsIHBhZ2UsIHZpZXcpO1xyXG4kOiBpZiAodmlldyA9PT0gXCJkYXlzXCIpIHtcclxuICAgIGhlYWRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwge1xyXG4gICAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxyXG4gICAgICAgIG1vbnRoOiBcImxvbmdcIlxyXG4gICAgfSkuZm9ybWF0KHBhZ2UpO1xyXG59XHJcbmVsc2UgaWYgKHZpZXcgPT09IFwibW9udGhzXCIpIHtcclxuICAgIGhlYWRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwge1xyXG4gICAgICAgIHllYXI6IFwibnVtZXJpY1wiXHJcbiAgICB9KS5mb3JtYXQocGFnZSk7XHJcbn1cclxuZWxzZSBpZiAodmlldyA9PT0gXCJ5ZWFyc1wiKSB7XHJcbiAgICBjb25zdCBkZWNhZGVTdGFydCA9IE1hdGguZmxvb3IocGFnZS5nZXRGdWxsWWVhcigpIC8gMTApICogMTA7XHJcbiAgICBjb25zdCBkZWNhZGVFbmQgPSBkZWNhZGVTdGFydCArIDk7XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQ2OTA1XHJcbiAgICBoZWFkZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHtcclxuICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIlxyXG4gICAgfSkuZm9ybWF0UmFuZ2UobmV3IERhdGUoZGVjYWRlU3RhcnQsIDAsIDEpLCBuZXcgRGF0ZShkZWNhZGVFbmQsIDAsIDEpKTtcclxufVxyXG5vbk1vdW50KCgpID0+IHtcclxuICAgIHBhZ2VBbmltYXRpb25EdXJhdGlvbiA9IGdldENTU0R1cmF0aW9uKFwiLS1mZHMtY29udHJvbC1zbG93LWR1cmF0aW9uXCIpO1xyXG59KTtcclxuZnVuY3Rpb24gZ2V0V2Vla2RheUxvY2FsZShkYXksIHsgbG9jYWxlID0gdW5kZWZpbmVkLCBmb3JtYXQgPSBcImxvbmdcIiwgb2Zmc2V0ID0gMCB9ID0ge30pIHtcclxuICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIHtcclxuICAgICAgICB3ZWVrZGF5OiBmb3JtYXQsXHJcbiAgICAgICAgdGltZVpvbmU6IFwiVVRDXCJcclxuICAgIH0pLmZvcm1hdChuZXcgRGF0ZShEYXRlLlVUQygyMDAwLCAxLCBkYXkgKyBvZmZzZXQgLSAxKSkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldE1vbnRoTG9jYWxlKG1vbnRoLCB7IGxvY2FsZSA9IHVuZGVmaW5lZCwgZm9ybWF0ID0gXCJsb25nXCIgfSA9IHt9KSB7XHJcbiAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCB7XHJcbiAgICAgICAgbW9udGg6IGZvcm1hdFxyXG4gICAgfSkuZm9ybWF0KG5ldyBEYXRlKDIwMDAsIG1vbnRoKSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TW9udGhMZW5ndGgoeWVhciwgbW9udGgpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCArIDEsIDApLmdldERhdGUoKSAtIDE7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TW9udGhEYXlzKHllYXIsIG1vbnRoKSB7XHJcbiAgICBjb25zdCBkYXlzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdldE1vbnRoTGVuZ3RoKHllYXIsIG1vbnRoKSArIDE7IGkrKykge1xyXG4gICAgICAgIGRheXMucHVzaChuZXcgRGF0ZSh5ZWFyLCBtb250aCwgaSArIDEpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXlzO1xyXG59XHJcbmZ1bmN0aW9uIGdldFllYXJNb250aHMoeWVhcikge1xyXG4gICAgY29uc3QgZGF5cyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XHJcbiAgICAgICAgZGF5cy5wdXNoKG5ldyBEYXRlKHllYXIsIGksIDEpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXlzO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVEYXRlcyhhLCBiLCBwcmVjaXNpb24gPSBcInRpbWVcIikge1xyXG4gICAgc3dpdGNoIChwcmVjaXNpb24pIHtcclxuICAgICAgICBjYXNlIFwidGltZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xyXG4gICAgICAgIGNhc2UgXCJkYXlcIjpcclxuICAgICAgICAgICAgcmV0dXJuIChhLmdldEZ1bGxZZWFyKCkgPT09IGIuZ2V0RnVsbFllYXIoKSAmJlxyXG4gICAgICAgICAgICAgICAgYS5nZXRNb250aCgpID09PSBiLmdldE1vbnRoKCkgJiZcclxuICAgICAgICAgICAgICAgIGEuZ2V0RGF0ZSgpID09PSBiLmdldERhdGUoKSk7XHJcbiAgICAgICAgY2FzZSBcIm1vbnRoXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBhLmdldEZ1bGxZZWFyKCkgPT09IGIuZ2V0RnVsbFllYXIoKSAmJiBhLmdldE1vbnRoKCkgPT09IGIuZ2V0TW9udGgoKTtcclxuICAgICAgICBjYXNlIFwieWVhclwiOlxyXG4gICAgICAgICAgICByZXR1cm4gYS5nZXRGdWxsWWVhcigpID09PSBiLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgY2FzZSBcImRlY2FkZVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gKE1hdGguZmxvb3IoYS5nZXRGdWxsWWVhcigpIC8gMTApICogMTAgPT09IE1hdGguZmxvb3IoYi5nZXRGdWxsWWVhcigpIC8gMTApICogMTApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluZGV4T2ZEYXRlKGFycmF5LCBkYXRlLCBwcmVjaXNpb24gPSBcInRpbWVcIikge1xyXG4gICAgcmV0dXJuIGFycmF5LmZpbmRJbmRleChkID0+IGNvbXBhcmVEYXRlcyhkLCBkYXRlLCBwcmVjaXNpb24pKTtcclxufVxyXG5mdW5jdGlvbiBnZXRDYWxlbmRhckRheXMoZGF0ZSkge1xyXG4gICAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgIGNvbnN0IG1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xyXG4gICAgY29uc3QgZmlyc3RXZWVrZGF5ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpLmdldERheSgpO1xyXG4gICAgY29uc3QgY2FsZW5kYXJSb3dzID0gNjtcclxuICAgIGxldCBkYXlzID0gW107XHJcbiAgICBsZXQgbmV4dE1vbnRoID0gbW9udGggKyAxO1xyXG4gICAgbGV0IGxhc3RNb250aCA9IG1vbnRoIC0gMTtcclxuICAgIGxldCBuZXh0TW9udGhZZWFyID0geWVhcjtcclxuICAgIGxldCBsYXN0TW9udGhZZWFyID0geWVhcjtcclxuICAgIGNvbnN0IGRheXNCZWZvcmUgPSAoZmlyc3RXZWVrZGF5IC0gd2Vla1N0YXJ0ICsgNykgJSA3O1xyXG4gICAgaWYgKGRheXNCZWZvcmUgPiAwKSB7XHJcbiAgICAgICAgaWYgKGxhc3RNb250aCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgbGFzdE1vbnRoID0gMTE7XHJcbiAgICAgICAgICAgIGxhc3RNb250aFllYXIgPSB5ZWFyIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF5cyA9IGdldE1vbnRoRGF5cyhsYXN0TW9udGhZZWFyLCBsYXN0TW9udGgpLnNsaWNlKC1kYXlzQmVmb3JlKTtcclxuICAgIH1cclxuICAgIGRheXMgPSBkYXlzLmNvbmNhdChnZXRNb250aERheXMoeWVhciwgbW9udGgpKTtcclxuICAgIGlmIChuZXh0TW9udGggPT09IDEyKSB7XHJcbiAgICAgICAgbmV4dE1vbnRoID0gMDtcclxuICAgICAgICBuZXh0TW9udGhZZWFyID0geWVhciArIDE7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXlzQWZ0ZXIgPSA3ICogY2FsZW5kYXJSb3dzIC0gZGF5cy5sZW5ndGg7XHJcbiAgICBkYXlzID0gZGF5cy5jb25jYXQoZ2V0TW9udGhEYXlzKG5leHRNb250aFllYXIsIG5leHRNb250aCkuc2xpY2UoMCwgZGF5c0FmdGVyKSk7XHJcbiAgICByZXR1cm4gZGF5cztcclxufVxyXG5mdW5jdGlvbiBnZXRDYWxlbmRhck1vbnRocyhkYXRlKSB7XHJcbiAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xyXG4gICAgbGV0IG1vbnRocyA9IFtdO1xyXG4gICAgcmV0dXJuIG1vbnRocy5jb25jYXQoZ2V0WWVhck1vbnRocyh5ZWFyKSwgZ2V0WWVhck1vbnRocyh5ZWFyICsgMSkuc2xpY2UoMCwgNCkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldENhbGVuZGFyWWVhcnMoZGF0ZSkge1xyXG4gICAgY29uc3QgZGVjYWRlU3RhcnQgPSBNYXRoLmZsb29yKGRhdGUuZ2V0RnVsbFllYXIoKSAvIDEwKSAqIDEwO1xyXG4gICAgbGV0IHllYXJzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICB5ZWFycy5wdXNoKG5ldyBEYXRlKGRlY2FkZVN0YXJ0ICsgaSwgMCwgMSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRlY2FkZVN0YXJ0ICUgMjAgPT09IDApIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xyXG4gICAgICAgICAgICB5ZWFycy51bnNoaWZ0KG5ldyBEYXRlKGRlY2FkZVN0YXJ0IC0gKGkgKyAxKSwgMCwgMSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICB5ZWFycy5wdXNoKG5ldyBEYXRlKGRlY2FkZVN0YXJ0ICsgaSArIDEyLCAwLCAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgICAgICAgICAgeWVhcnMucHVzaChuZXcgRGF0ZShkZWNhZGVTdGFydCArIGkgKyAxMiwgMCwgMSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB5ZWFycztcclxufVxyXG5mdW5jdGlvbiBnZXRQYWdlQnlPZmZzZXQob2Zmc2V0LCBwYWdlLCB2aWV3KSB7XHJcbiAgICBpZiAodmlldyA9PT0gXCJkYXlzXCIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGUocGFnZS5nZXRGdWxsWWVhcigpLCBwYWdlLmdldE1vbnRoKCkgKyBvZmZzZXQsIDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmlldyA9PT0gXCJtb250aHNcIikge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShwYWdlLmdldEZ1bGxZZWFyKCkgKyBvZmZzZXQsIDAsIDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmlldyA9PT0gXCJ5ZWFyc1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE1hdGguZmxvb3IocGFnZS5nZXRGdWxsWWVhcigpIC8gMTApICogMTAgKyBvZmZzZXQgKiAxMCwgMCwgMSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlUGFnZShhbW91bnQgPSAwLCBkaXJlY3Rpb25PdmVycmlkZSA9IHVuZGVmaW5lZCkge1xyXG4gICAgcGFnZSA9IGdldFBhZ2VCeU9mZnNldChhbW91bnQsIHBhZ2UsIHZpZXcpO1xyXG4gICAgaWYgKGRpcmVjdGlvbk92ZXJyaWRlKSB7XHJcbiAgICAgICAgcGFnZUFuaW1hdGlvbkRpcmVjdGlvbiA9IGRpcmVjdGlvbk92ZXJyaWRlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChhbW91bnQgPD0gLTEpIHtcclxuICAgICAgICBwYWdlQW5pbWF0aW9uRGlyZWN0aW9uID0gXCJ1cFwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYW1vdW50ID49IDEpIHtcclxuICAgICAgICBwYWdlQW5pbWF0aW9uRGlyZWN0aW9uID0gXCJkb3duXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwYWdlQW5pbWF0aW9uRGlyZWN0aW9uID0gXCJuZXV0cmFsXCI7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlVmlldyhuZXdWaWV3KSB7XHJcbiAgICBpZiAoKHZpZXcgPT09IFwiZGF5c1wiICYmIG5ld1ZpZXcgPT09IFwibW9udGhzXCIpIHx8XHJcbiAgICAgICAgKHZpZXcgPT09IFwibW9udGhzXCIgJiYgbmV3VmlldyA9PT0gXCJ5ZWFyc1wiKSkge1xyXG4gICAgICAgIHZpZXdBbmltYXRpb25EaXJlY3Rpb24gPSBcInVwXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgodmlldyA9PT0gXCJ5ZWFyc1wiICYmIG5ld1ZpZXcgPT09IFwibW9udGhzXCIpIHx8XHJcbiAgICAgICAgKHZpZXcgPT09IFwibW9udGhzXCIgJiYgbmV3VmlldyA9PT0gXCJkYXlzXCIpKSB7XHJcbiAgICAgICAgdmlld0FuaW1hdGlvbkRpcmVjdGlvbiA9IFwiZG93blwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmlld0FuaW1hdGlvbkRpcmVjdGlvbiA9IFwibmV1dHJhbFwiO1xyXG4gICAgfVxyXG4gICAgcGFnZUFuaW1hdGlvbkRpcmVjdGlvbiA9IFwibmV1dHJhbFwiO1xyXG4gICAgdmlldyA9IG5ld1ZpZXc7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCwgZGF0ZSkge1xyXG4gICAgY29uc3QgeyBrZXkgfSA9IGV2ZW50O1xyXG4gICAgaWYgKGtleSA9PT0gXCJBcnJvd1VwXCIgfHxcclxuICAgICAgICBrZXkgPT09IFwiQXJyb3dEb3duXCIgfHxcclxuICAgICAgICBrZXkgPT09IFwiQXJyb3dMZWZ0XCIgfHxcclxuICAgICAgICBrZXkgPT09IFwiQXJyb3dSaWdodFwiIHx8XHJcbiAgICAgICAga2V5ID09PSBcIkhvbWVcIiB8fFxyXG4gICAgICAgIGtleSA9PT0gXCJFbmRcIikge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZXZlbnQuY3RybEtleSAmJiAoa2V5ID09PSBcIkFycm93VXBcIiB8fCBrZXkgPT09IFwiQXJyb3dEb3duXCIpKSB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJBcnJvd1VwXCIpIHtcclxuICAgICAgICAgICAgdXBkYXRlVmlldyh2aWV3ID09PSBcImRheXNcIiA/IFwibW9udGhzXCIgOiBcInllYXJzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiQXJyb3dEb3duXCIpIHtcclxuICAgICAgICAgICAgdXBkYXRlVmlldyh2aWV3ID09PSBcInllYXJzXCIgPyBcIm1vbnRoc1wiIDogXCJkYXlzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgZm9jdXNPcmRlciA9IGJvZHlFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJidXR0b25cIik7XHJcbiAgICBsZXQgZm9jdXNlZERhdGUgPSBkYXRlO1xyXG4gICAgY29uc3QgZm9jdXNJbmRleCA9IEFycmF5LmZyb20oZm9jdXNPcmRlcikuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcclxuICAgIGlmIChmb2N1c09yZGVyLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBpZiAodmlldyA9PT0gXCJkYXlzXCIpIHtcclxuICAgICAgICBsZXQgZm9jdXNJbmNyZW1lbnRBbW91bnQgPSB7XHJcbiAgICAgICAgICAgIEFycm93VXA6IC03LFxyXG4gICAgICAgICAgICBBcnJvd0Rvd246IDcsXHJcbiAgICAgICAgICAgIEFycm93TGVmdDogLTEsXHJcbiAgICAgICAgICAgIEFycm93UmlnaHQ6IDFcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghZm9jdXNJbmNyZW1lbnRBbW91bnRba2V5XSB8fCBldmVudC5zaGlmdEtleSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGZvY3VzZWREYXRlID0gbmV3IERhdGUobmV3IERhdGUoZm9jdXNlZERhdGUpLnNldERhdGUoZm9jdXNlZERhdGUuZ2V0RGF0ZSgpICsgZm9jdXNJbmNyZW1lbnRBbW91bnRba2V5XSkpO1xyXG4gICAgICAgIGNvbnN0IG5leHREYXRlSXNCbGFja291dCA9IGJsYWNrb3V0ICYmIGluZGV4T2ZEYXRlKGJsYWNrb3V0LCBmb2N1c2VkRGF0ZSwgXCJkYXlcIikgPiAtMTtcclxuICAgICAgICBpZiAobmV4dERhdGVJc0JsYWNrb3V0KSB7XHJcbiAgICAgICAgICAgIGZvY3VzZWREYXRlLnNldERhdGUoZm9jdXNlZERhdGUuZ2V0RGF0ZSgpICsgZm9jdXNJbmNyZW1lbnRBbW91bnRba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF5cyA9IGdldENhbGVuZGFyRGF5cyhmb2N1c2VkRGF0ZSk7XHJcbiAgICAgICAgY29uc3QgbmV3Rm9jdXNlZERhdGUgPSBjYWxlbmRhckRheXMuZmluZChkYXkgPT4gY29tcGFyZURhdGVzKGRheSwgZm9jdXNlZERhdGUsIFwidGltZVwiKSk7XHJcbiAgICAgICAgaWYgKG1pbiA+IG5ld0ZvY3VzZWREYXRlIHx8IG1heCA8IG5ld0ZvY3VzZWREYXRlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKGZvY3VzZWREYXRlLmdldE1vbnRoKCkgIT09IHBhZ2UuZ2V0TW9udGgoKSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIkFycm93TGVmdFwiIHx8IGtleSA9PT0gXCJBcnJvd1VwXCIpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVBhZ2UoLTEsIFwibmV1dHJhbFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiQXJyb3dSaWdodFwiIHx8IGtleSA9PT0gXCJBcnJvd0Rvd25cIikge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlUGFnZSgxLCBcIm5ldXRyYWxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXdhaXQgdGljaygpO1xyXG4gICAgICAgICAgICBmb2N1c09yZGVyID0gYm9keUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcImJ1dHRvblwiKTtcclxuICAgICAgICAgICAgZm9jdXNlZERhdGUgPSBuZXdGb2N1c2VkRGF0ZTtcclxuICAgICAgICAgICAgZm9jdXNPcmRlciA9PT0gbnVsbCB8fCBmb2N1c09yZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb2N1c09yZGVyW2NhbGVuZGFyRGF5cy5pbmRleE9mKG5ld0ZvY3VzZWREYXRlKV0uZm9jdXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb2N1c09yZGVyID09PSBudWxsIHx8IGZvY3VzT3JkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvY3VzT3JkZXJbZm9jdXNJbmRleCArIGZvY3VzSW5jcmVtZW50QW1vdW50W2tleV0gKiAobmV4dERhdGVJc0JsYWNrb3V0ID8gMiA6IDEpXS5mb2N1cygpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmlldyA9PT0gXCJtb250aHNcIiB8fCB2aWV3ID09PSBcInllYXJzXCIpIHtcclxuICAgICAgICBsZXQgY2FsZW5kYXIgPSBbXTtcclxuICAgICAgICBjb25zdCBmb2N1c0luY3JlbWVudEFtb3VudCA9IHtcclxuICAgICAgICAgICAgQXJyb3dVcDogLTQsXHJcbiAgICAgICAgICAgIEFycm93RG93bjogNCxcclxuICAgICAgICAgICAgQXJyb3dMZWZ0OiAtMSxcclxuICAgICAgICAgICAgQXJyb3dSaWdodDogMVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFmb2N1c0luY3JlbWVudEFtb3VudFtrZXldIHx8IGV2ZW50LnNoaWZ0S2V5KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKHZpZXcgPT09IFwibW9udGhzXCIpIHtcclxuICAgICAgICAgICAgZm9jdXNlZERhdGUgPSBuZXcgRGF0ZShuZXcgRGF0ZShmb2N1c2VkRGF0ZSkuc2V0TW9udGgoZm9jdXNlZERhdGUuZ2V0TW9udGgoKSArIGZvY3VzSW5jcmVtZW50QW1vdW50W2tleV0sIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvY3VzZWREYXRlID0gbmV3IERhdGUobmV3IERhdGUoZm9jdXNlZERhdGUpLnNldEZ1bGxZZWFyKGZvY3VzZWREYXRlLmdldEZ1bGxZZWFyKCkgKyBmb2N1c0luY3JlbWVudEFtb3VudFtrZXldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGVuZGFyID1cclxuICAgICAgICAgICAgdmlldyA9PT0gXCJtb250aHNcIiA/IGdldENhbGVuZGFyTW9udGhzKGZvY3VzZWREYXRlKSA6IGdldENhbGVuZGFyWWVhcnMoZm9jdXNlZERhdGUpO1xyXG4gICAgICAgIGNvbnN0IG5ld0ZvY3VzZWREYXRlID0gY2FsZW5kYXIuZmluZChkYXkgPT4gY29tcGFyZURhdGVzKGRheSwgZm9jdXNlZERhdGUsIHZpZXcgPT09IFwibW9udGhzXCIgPyBcIm1vbnRoXCIgOiBcInllYXJcIikpO1xyXG4gICAgICAgIGNvbnN0IGFib3ZlTWluaW11bU1vbnRocyA9IChtaW4gPT09IG51bGwgfHwgbWluID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW4uZ2V0TW9udGgoKSkgPiBuZXdGb2N1c2VkRGF0ZS5nZXRNb250aCgpICYmXHJcbiAgICAgICAgICAgIChtaW4gPT09IG51bGwgfHwgbWluID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtaW4uZ2V0RnVsbFllYXIoKSkgPT09IG5ld0ZvY3VzZWREYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgY29uc3QgYWJvdmVNaW5pbXVtWWVhcnMgPSAobWluID09PSBudWxsIHx8IG1pbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWluLmdldEZ1bGxZZWFyKCkpID4gbmV3Rm9jdXNlZERhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICBpZiAoKHZpZXcgPT09IFwibW9udGhzXCIgPyBhYm92ZU1pbmltdW1Nb250aHMgOiBhYm92ZU1pbmltdW1ZZWFycykgfHxcclxuICAgICAgICAgICAgbWF4IDwgbmV3Rm9jdXNlZERhdGUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoIWNvbXBhcmVEYXRlcyhmb2N1c2VkRGF0ZSwgcGFnZSwgdmlldyA9PT0gXCJtb250aHNcIiA/IFwieWVhclwiIDogXCJkZWNhZGVcIikpIHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJBcnJvd0xlZnRcIiB8fCBrZXkgPT09IFwiQXJyb3dVcFwiKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVQYWdlKC0xLCBcIm5ldXRyYWxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIkFycm93UmlnaHRcIiB8fCBrZXkgPT09IFwiQXJyb3dEb3duXCIpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVBhZ2UoMSwgXCJuZXV0cmFsXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF3YWl0IHRpY2soKTtcclxuICAgICAgICAgICAgZm9jdXNlZERhdGUgPSBuZXdGb2N1c2VkRGF0ZTtcclxuICAgICAgICAgICAgZm9jdXNPcmRlciA9IGJvZHlFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJidXR0b25cIik7XHJcbiAgICAgICAgICAgIGZvY3VzT3JkZXIgPT09IG51bGwgfHwgZm9jdXNPcmRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9jdXNPcmRlcltjYWxlbmRhci5pbmRleE9mKG5ld0ZvY3VzZWREYXRlKV0uZm9jdXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb2N1c09yZGVyID09PSBudWxsIHx8IGZvY3VzT3JkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvY3VzT3JkZXJbZm9jdXNJbmRleCArIGZvY3VzSW5jcmVtZW50QW1vdW50W2tleV1dLmZvY3VzKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2VsZWN0RGF5KGRheSkge1xyXG4gICAgaWYgKG11bHRpcGxlKSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gW2RheV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluZGV4T2ZEYXRlKHZhbHVlLCBkYXkpID09PSAtMSkge1xyXG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGRheSk7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXhPZkRhdGUodmFsdWUsIGRheSkpXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KHZhbHVlLnNsaWNlKGluZGV4T2ZEYXRlKHZhbHVlLCBkYXkpICsgMSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcclxuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xyXG4gICAgICAgIGlmIChkYXkuZ2V0VGltZSgpID09PSAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmdldFRpbWUoKSkpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBkYXk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzcGF0Y2goXCJjaGFuZ2VcIiwgdmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHNlbGVjdE1vbnRoKG1vbnRoKSB7XHJcbiAgICBwYWdlID0gbmV3IERhdGUobmV3IERhdGUobW9udGguc2V0RGF0ZSgxKSkpO1xyXG4gICAgdXBkYXRlVmlldyhcImRheXNcIik7XHJcbn1cclxuZnVuY3Rpb24gc2VsZWN0WWVhcihtb250aCkge1xyXG4gICAgcGFnZS5zZXRGdWxsWWVhcihtb250aC5nZXRGdWxsWWVhcigpKTtcclxuICAgIHVwZGF0ZVZpZXcoXCJtb250aHNcIik7XHJcbn1cclxuZnVuY3Rpb24gZmFkZVNjYWxlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAsIGVhc2luZyA9IHggPT4geCwgYmFzZVNjYWxlID0gMCB9KSB7XHJcbiAgICBjb25zdCBvID0gK2dldENvbXB1dGVkU3R5bGUobm9kZSkub3BhY2l0eTtcclxuICAgIGNvbnN0IGlzID0gMSAtIGJhc2VTY2FsZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGVsYXksXHJcbiAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgY3NzOiB0ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZWFzZWQgPSBlYXNpbmcodCk7XHJcbiAgICAgICAgICAgIHJldHVybiBgb3BhY2l0eTogJHtlYXNlZCAqIG99OyB0cmFuc2Zvcm06IHNjYWxlKCR7ZWFzZWQgKiBpcyArIGJhc2VTY2FsZX0pYDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbjwvc2NyaXB0PlxuXG48IS0tXG5AY29tcG9uZW50XG5BIGNhbGVuZGFyIHZpZXcgbGV0cyBhIHVzZXIgdmlldyBhbmQgaW50ZXJhY3Qgd2l0aCBhIGNhbGVuZGFyIHRoYXQgdGhleSBjYW4gbmF2aWdhdGUgYnkgbW9udGgsIHllYXIsIG9yIGRlY2FkZS4gQSB1c2VyIGNhbiBzZWxlY3QgYSBzaW5nbGUgZGF0ZSBvciBtdWx0aXBsZSBkYXRlcy4gW0RvY3NdKGh0dHBzOi8vZmx1ZW50LXN2ZWx0ZS52ZXJjZWwuYXBwL2RvY3MvY29tcG9uZW50cy9jYWxlbmRhcnZpZXcpXG4tIFVzYWdlOlxuICAgIGBgYHRzeFxuICAgIDxDYWxlbmRhclZpZXcgdmFsdWU9e25ldyBEYXRlKDIwMjIsIDIsIDE0KX0gLz5cbiAgICBgYGBcbi0tPlxuPGRpdlxuXHRjbGFzcz1cImNhbGVuZGFyLXZpZXcge2NsYXNzTmFtZX1cIlxuXHRjbGFzczpmbG9hdGluZz17X19mbG9hdGluZ31cblx0dXNlOmZvcndhcmRFdmVudHNcblx0YmluZDp0aGlzPXtlbGVtZW50fVxuXHR7Li4uJCRyZXN0UHJvcHN9XG4+XG5cdDxoZWFkZXIgY2xhc3M9XCJjYWxlbmRhci12aWV3LWhlYWRlclwiPlxuXHRcdDxkaXYgY2xhc3M9XCJjYWxlbmRhci12aWV3LWhlYWRlci10ZXh0XCIgcm9sZT1cImhlYWRpbmdcIiBhcmlhLWxpdmU9XCJwb2xpdGVcIj5cblx0XHRcdDxidXR0b25cblx0XHRcdFx0b246Y2xpY2s9eygpID0+IHVwZGF0ZVZpZXcodmlldyA9PT0gXCJkYXlzXCIgPyBcIm1vbnRoc1wiIDogXCJ5ZWFyc1wiKX1cblx0XHRcdFx0ZGlzYWJsZWQ9e3ZpZXcgPT09IFwieWVhcnNcIn0+e2hlYWRlcn08L2J1dHRvblxuXHRcdFx0PlxuXHRcdDwvZGl2PlxuXHRcdDxkaXYgY2xhc3M9XCJjYWxlbmRhci12aWV3LXBhZ2luYXRpb24tY29udHJvbHNcIj5cblx0XHRcdDxidXR0b24gZGlzYWJsZWQ9e3ZpZXcgJiYgbWluID49IHBhZ2V9IG9uOmNsaWNrPXsoKSA9PiB1cGRhdGVQYWdlKC0xKX0+XG5cdFx0XHRcdDxzdmcgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAxNiAxNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cblx0XHRcdFx0XHQ8cGF0aFxuXHRcdFx0XHRcdFx0ZD1cIk00Ljk1NjgxIDEwLjk5OEM0LjE0OTEyIDEwLjk5OCAzLjY3NDY2IDEwLjA5IDQuMTM1OTEgOS40MjY5OEw2Ljc2ODU0IDUuNjQyNTdDNy4zNjUzMiA0Ljc4NDY5IDguNjM0NDggNC43ODQ3IDkuMjMxMjYgNS42NDI1N0wxMS44NjM5IDkuNDI2OThDMTIuMzI1MSAxMC4wOSAxMS44NTA3IDEwLjk5OCAxMS4wNDMgMTAuOTk4SDQuOTU2ODFaXCJcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L3N2Zz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0PGJ1dHRvbiBkaXNhYmxlZD17bWF4IDwgbmV4dFBhZ2V9IG9uOmNsaWNrPXsoKSA9PiB1cGRhdGVQYWdlKDEpfT5cblx0XHRcdFx0PHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPlxuXHRcdFx0XHRcdDxwYXRoXG5cdFx0XHRcdFx0XHRkPVwiTTQuOTU2ODEgNUM0LjE0OTEyIDUgMy42NzQ2NiA1LjkwODAzIDQuMTM1OTEgNi41NzEwN0w2Ljc2ODU0IDEwLjM1NTVDNy4zNjUzMiAxMS4yMTM0IDguNjM0NDggMTEuMjEzMyA5LjIzMTI2IDEwLjM1NTVMMTEuODYzOSA2LjU3MTA2QzEyLjMyNTEgNS45MDgwMyAxMS44NTA3IDUgMTEuMDQzIDVINC45NTY4MVpcIlxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvc3ZnPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0PC9kaXY+XG5cdDwvaGVhZGVyPlxuXHQ8ZGl2IGNsYXNzPVwiY2FsZW5kYXItdmlldy10YWJsZS13cmFwcGVyXCI+XG5cdFx0eyNrZXkgdmlld31cblx0XHRcdDx0YWJsZVxuXHRcdFx0XHRjbGFzcz1cImNhbGVuZGFyLXZpZXctdGFibGUgdmlldy17dmlld31cIlxuXHRcdFx0XHRyb2xlPVwiZ3JpZFwiXG5cdFx0XHRcdGluOmZhZGVTY2FsZT17e1xuXHRcdFx0XHRcdGR1cmF0aW9uOiB2aWV3QW5pbWF0aW9uRGlyZWN0aW9uICE9PSBcIm5ldXRyYWxcIiA/IDUwMCA6IDAsXG5cdFx0XHRcdFx0ZWFzaW5nOiBjaXJjT3V0LFxuXHRcdFx0XHRcdGJhc2VTY2FsZTogdmlld0FuaW1hdGlvbkRpcmVjdGlvbiA9PT0gXCJ1cFwiID8gMS4yOSA6IDAuODQsXG5cdFx0XHRcdFx0ZGVsYXk6IHZpZXdBbmltYXRpb25EaXJlY3Rpb24gIT09IFwibmV1dHJhbFwiID8gMTUwIDogMFxuXHRcdFx0XHR9fVxuXHRcdFx0XHRvdXQ6ZmFkZVNjYWxlfGxvY2FsPXt7XG5cdFx0XHRcdFx0ZHVyYXRpb246IHZpZXdBbmltYXRpb25EaXJlY3Rpb24gIT09IFwibmV1dHJhbFwiID8gMTUwIDogMCxcblx0XHRcdFx0XHRlYXNpbmc6IGNpcmNPdXQsXG5cdFx0XHRcdFx0YmFzZVNjYWxlOiB2aWV3QW5pbWF0aW9uRGlyZWN0aW9uID09PSBcInVwXCIgPyAwLjg0IDogMS4yOSxcblx0XHRcdFx0XHRkZWxheTogMFxuXHRcdFx0XHR9fVxuXHRcdFx0PlxuXHRcdFx0XHR7I2lmIHZpZXcgPT09IFwiZGF5c1wifVxuXHRcdFx0XHRcdDx0aGVhZD5cblx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0eyNlYWNoIEFycmF5KDcpIGFzIF8sIGRheX1cblx0XHRcdFx0XHRcdFx0XHQ8dGhcblx0XHRcdFx0XHRcdFx0XHRcdHNjb3BlPVwiY29sXCJcblx0XHRcdFx0XHRcdFx0XHRcdHsuLi57XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFiYnI6IGdldFdlZWtkYXlMb2NhbGUoZGF5LCB7IGxvY2FsZSwgb2Zmc2V0OiB3ZWVrU3RhcnQgfSlcblx0XHRcdFx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0e2dldFdlZWtkYXlMb2NhbGUoZGF5LCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxvY2FsZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9ybWF0OiBcInNob3J0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldDogd2Vla1N0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0XHR9KX1cblx0XHRcdFx0XHRcdFx0XHQ8L3RoPlxuXHRcdFx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHRcdDwvdGhlYWQ+XG5cdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdHsja2V5IHBhZ2V9XG5cdFx0XHRcdFx0PHRib2R5XG5cdFx0XHRcdFx0XHR1c2U6Ym9keUVsZW1lbnRCaW5kaW5nXG5cdFx0XHRcdFx0XHRpbjpmbHk9e3tcblx0XHRcdFx0XHRcdFx0b3BhY2l0eTogMSxcblx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IHBhZ2VBbmltYXRpb25EdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0ZWFzaW5nOiBjaXJjT3V0LFxuXHRcdFx0XHRcdFx0XHR5OlxuXHRcdFx0XHRcdFx0XHRcdHBhZ2VBbmltYXRpb25EaXJlY3Rpb24gPT09IFwibmV1dHJhbFwiXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IDBcblx0XHRcdFx0XHRcdFx0XHRcdDogcGFnZUFuaW1hdGlvbkRpcmVjdGlvbiA9PT0gXCJ1cFwiXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IC0xOThcblx0XHRcdFx0XHRcdFx0XHRcdDogMTk4XG5cdFx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdFx0b3V0OmZseXxsb2NhbD17e1xuXHRcdFx0XHRcdFx0XHRvcGFjaXR5OiAxLFxuXHRcdFx0XHRcdFx0XHRkdXJhdGlvbjogcGFnZUFuaW1hdGlvbkR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHRlYXNpbmc6IGNpcmNPdXQsXG5cdFx0XHRcdFx0XHRcdHk6XG5cdFx0XHRcdFx0XHRcdFx0cGFnZUFuaW1hdGlvbkRpcmVjdGlvbiA9PT0gXCJuZXV0cmFsXCJcblx0XHRcdFx0XHRcdFx0XHRcdD8gMFxuXHRcdFx0XHRcdFx0XHRcdFx0OiBwYWdlQW5pbWF0aW9uRGlyZWN0aW9uID09PSBcInVwXCJcblx0XHRcdFx0XHRcdFx0XHRcdD8gMTk4XG5cdFx0XHRcdFx0XHRcdFx0XHQ6IC0xOThcblx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0eyNpZiB2aWV3ID09PSBcImRheXNcIn1cblx0XHRcdFx0XHRcdFx0eyNlYWNoIEFycmF5KDYpIGFzIF8sIHdlZWt9XG5cdFx0XHRcdFx0XHRcdFx0PHRyPlxuXHRcdFx0XHRcdFx0XHRcdFx0eyNlYWNoIGdldENhbGVuZGFyRGF5cyhwYWdlKS5zbGljZSh3ZWVrICogNywgd2VlayAqIDcgKyA3KSBhcyBkYXksIGl9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHtAY29uc3Qgc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KEFycmF5LmlzQXJyYXkodmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ/IGluZGV4T2ZEYXRlKHZhbHVlLCBkYXksIFwiZGF5XCIpID4gLTFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDogY29tcGFyZURhdGVzKHZhbHVlLCBkYXksIFwiZGF5XCIpKX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0e0Bjb25zdCBpbk1vbnRoID0gY29tcGFyZURhdGVzKGRheSwgcGFnZSwgXCJtb250aFwiKX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0e0Bjb25zdCBmaXJzdEZvY3VzYWJsZURheSA9IGdldENhbGVuZGFyRGF5cyhwYWdlKS5maW5kKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGQgPT5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbXBhcmVEYXRlcyhkLCBwYWdlLCBcIm1vbnRoXCIpICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIWJsYWNrb3V0IHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluZGV4T2ZEYXRlKGJsYWNrb3V0LCBkLCBcImRheVwiKSA9PT0gLTEpICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIW1pbiB8fCBtaW4gPD0gZCkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCghbWF4IHx8IG1heCA+PSBkKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpfVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDx0ZCByb2xlPVwiZ3JpZGNlbGxcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8Q2FsZW5kYXJWaWV3SXRlbVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHNlbGVjdERheShkYXkpfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b246a2V5ZG93bj17ZSA9PiBoYW5kbGVLZXlEb3duKGUsIGRheSl9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRPZlJhbmdlPXshaW5Nb250aH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQ9e2NvbXBhcmVEYXRlcyhkYXksIG5ldyBEYXRlKCksIFwiZGF5XCIpfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGlzYWJsZWQ9e21pbiA+IGRheSB8fCBtYXggPCBkYXl9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRibGFja291dD17YmxhY2tvdXQgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5kZXhPZkRhdGUoYmxhY2tvdXQsIGRheSwgXCJkYXlcIikgPiAtMX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGhlYWRlcj17cGFnZSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRoZWFkZXJzICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRheS5nZXREYXRlKCkgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Z2V0TW9udGhMb2NhbGUoZGF5LmdldE1vbnRoKCksIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRsb2NhbGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9ybWF0OiBcInNob3J0XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSl9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJpbmRleD17Zmlyc3RGb2N1c2FibGVEYXkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbXBhcmVEYXRlcyhmaXJzdEZvY3VzYWJsZURheSwgZGF5LCBcImRheVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ/IDBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0OiAtMX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtzZWxlY3RlZH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7ZGF5LmdldERhdGUoKX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L0NhbGVuZGFyVmlld0l0ZW0+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0XHRcdFx0ey9lYWNofVxuXHRcdFx0XHRcdFx0ezplbHNlfVxuXHRcdFx0XHRcdFx0XHR7I2VhY2ggQXJyYXkoNCkgYXMgXywgcm93fVxuXHRcdFx0XHRcdFx0XHRcdDx0cj5cblx0XHRcdFx0XHRcdFx0XHRcdHsjaWYgdmlldyA9PT0gXCJtb250aHNcIn1cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyNlYWNoIGdldENhbGVuZGFyTW9udGhzKHBhZ2UpLnNsaWNlKHJvdyAqIDQsIHJvdyAqIDQgKyA0KSBhcyBtb250aCwgaX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7QGNvbnN0IHNlbGVjdGVkID1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoQXJyYXkuaXNBcnJheSh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PyBpbmRleE9mRGF0ZSh2YWx1ZSwgbW9udGgsIFwibW9udGhcIikgPiAtMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ6IGNvbXBhcmVEYXRlcyh2YWx1ZSwgbW9udGgsIFwibW9udGhcIikpfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtAY29uc3QgaW5ZZWFyID1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoLmdldEZ1bGxZZWFyKCkgPT09IHBhZ2UuZ2V0RnVsbFllYXIoKX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7QGNvbnN0IGZpcnN0Rm9jdXNhYmxlTW9udGggPSBnZXRDYWxlbmRhck1vbnRocyhcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhZ2Vcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpLmZpbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkID0+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbXBhcmVEYXRlcyhkLCBwYWdlLCBcInllYXJcIikgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCFtaW4gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgRGF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pbi5nZXRGdWxsWWVhcigpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWluLmdldE1vbnRoKCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KSA8PVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IERhdGUoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGQuZ2V0RnVsbFllYXIoKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZC5nZXRNb250aCgpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIW1heCB8fCBtYXggPj0gZClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpfVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PHRkIHJvbGU9XCJncmlkY2VsbFwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PENhbGVuZGFyVmlld0l0ZW1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHNlbGVjdE1vbnRoKG1vbnRoKX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b246a2V5ZG93bj17ZSA9PiBoYW5kbGVLZXlEb3duKGUsIG1vbnRoKX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyaWFudD1cIm1vbnRoWWVhclwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dE9mUmFuZ2U9eyFpblllYXJ9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQ9e2NvbXBhcmVEYXRlcyhcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb250aCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgRGF0ZSgpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibW9udGhcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkaXNhYmxlZD17KG1pbj8uZ2V0TW9udGgoKSA+IG1vbnRoLmdldE1vbnRoKCkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaW4/LmdldEZ1bGxZZWFyKCkgPT09XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb250aC5nZXRGdWxsWWVhcigpKSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heCA8IG1vbnRofVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRoZWFkZXI9e3BhZ2UgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRoZWFkZXJzICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9udGguZ2V0TW9udGgoKSA9PT0gMCAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0e3NlbGVjdGVkfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0YWJpbmRleD17Zmlyc3RGb2N1c2FibGVNb250aCAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb21wYXJlRGF0ZXMoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zmlyc3RGb2N1c2FibGVNb250aCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb250aCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1vbnRoXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdD8gMFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDogLTF9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtnZXRNb250aExvY2FsZShtb250aC5nZXRNb250aCgpLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bG9jYWxlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZvcm1hdDogXCJzaG9ydFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9DYWxlbmRhclZpZXdJdGVtPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvdGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0XHRcdFx0XHRcdHs6ZWxzZSBpZiB2aWV3ID09PSBcInllYXJzXCJ9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsjZWFjaCBnZXRDYWxlbmRhclllYXJzKHBhZ2UpLnNsaWNlKHJvdyAqIDQsIHJvdyAqIDQgKyA0KSBhcyB5ZWFyLCBpfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtAY29uc3Qgc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChBcnJheS5pc0FycmF5KHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ/IGluZGV4T2ZEYXRlKHZhbHVlLCB5ZWFyLCBcInllYXJcIikgPiAtMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ6IGNvbXBhcmVEYXRlcyh2YWx1ZSwgeWVhciwgXCJ5ZWFyXCIpKX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7QGNvbnN0IGluRGVjYWRlID0gY29tcGFyZURhdGVzKHllYXIsIHBhZ2UsIFwiZGVjYWRlXCIpfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtAY29uc3QgZmlyc3RGb2N1c2FibGVZZWFyID0gZ2V0Q2FsZW5kYXJZZWFycyhcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhZ2Vcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpLmZpbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkID0+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbXBhcmVEYXRlcyhkLCBwYWdlLCBcImRlY2FkZVwiKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIW1pbiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pbi5nZXRGdWxsWWVhcigpIDw9IGQuZ2V0RnVsbFllYXIoKSkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCFtYXggfHwgbWF4ID49IGQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KX1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDx0ZCByb2xlPVwiZ3JpZGNlbGxcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxDYWxlbmRhclZpZXdJdGVtXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiBzZWxlY3RZZWFyKHllYXIpfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbjprZXlkb3duPXtlID0+IGhhbmRsZUtleURvd24oZSwgeWVhcil9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhcmlhbnQ9XCJtb250aFllYXJcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRPZlJhbmdlPXshaW5EZWNhZGV9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQ9e2NvbXBhcmVEYXRlcyh5ZWFyLCBuZXcgRGF0ZSgpLCBcInllYXJcIil9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRpc2FibGVkPXttaW4/LmdldEZ1bGxZZWFyKCkgPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHllYXIuZ2V0RnVsbFllYXIoKSB8fCBtYXggPCB5ZWFyfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7c2VsZWN0ZWR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRhYmluZGV4PXtmaXJzdEZvY3VzYWJsZVllYXIgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29tcGFyZURhdGVzKGZpcnN0Rm9jdXNhYmxlWWVhciwgeWVhciwgXCJ5ZWFyXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PyAwXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0OiAtMX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0e3llYXIuZ2V0RnVsbFllYXIoKX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvQ2FsZW5kYXJWaWV3SXRlbT5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3RkPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdFx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHRcdFx0XHRcdDwvdHI+XG5cdFx0XHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0PC90Ym9keT5cblx0XHRcdFx0ey9rZXl9XG5cdFx0XHQ8L3RhYmxlPlxuXHRcdHsva2V5fVxuXHQ8L2Rpdj5cbjwvZGl2PlxuXG48c3R5bGUgPi5jYWxlbmRhci12aWV3e2JhY2tncm91bmQtY2xpcDpwYWRkaW5nLWJveDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZkcy1zb2xpZC1iYWNrZ3JvdW5kLXF1YXJ0ZXJuYXJ5KTtibG9jay1zaXplOjM0N3B4O2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmRzLXN1cmZhY2Utc3Ryb2tlLWZseW91dCk7Ym9yZGVyLXJhZGl1czp2YXIoLS1mZHMtY29udHJvbC1jb3JuZXItcmFkaXVzKTtjb2xvcjp2YXIoLS1mZHMtdGV4dC1wcmltYXJ5KTtkaXNwbGF5OmlubGluZS1mbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmb250LWZhbWlseTp2YXIoLS1mZHMtZm9udC1mYW1pbHktdGV4dCk7aW5saW5lLXNpemU6MzAwcHg7cG9zaXRpb246cmVsYXRpdmU7dGV4dC1hbGlnbjpzdGFydDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LmNhbGVuZGFyLXZpZXcuZmxvYXRpbmd7Ym9yZGVyLXJhZGl1czp2YXIoLS1mZHMtb3ZlcmxheS1jb3JuZXItcmFkaXVzKTtib3gtc2hhZG93OnZhcigtLWZkcy1mbHlvdXQtc2hhZG93KX0uY2FsZW5kYXItdmlldy1oZWFkZXIsLmNhbGVuZGFyLXZpZXctcGFnaW5hdGlvbi1jb250cm9sc3thbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4fS5jYWxlbmRhci12aWV3LXBhZ2luYXRpb24tY29udHJvbHMgYnV0dG9uey13ZWJraXQtbWFyZ2luLXN0YXJ0OjRweDtpbmxpbmUtc2l6ZTozMHB4O21hcmdpbi1pbmxpbmUtc3RhcnQ6NHB4O3BhZGRpbmc6MH0uY2FsZW5kYXItdmlldy1oZWFkZXJ7LXdlYmtpdC1ib3JkZXItYWZ0ZXI6MXB4IHNvbGlkIHZhcigtLWZkcy1jYXJkLXN0cm9rZS1kZWZhdWx0KTtib3JkZXItYmxvY2stZW5kOjFweCBzb2xpZCB2YXIoLS1mZHMtY2FyZC1zdHJva2UtZGVmYXVsdCk7Ym94LXNpemluZzpib3JkZXItYm94O2lubGluZS1zaXplOjEwMCU7cGFkZGluZzo3cHh9LmNhbGVuZGFyLXZpZXctaGVhZGVyIGJ1dHRvbnthbGlnbi1pdGVtczpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtc3VidGxlLWZpbGwtdHJhbnNwYXJlbnQpO2JvcmRlcjpub25lO2JvcmRlci1yYWRpdXM6dmFyKC0tZmRzLWNvbnRyb2wtY29ybmVyLXJhZGl1cyk7Y29sb3I6dmFyKC0tZmRzLXRleHQtcHJpbWFyeSk7ZGlzcGxheTpmbGV4O2ZvbnQtZmFtaWx5OnZhcigtLWZkcy1mb250LWZhbWlseS10ZXh0KTtmb250LXNpemU6MTRweDtmb250LXdlaWdodDo2MDA7anVzdGlmeS1jb250ZW50OmNlbnRlcjtsaW5lLWhlaWdodDoyMHB4O21pbi1ibG9jay1zaXplOjMycHg7b3V0bGluZTpub25lO3BhZGRpbmc6MH0uY2FsZW5kYXItdmlldy1oZWFkZXIgYnV0dG9uOmZvY3VzLXZpc2libGV7Ym94LXNoYWRvdzp2YXIoLS1mZHMtZm9jdXMtc3Ryb2tlKX0uY2FsZW5kYXItdmlldy1oZWFkZXIgYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLXN1YnRsZS1maWxsLXNlY29uZGFyeSl9LmNhbGVuZGFyLXZpZXctaGVhZGVyIGJ1dHRvbjphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtc3VidGxlLWZpbGwtdGVydGlhcnkpO2NvbG9yOnZhcigtLWZkcy10ZXh0LXNlY29uZGFyeSl9LmNhbGVuZGFyLXZpZXctaGVhZGVyIGJ1dHRvbjpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZkcy1zdXRibGUtZmlsbC1kaXNhYmxlZCk7Y29sb3I6dmFyKC0tZmRzLXRleHQtZGlzYWJsZWQpfS5jYWxlbmRhci12aWV3LWhlYWRlciBidXR0b246ZGlzYWJsZWQgc3Zne2NvbG9yOnZhcigtLWZkcy1jb250cm9sLXN0cm9uZy1maWxsLWRpc2FibGVkKX0uY2FsZW5kYXItdmlldy1oZWFkZXIgYnV0dG9uIHN2Z3tmaWxsOmN1cnJlbnRDb2xvcjtibG9jay1zaXplOmF1dG87Y29sb3I6dmFyKC0tZmRzLWNvbnRyb2wtc3Ryb25nLWZpbGwtZGVmYXVsdCk7aW5saW5lLXNpemU6MTZweH0uY2FsZW5kYXItdmlldy1oZWFkZXItdGV4dHtmbGV4OjEgMSBhdXRvfS5jYWxlbmRhci12aWV3LWhlYWRlci10ZXh0IGJ1dHRvbntmbGV4OjEgMSBhdXRvO2lubGluZS1zaXplOjEwMCU7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7cGFkZGluZy1pbmxpbmU6OXB4fS5jYWxlbmRhci12aWV3LXRhYmxle2Jsb2NrLXNpemU6Y2FsYygxMDAlIC0gNnB4KTtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpibG9jaztmb250LXNpemU6MTRweDtpbmxpbmUtc2l6ZTpjYWxjKDEwMCUgLSA2cHgpO2luc2V0OjA7bWFyZ2luOjNweDtvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246YWJzb2x1dGV9LmNhbGVuZGFyLXZpZXctdGFibGUtd3JhcHBlcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZkcy1sYXllci1vbi1hY3J5bGljLWJhY2tncm91bmQtZGVmYXVsdCk7YmxvY2stc2l6ZToyOThweDtjb250YWluOmxheW91dDtpbmxpbmUtc2l6ZToyOThweDtvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmV9LmNhbGVuZGFyLXZpZXctdGFibGUudmlldy1tb250aHMsLmNhbGVuZGFyLXZpZXctdGFibGUudmlldy15ZWFyc3tibG9jay1zaXplOmNhbGMoMTAwJSAtIDIycHgpO2lubGluZS1zaXplOmNhbGMoMTAwJSAtIDIycHgpO21hcmdpbjoxMXB4fS5jYWxlbmRhci12aWV3LXRhYmxlLnZpZXctbW9udGhzIHRyLC5jYWxlbmRhci12aWV3LXRhYmxlLnZpZXcteWVhcnMgdHJ7Z3JpZC1nYXA6MTcuMzMzMzMzMzMzM3B4Oy13ZWJraXQtbWFyZ2luLWFmdGVyOjE3LjMzMzMzMzMzMzNweDtncmlkLXRlbXBsYXRlLWNvbHVtbnM6cmVwZWF0KDQsMWZyKTttYXJnaW4tYmxvY2stZW5kOjE3LjMzMzMzMzMzMzNweH0uY2FsZW5kYXItdmlldy10YWJsZSB0ZCwuY2FsZW5kYXItdmlldy10YWJsZSB0aHtwYWRkaW5nOjB9LmNhbGVuZGFyLXZpZXctdGFibGUgdGh7YWxpZ24taXRlbXM6Y2VudGVyO2Jsb2NrLXNpemU6NDBweDtkaXNwbGF5OmZsZXg7Zm9udC1zaXplOjEzcHg7Zm9udC13ZWlnaHQ6NjAwO2p1c3RpZnktY29udGVudDpjZW50ZXI7dGV4dC1hbGlnbjpjZW50ZXJ9LmNhbGVuZGFyLXZpZXctdGFibGUgdGJvZHksLmNhbGVuZGFyLXZpZXctdGFibGUgdGhlYWR7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtpbmxpbmUtc2l6ZToxMDAlfS5jYWxlbmRhci12aWV3LXRhYmxlIHRib2R5LC5jYWxlbmRhci12aWV3LXRhYmxlIHRoZWFkIHRye2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLXNvbGlkLWJhY2tncm91bmQtcXVhcnRlcm5hcnkpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMTAwdm1heCB2YXIoLS1mZHMtbGF5ZXItb24tYWNyeWxpYy1iYWNrZ3JvdW5kLWRlZmF1bHQpfS5jYWxlbmRhci12aWV3LXRhYmxlIHRoZWFke3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0uY2FsZW5kYXItdmlldy10YWJsZSB0Ym9keXtpbnNldC1ibG9jay1lbmQ6MDtpbnNldC1pbmxpbmUtc3RhcnQ6MDtwb3NpdGlvbjphYnNvbHV0ZX0uY2FsZW5kYXItdmlldy10YWJsZSB0Ym9keSB0cjpsYXN0LWNoaWxkey13ZWJraXQtbWFyZ2luLWFmdGVyOjA7bWFyZ2luLWJsb2NrLWVuZDowfS5jYWxlbmRhci12aWV3LXRhYmxlIHRye2dyaWQtZ2FwOjJweDstd2Via2l0LW1hcmdpbi1hZnRlcjoycHg7ZGlzcGxheTpncmlkO2dyaWQtdGVtcGxhdGUtY29sdW1uczpyZXBlYXQoNywxZnIpO2lubGluZS1zaXplOjEwMCU7bWFyZ2luLWJsb2NrLWVuZDoycHh9PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFzbkJRLDBDQUFjLENBQUMsZ0JBQWdCLFdBQVcsQ0FBQyxpQkFBaUIsSUFBSSxrQ0FBa0MsQ0FBQyxDQUFDLFdBQVcsS0FBSyxDQUFDLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLDJCQUEyQixDQUFDLENBQUMsY0FBYyxJQUFJLDJCQUEyQixDQUFDLENBQUMsTUFBTSxJQUFJLGtCQUFrQixDQUFDLENBQUMsUUFBUSxXQUFXLENBQUMsZUFBZSxNQUFNLENBQUMsWUFBWSxJQUFJLHNCQUFzQixDQUFDLENBQUMsWUFBWSxLQUFLLENBQUMsU0FBUyxRQUFRLENBQUMsV0FBVyxLQUFLLENBQUMsb0JBQW9CLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxDQUFDLGdCQUFnQixJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsY0FBYyxxQ0FBUyxDQUFDLGNBQWMsSUFBSSwyQkFBMkIsQ0FBQyxDQUFDLFdBQVcsSUFBSSxtQkFBbUIsQ0FBQyxDQUFDLGlEQUFxQixDQUFDLDhEQUFrQyxDQUFDLFlBQVksTUFBTSxDQUFDLFFBQVEsSUFBSSxDQUFDLGdEQUFrQyxDQUFDLG9CQUFNLENBQUMscUJBQXFCLEdBQUcsQ0FBQyxZQUFZLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLGlEQUFxQixDQUFDLHFCQUFxQixHQUFHLENBQUMsS0FBSyxDQUFDLElBQUkseUJBQXlCLENBQUMsQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLHlCQUF5QixDQUFDLENBQUMsV0FBVyxVQUFVLENBQUMsWUFBWSxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsbUNBQXFCLENBQUMsb0JBQU0sQ0FBQyxZQUFZLE1BQU0sQ0FBQyxpQkFBaUIsSUFBSSw2QkFBNkIsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLGNBQWMsSUFBSSwyQkFBMkIsQ0FBQyxDQUFDLE1BQU0sSUFBSSxrQkFBa0IsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLFlBQVksSUFBSSxzQkFBc0IsQ0FBQyxDQUFDLFVBQVUsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLGdCQUFnQixNQUFNLENBQUMsWUFBWSxJQUFJLENBQUMsZUFBZSxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsbUNBQXFCLENBQUMsb0JBQU0sY0FBYyxDQUFDLFdBQVcsSUFBSSxrQkFBa0IsQ0FBQyxDQUFDLG1DQUFxQixDQUFDLG9CQUFNLE1BQU0sQ0FBQyxpQkFBaUIsSUFBSSwyQkFBMkIsQ0FBQyxDQUFDLG1DQUFxQixDQUFDLG9CQUFNLE9BQU8sQ0FBQyxpQkFBaUIsSUFBSSwwQkFBMEIsQ0FBQyxDQUFDLE1BQU0sSUFBSSxvQkFBb0IsQ0FBQyxDQUFDLG1DQUFxQixDQUFDLG9CQUFNLFNBQVMsQ0FBQyxpQkFBaUIsSUFBSSwwQkFBMEIsQ0FBQyxDQUFDLE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxDQUFDLG1DQUFxQixDQUFDLE1BQU0sU0FBUyxDQUFDLGlCQUFHLENBQUMsTUFBTSxJQUFJLGtDQUFrQyxDQUFDLENBQUMsbUNBQXFCLENBQUMsTUFBTSxDQUFDLGlCQUFHLENBQUMsS0FBSyxZQUFZLENBQUMsV0FBVyxJQUFJLENBQUMsTUFBTSxJQUFJLGlDQUFpQyxDQUFDLENBQUMsWUFBWSxJQUFJLENBQUMsc0RBQTBCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyx3Q0FBMEIsQ0FBQyxvQkFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsZ0JBQWdCLFVBQVUsQ0FBQyxlQUFlLEdBQUcsQ0FBQyxnREFBb0IsQ0FBQyxXQUFXLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLFVBQVUsQ0FBQyxRQUFRLEtBQUssQ0FBQyxVQUFVLElBQUksQ0FBQyxZQUFZLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxTQUFTLE1BQU0sQ0FBQyxTQUFTLFFBQVEsQ0FBQyx3REFBNEIsQ0FBQyxpQkFBaUIsSUFBSSx5Q0FBeUMsQ0FBQyxDQUFDLFdBQVcsS0FBSyxDQUFDLFFBQVEsTUFBTSxDQUFDLFlBQVksS0FBSyxDQUFDLFNBQVMsTUFBTSxDQUFDLFNBQVMsUUFBUSxDQUFDLG9CQUFvQix3Q0FBWSxDQUFDLG9CQUFvQix1Q0FBVyxDQUFDLFdBQVcsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFlBQVksS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLG9CQUFvQiwwQkFBWSxDQUFDLGdCQUFFLENBQUMsb0JBQW9CLHlCQUFXLENBQUMsZ0JBQUUsQ0FBQyxTQUFTLGVBQWUsQ0FBQyxxQkFBcUIsZUFBZSxDQUFDLHNCQUFzQixPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxpQkFBaUIsZUFBZSxDQUFDLGtDQUFvQixDQUFDLGdCQUFFLENBQUMsa0NBQW9CLENBQUMsZ0JBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxrQ0FBb0IsQ0FBQyxnQkFBRSxDQUFDLFlBQVksTUFBTSxDQUFDLFdBQVcsSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLGdCQUFnQixNQUFNLENBQUMsV0FBVyxNQUFNLENBQUMsa0NBQW9CLENBQUMsbUJBQUssQ0FBQyxrQ0FBb0IsQ0FBQyxtQkFBSyxDQUFDLFFBQVEsSUFBSSxDQUFDLGVBQWUsTUFBTSxDQUFDLFlBQVksSUFBSSxDQUFDLGtDQUFvQixDQUFDLG1CQUFLLENBQUMsa0NBQW9CLENBQUMsS0FBSyxDQUFDLGdCQUFFLENBQUMsaUJBQWlCLElBQUksa0NBQWtDLENBQUMsQ0FBQyxXQUFXLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSx5Q0FBeUMsQ0FBQyxDQUFDLGtDQUFvQixDQUFDLG1CQUFLLENBQUMsU0FBUyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsa0NBQW9CLENBQUMsbUJBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLENBQUMsU0FBUyxRQUFRLENBQUMsa0NBQW9CLENBQUMsS0FBSyxDQUFDLGdCQUFFLFdBQVcsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLENBQUMsa0NBQW9CLENBQUMsZ0JBQUUsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxxQkFBcUIsR0FBRyxDQUFDLFFBQVEsSUFBSSxDQUFDLHNCQUFzQixPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxZQUFZLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxDQUFDIn0= */");
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[41] = list[i];
	child_ctx[51] = i;
	return child_ctx;
}

function get_each_context_4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[56] = list[i];
	child_ctx[49] = i;

	const constants_0 = /*value*/ child_ctx[0] !== null && (Array.isArray(/*value*/ child_ctx[0])
	? indexOfDate(/*value*/ child_ctx[0], /*year*/ child_ctx[56], "year") > -1
	: compareDates(/*value*/ child_ctx[0], /*year*/ child_ctx[56], "year"));

	child_ctx[45] = constants_0;
	const constants_1 = compareDates(/*year*/ child_ctx[56], /*page*/ child_ctx[11], "decade");
	child_ctx[57] = constants_1;
	const constants_2 = getCalendarYears(/*page*/ child_ctx[11]).find(d => compareDates(d, /*page*/ child_ctx[11], "decade") && (!/*min*/ child_ctx[6] || /*min*/ child_ctx[6].getFullYear() <= d.getFullYear()) && (!/*max*/ child_ctx[7] || /*max*/ child_ctx[7] >= d));
	child_ctx[58] = constants_2;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[52] = list[i];
	child_ctx[49] = i;

	const constants_0 = /*value*/ child_ctx[0] !== null && (Array.isArray(/*value*/ child_ctx[0])
	? indexOfDate(/*value*/ child_ctx[0], /*month*/ child_ctx[52], "month") > -1
	: compareDates(/*value*/ child_ctx[0], /*month*/ child_ctx[52], "month"));

	child_ctx[45] = constants_0;
	const constants_1 = /*month*/ child_ctx[52].getFullYear() === /*page*/ child_ctx[11].getFullYear();
	child_ctx[53] = constants_1;
	const constants_2 = getCalendarMonths(/*page*/ child_ctx[11]).find(d => compareDates(d, /*page*/ child_ctx[11], "year") && (!/*min*/ child_ctx[6] || new Date(/*min*/ child_ctx[6].getFullYear(), /*min*/ child_ctx[6].getMonth(), 1) <= new Date(d.getFullYear(), d.getMonth(), 1)) && (!/*max*/ child_ctx[7] || /*max*/ child_ctx[7] >= d));
	child_ctx[54] = constants_2;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[41] = list[i];
	child_ctx[43] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[44] = list[i];
	child_ctx[49] = i;

	const constants_0 = /*value*/ child_ctx[0] !== null && (Array.isArray(/*value*/ child_ctx[0])
	? indexOfDate(/*value*/ child_ctx[0], /*day*/ child_ctx[44], "day") > -1
	: compareDates(/*value*/ child_ctx[0], /*day*/ child_ctx[44], "day"));

	child_ctx[45] = constants_0;
	const constants_1 = compareDates(/*day*/ child_ctx[44], /*page*/ child_ctx[11], "month");
	child_ctx[46] = constants_1;
	const constants_2 = /*getCalendarDays*/ child_ctx[19](/*page*/ child_ctx[11]).find(d => compareDates(d, /*page*/ child_ctx[11], "month") && (!/*blackout*/ child_ctx[5] || indexOfDate(/*blackout*/ child_ctx[5], d, "day") === -1) && (!/*min*/ child_ctx[6] || /*min*/ child_ctx[6] <= d) && (!/*max*/ child_ctx[7] || /*max*/ child_ctx[7] >= d));
	child_ctx[47] = constants_2;
	return child_ctx;
}

function get_each_context_5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[41] = list[i];
	child_ctx[44] = i;
	return child_ctx;
}

// (423:4) {#if view === "days"}
function create_if_block_3(ctx) {
	let thead;
	let tr;
	let each_value_5 = Array(7);
	validate_each_argument(each_value_5);
	let each_blocks = [];

	for (let i = 0; i < each_value_5.length; i += 1) {
		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
	}

	const block = {
		c: function create() {
			thead = element_1("thead");
			tr = element_1("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(tr, "class", "svelte-2np5h6");
			add_location(tr, file, 424, 6, 16581);
			attr_dev(thead, "class", "svelte-2np5h6");
			add_location(thead, file, 423, 5, 16567);
		},
		m: function mount(target, anchor) {
			insert_dev(target, thead, anchor);
			append_dev(thead, tr);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*locale, weekStart*/ 264) {
				each_value_5 = Array(7);
				validate_each_argument(each_value_5);
				let i;

				for (i = 0; i < each_value_5.length; i += 1) {
					const child_ctx = get_each_context_5(ctx, each_value_5, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(tr, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_5.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(thead);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(423:4) {#if view === \\\"days\\\"}",
		ctx
	});

	return block;
}

// (426:7) {#each Array(7) as _, day}
function create_each_block_5(ctx) {
	let th;

	let t0_value = getWeekdayLocale(/*day*/ ctx[44], {
		locale: /*locale*/ ctx[3],
		format: "short",
		offset: /*weekStart*/ ctx[8]
	}) + "";

	let t0;
	let t1;

	let th_levels = [
		{ scope: "col" },
		{
			abbr: getWeekdayLocale(/*day*/ ctx[44], {
				locale: /*locale*/ ctx[3],
				offset: /*weekStart*/ ctx[8]
			})
		}
	];

	let th_data = {};

	for (let i = 0; i < th_levels.length; i += 1) {
		th_data = assign(th_data, th_levels[i]);
	}

	const block = {
		c: function create() {
			th = element_1("th");
			t0 = text(t0_value);
			t1 = space();
			set_attributes(th, th_data);
			toggle_class(th, "svelte-2np5h6", true);
			add_location(th, file, 426, 8, 16628);
		},
		m: function mount(target, anchor) {
			insert_dev(target, th, anchor);
			append_dev(th, t0);
			append_dev(th, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*locale, weekStart*/ 264 && t0_value !== (t0_value = getWeekdayLocale(/*day*/ ctx[44], {
				locale: /*locale*/ ctx[3],
				format: "short",
				offset: /*weekStart*/ ctx[8]
			}) + "")) set_data_dev(t0, t0_value);

			set_attributes(th, th_data = get_spread_update(th_levels, [
				{ scope: "col" },
				dirty[0] & /*locale, weekStart*/ 264 && {
					abbr: getWeekdayLocale(/*day*/ ctx[44], {
						locale: /*locale*/ ctx[3],
						offset: /*weekStart*/ ctx[8]
					})
				}
			]));

			toggle_class(th, "svelte-2np5h6", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(th);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_5.name,
		type: "each",
		source: "(426:7) {#each Array(7) as _, day}",
		ctx
	});

	return block;
}

// (516:6) {:else}
function create_else_block(ctx) {
	let each_1_anchor;
	let current;
	let each_value_2 = Array(4);
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*page, min, max, headers, value, selectMonth, handleKeyDown, locale, view, selectYear*/ 54528219) {
				each_value_2 = Array(4);
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(516:6) {:else}",
		ctx
	});

	return block;
}

// (469:6) {#if view === "days"}
function create_if_block(ctx) {
	let each_1_anchor;
	let current;
	let each_value = Array(6);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*getCalendarDays, page, min, max, blackout, headers, locale, value, selectDay, handleKeyDown*/ 13109497) {
				each_value = Array(6);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(469:6) {#if view === \\\"days\\\"}",
		ctx
	});

	return block;
}

// (583:36) 
function create_if_block_2(ctx) {
	let each_1_anchor;
	let current;
	let each_value_4 = getCalendarYears(/*page*/ ctx[11]).slice(/*row*/ ctx[51] * 4, /*row*/ ctx[51] * 4 + 4);
	validate_each_argument(each_value_4);
	let each_blocks = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*page, min, max, value, selectYear, handleKeyDown*/ 37750977) {
				each_value_4 = getCalendarYears(/*page*/ ctx[11]).slice(/*row*/ ctx[51] * 4, /*row*/ ctx[51] * 4 + 4);
				validate_each_argument(each_value_4);
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4(ctx, each_value_4, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_4.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(583:36) ",
		ctx
	});

	return block;
}

// (519:9) {#if view === "months"}
function create_if_block_1(ctx) {
	let each_1_anchor;
	let current;
	let each_value_3 = getCalendarMonths(/*page*/ ctx[11]).slice(/*row*/ ctx[51] * 4, /*row*/ ctx[51] * 4 + 4);
	validate_each_argument(each_value_3);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*page, min, max, headers, value, selectMonth, handleKeyDown, locale*/ 20973785) {
				each_value_3 = getCalendarMonths(/*page*/ ctx[11]).slice(/*row*/ ctx[51] * 4, /*row*/ ctx[51] * 4 + 4);
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(519:9) {#if view === \\\"months\\\"}",
		ctx
	});

	return block;
}

// (602:12) <CalendarViewItem              on:click={() => selectYear(year)}              on:keydown={e => handleKeyDown(e, year)}              variant="monthYear"              outOfRange={!inDecade}              current={compareDates(year, new Date(), "year")}              disabled={min?.getFullYear() >               year.getFullYear() || max < year}              {selected}              tabindex={firstFocusableYear &&              compareDates(firstFocusableYear, year, "year")               ? 0               : -1}             >
function create_default_slot_2(ctx) {
	let t_value = /*year*/ ctx[56].getFullYear() + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*page*/ 2048 && t_value !== (t_value = /*year*/ ctx[56].getFullYear() + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(602:12) <CalendarViewItem              on:click={() => selectYear(year)}              on:keydown={e => handleKeyDown(e, year)}              variant=\\\"monthYear\\\"              outOfRange={!inDecade}              current={compareDates(year, new Date(), \\\"year\\\")}              disabled={min?.getFullYear() >               year.getFullYear() || max < year}              {selected}              tabindex={firstFocusableYear &&              compareDates(firstFocusableYear, year, \\\"year\\\")               ? 0               : -1}             >",
		ctx
	});

	return block;
}

// (584:10) {#each getCalendarYears(page).slice(row * 4, row * 4 + 4) as year, i}
function create_each_block_4(ctx) {
	let td;
	let calendarviewitem;
	let t;
	let current;

	function click_handler_5() {
		return /*click_handler_5*/ ctx[35](/*year*/ ctx[56]);
	}

	function keydown_handler_2(...args) {
		return /*keydown_handler_2*/ ctx[36](/*year*/ ctx[56], ...args);
	}

	calendarviewitem = new CalendarViewItem({
			props: {
				variant: "monthYear",
				outOfRange: !/*inDecade*/ ctx[57],
				current: compareDates(/*year*/ ctx[56], new Date(), "year"),
				disabled: /*min*/ ctx[6]?.getFullYear() > /*year*/ ctx[56].getFullYear() || /*max*/ ctx[7] < /*year*/ ctx[56],
				selected: /*selected*/ ctx[45],
				tabindex: /*firstFocusableYear*/ ctx[58] && compareDates(/*firstFocusableYear*/ ctx[58], /*year*/ ctx[56], "year")
				? 0
				: -1,
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	calendarviewitem.$on("click", click_handler_5);
	calendarviewitem.$on("keydown", keydown_handler_2);

	const block = {
		c: function create() {
			td = element_1("td");
			create_component(calendarviewitem.$$.fragment);
			t = space();
			attr_dev(td, "role", "gridcell");
			attr_dev(td, "class", "svelte-2np5h6");
			add_location(td, file, 600, 11, 21790);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			mount_component(calendarviewitem, td, null);
			append_dev(td, t);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const calendarviewitem_changes = {};
			if (dirty[0] & /*page*/ 2048) calendarviewitem_changes.outOfRange = !/*inDecade*/ ctx[57];
			if (dirty[0] & /*page*/ 2048) calendarviewitem_changes.current = compareDates(/*year*/ ctx[56], new Date(), "year");
			if (dirty[0] & /*min, page, max*/ 2240) calendarviewitem_changes.disabled = /*min*/ ctx[6]?.getFullYear() > /*year*/ ctx[56].getFullYear() || /*max*/ ctx[7] < /*year*/ ctx[56];
			if (dirty[0] & /*value, page*/ 2049) calendarviewitem_changes.selected = /*selected*/ ctx[45];

			if (dirty[0] & /*page, min, max*/ 2240) calendarviewitem_changes.tabindex = /*firstFocusableYear*/ ctx[58] && compareDates(/*firstFocusableYear*/ ctx[58], /*year*/ ctx[56], "year")
			? 0
			: -1;

			if (dirty[0] & /*page*/ 2048 | dirty[1] & /*$$scope*/ 1073741824) {
				calendarviewitem_changes.$$scope = { dirty, ctx };
			}

			calendarviewitem.$set(calendarviewitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(calendarviewitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(calendarviewitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			destroy_component(calendarviewitem);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_4.name,
		type: "each",
		source: "(584:10) {#each getCalendarYears(page).slice(row * 4, row * 4 + 4) as year, i}",
		ctx
	});

	return block;
}

// (548:12) <CalendarViewItem              on:click={() => selectMonth(month)}              on:keydown={e => handleKeyDown(e, month)}              variant="monthYear"              outOfRange={!inYear}              current={compareDates(               month,               new Date(),               "month"              )}              disabled={(min?.getMonth() > month.getMonth() &&               min?.getFullYear() ===                month.getFullYear()) ||               max < month}              header={page &&               headers &&               month.getMonth() === 0 &&               month.getFullYear().toString()}              {selected}              tabindex={firstFocusableMonth &&              compareDates(               firstFocusableMonth,               month,               "month"              )               ? 0               : -1}             >
function create_default_slot_1(ctx) {
	let t_value = getMonthLocale(/*month*/ ctx[52].getMonth(), {
		locale: /*locale*/ ctx[3],
		format: "short"
	}) + "";

	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*page, locale*/ 2056 && t_value !== (t_value = getMonthLocale(/*month*/ ctx[52].getMonth(), {
				locale: /*locale*/ ctx[3],
				format: "short"
			}) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(548:12) <CalendarViewItem              on:click={() => selectMonth(month)}              on:keydown={e => handleKeyDown(e, month)}              variant=\\\"monthYear\\\"              outOfRange={!inYear}              current={compareDates(               month,               new Date(),               \\\"month\\\"              )}              disabled={(min?.getMonth() > month.getMonth() &&               min?.getFullYear() ===                month.getFullYear()) ||               max < month}              header={page &&               headers &&               month.getMonth() === 0 &&               month.getFullYear().toString()}              {selected}              tabindex={firstFocusableMonth &&              compareDates(               firstFocusableMonth,               month,               \\\"month\\\"              )               ? 0               : -1}             >",
		ctx
	});

	return block;
}

// (520:10) {#each getCalendarMonths(page).slice(row * 4, row * 4 + 4) as month, i}
function create_each_block_3(ctx) {
	let td;
	let calendarviewitem;
	let t;
	let current;

	function click_handler_4() {
		return /*click_handler_4*/ ctx[33](/*month*/ ctx[52]);
	}

	function keydown_handler_1(...args) {
		return /*keydown_handler_1*/ ctx[34](/*month*/ ctx[52], ...args);
	}

	calendarviewitem = new CalendarViewItem({
			props: {
				variant: "monthYear",
				outOfRange: !/*inYear*/ ctx[53],
				current: compareDates(/*month*/ ctx[52], new Date(), "month"),
				disabled: /*min*/ ctx[6]?.getMonth() > /*month*/ ctx[52].getMonth() && /*min*/ ctx[6]?.getFullYear() === /*month*/ ctx[52].getFullYear() || /*max*/ ctx[7] < /*month*/ ctx[52],
				header: /*page*/ ctx[11] && /*headers*/ ctx[4] && /*month*/ ctx[52].getMonth() === 0 && /*month*/ ctx[52].getFullYear().toString(),
				selected: /*selected*/ ctx[45],
				tabindex: /*firstFocusableMonth*/ ctx[54] && compareDates(/*firstFocusableMonth*/ ctx[54], /*month*/ ctx[52], "month")
				? 0
				: -1,
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	calendarviewitem.$on("click", click_handler_4);
	calendarviewitem.$on("keydown", keydown_handler_1);

	const block = {
		c: function create() {
			td = element_1("td");
			create_component(calendarviewitem.$$.fragment);
			t = space();
			attr_dev(td, "role", "gridcell");
			attr_dev(td, "class", "svelte-2np5h6");
			add_location(td, file, 546, 11, 20040);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			mount_component(calendarviewitem, td, null);
			append_dev(td, t);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const calendarviewitem_changes = {};
			if (dirty[0] & /*page*/ 2048) calendarviewitem_changes.outOfRange = !/*inYear*/ ctx[53];
			if (dirty[0] & /*page*/ 2048) calendarviewitem_changes.current = compareDates(/*month*/ ctx[52], new Date(), "month");
			if (dirty[0] & /*min, page, max*/ 2240) calendarviewitem_changes.disabled = /*min*/ ctx[6]?.getMonth() > /*month*/ ctx[52].getMonth() && /*min*/ ctx[6]?.getFullYear() === /*month*/ ctx[52].getFullYear() || /*max*/ ctx[7] < /*month*/ ctx[52];
			if (dirty[0] & /*page, headers*/ 2064) calendarviewitem_changes.header = /*page*/ ctx[11] && /*headers*/ ctx[4] && /*month*/ ctx[52].getMonth() === 0 && /*month*/ ctx[52].getFullYear().toString();
			if (dirty[0] & /*value, page*/ 2049) calendarviewitem_changes.selected = /*selected*/ ctx[45];

			if (dirty[0] & /*page, min, max*/ 2240) calendarviewitem_changes.tabindex = /*firstFocusableMonth*/ ctx[54] && compareDates(/*firstFocusableMonth*/ ctx[54], /*month*/ ctx[52], "month")
			? 0
			: -1;

			if (dirty[0] & /*page, locale*/ 2056 | dirty[1] & /*$$scope*/ 1073741824) {
				calendarviewitem_changes.$$scope = { dirty, ctx };
			}

			calendarviewitem.$set(calendarviewitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(calendarviewitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(calendarviewitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			destroy_component(calendarviewitem);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(520:10) {#each getCalendarMonths(page).slice(row * 4, row * 4 + 4) as month, i}",
		ctx
	});

	return block;
}

// (517:7) {#each Array(4) as _, row}
function create_each_block_2(ctx) {
	let tr;
	let current_block_type_index;
	let if_block;
	let t;
	let current;
	const if_block_creators = [create_if_block_1, create_if_block_2];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*view*/ ctx[1] === "months") return 0;
		if (/*view*/ ctx[1] === "years") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx, [-1, -1]))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			tr = element_1("tr");
			if (if_block) if_block.c();
			t = space();
			attr_dev(tr, "class", "svelte-2np5h6");
			add_location(tr, file, 517, 8, 19143);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(tr, null);
			}

			append_dev(tr, t);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(tr, t);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(517:7) {#each Array(4) as _, row}",
		ctx
	});

	return block;
}

// (489:11) <CalendarViewItem             on:click={() => selectDay(day)}             on:keydown={e => handleKeyDown(e, day)}             outOfRange={!inMonth}             current={compareDates(day, new Date(), "day")}             disabled={min > day || max < day}             blackout={blackout &&              indexOfDate(blackout, day, "day") > -1}             header={page &&              headers &&              day.getDate() === 1 &&              getMonthLocale(day.getMonth(), {               locale,               format: "short"              })}             tabindex={firstFocusableDay &&             compareDates(firstFocusableDay, day, "day")              ? 0              : -1}             {selected}            >
function create_default_slot(ctx) {
	let t_value = /*day*/ ctx[44].getDate() + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*page*/ 2048 && t_value !== (t_value = /*day*/ ctx[44].getDate() + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(489:11) <CalendarViewItem             on:click={() => selectDay(day)}             on:keydown={e => handleKeyDown(e, day)}             outOfRange={!inMonth}             current={compareDates(day, new Date(), \\\"day\\\")}             disabled={min > day || max < day}             blackout={blackout &&              indexOfDate(blackout, day, \\\"day\\\") > -1}             header={page &&              headers &&              day.getDate() === 1 &&              getMonthLocale(day.getMonth(), {               locale,               format: \\\"short\\\"              })}             tabindex={firstFocusableDay &&             compareDates(firstFocusableDay, day, \\\"day\\\")              ? 0              : -1}             {selected}            >",
		ctx
	});

	return block;
}

// (472:9) {#each getCalendarDays(page).slice(week * 7, week * 7 + 7) as day, i}
function create_each_block_1(ctx) {
	let td;
	let calendarviewitem;
	let current;

	function click_handler_3() {
		return /*click_handler_3*/ ctx[31](/*day*/ ctx[44]);
	}

	function keydown_handler(...args) {
		return /*keydown_handler*/ ctx[32](/*day*/ ctx[44], ...args);
	}

	calendarviewitem = new CalendarViewItem({
			props: {
				outOfRange: !/*inMonth*/ ctx[46],
				current: compareDates(/*day*/ ctx[44], new Date(), "day"),
				disabled: /*min*/ ctx[6] > /*day*/ ctx[44] || /*max*/ ctx[7] < /*day*/ ctx[44],
				blackout: /*blackout*/ ctx[5] && indexOfDate(/*blackout*/ ctx[5], /*day*/ ctx[44], "day") > -1,
				header: /*page*/ ctx[11] && /*headers*/ ctx[4] && /*day*/ ctx[44].getDate() === 1 && getMonthLocale(/*day*/ ctx[44].getMonth(), {
					locale: /*locale*/ ctx[3],
					format: "short"
				}),
				tabindex: /*firstFocusableDay*/ ctx[47] && compareDates(/*firstFocusableDay*/ ctx[47], /*day*/ ctx[44], "day")
				? 0
				: -1,
				selected: /*selected*/ ctx[45],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	calendarviewitem.$on("click", click_handler_3);
	calendarviewitem.$on("keydown", keydown_handler);

	const block = {
		c: function create() {
			td = element_1("td");
			create_component(calendarviewitem.$$.fragment);
			attr_dev(td, "role", "gridcell");
			attr_dev(td, "class", "svelte-2np5h6");
			add_location(td, file, 487, 10, 18220);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			mount_component(calendarviewitem, td, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const calendarviewitem_changes = {};
			if (dirty[0] & /*page*/ 2048) calendarviewitem_changes.outOfRange = !/*inMonth*/ ctx[46];
			if (dirty[0] & /*page*/ 2048) calendarviewitem_changes.current = compareDates(/*day*/ ctx[44], new Date(), "day");
			if (dirty[0] & /*min, page, max*/ 2240) calendarviewitem_changes.disabled = /*min*/ ctx[6] > /*day*/ ctx[44] || /*max*/ ctx[7] < /*day*/ ctx[44];
			if (dirty[0] & /*blackout, page*/ 2080) calendarviewitem_changes.blackout = /*blackout*/ ctx[5] && indexOfDate(/*blackout*/ ctx[5], /*day*/ ctx[44], "day") > -1;

			if (dirty[0] & /*page, headers, locale*/ 2072) calendarviewitem_changes.header = /*page*/ ctx[11] && /*headers*/ ctx[4] && /*day*/ ctx[44].getDate() === 1 && getMonthLocale(/*day*/ ctx[44].getMonth(), {
				locale: /*locale*/ ctx[3],
				format: "short"
			});

			if (dirty[0] & /*page, blackout, min, max*/ 2272) calendarviewitem_changes.tabindex = /*firstFocusableDay*/ ctx[47] && compareDates(/*firstFocusableDay*/ ctx[47], /*day*/ ctx[44], "day")
			? 0
			: -1;

			if (dirty[0] & /*value, page*/ 2049) calendarviewitem_changes.selected = /*selected*/ ctx[45];

			if (dirty[0] & /*page*/ 2048 | dirty[1] & /*$$scope*/ 1073741824) {
				calendarviewitem_changes.$$scope = { dirty, ctx };
			}

			calendarviewitem.$set(calendarviewitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(calendarviewitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(calendarviewitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			destroy_component(calendarviewitem);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(472:9) {#each getCalendarDays(page).slice(week * 7, week * 7 + 7) as day, i}",
		ctx
	});

	return block;
}

// (470:7) {#each Array(6) as _, week}
function create_each_block(ctx) {
	let tr;
	let t;
	let current;
	let each_value_1 = /*getCalendarDays*/ ctx[19](/*page*/ ctx[11]).slice(/*week*/ ctx[43] * 7, /*week*/ ctx[43] * 7 + 7);
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			tr = element_1("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr_dev(tr, "class", "svelte-2np5h6");
			add_location(tr, file, 470, 8, 17586);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tr, null);
			}

			append_dev(tr, t);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*getCalendarDays, page, min, max, blackout, headers, locale, value, selectDay, handleKeyDown*/ 13109497) {
				each_value_1 = /*getCalendarDays*/ ctx[19](/*page*/ ctx[11]).slice(/*week*/ ctx[43] * 7, /*week*/ ctx[43] * 7 + 7);
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(tr, t);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(470:7) {#each Array(6) as _, week}",
		ctx
	});

	return block;
}

// (443:4) {#key page}
function create_key_block_1(ctx) {
	let tbody;
	let current_block_type_index;
	let if_block;
	let bodyElementBinding_action;
	let tbody_intro;
	let tbody_outro;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*view*/ ctx[1] === "days") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			tbody = element_1("tbody");
			if_block.c();
			attr_dev(tbody, "class", "svelte-2np5h6");
			add_location(tbody, file, 443, 5, 16965);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tbody, anchor);
			if_blocks[current_block_type_index].m(tbody, null);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(bodyElementBinding_action = /*bodyElementBinding*/ ctx[18].call(null, tbody));
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(tbody, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			add_render_callback(() => {
				if (tbody_outro) tbody_outro.end(1);

				tbody_intro = create_in_transition(tbody, fly, {
					opacity: 1,
					duration: /*pageAnimationDuration*/ ctx[15],
					easing: circOut,
					y: /*pageAnimationDirection*/ ctx[14] === "neutral"
					? 0
					: /*pageAnimationDirection*/ ctx[14] === "up" ? -198 : 198
				});

				tbody_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			if (tbody_intro) tbody_intro.invalidate();

			if (local) {
				tbody_outro = create_out_transition(tbody, fly, {
					opacity: 1,
					duration: /*pageAnimationDuration*/ ctx[15],
					easing: circOut,
					y: /*pageAnimationDirection*/ ctx[14] === "neutral"
					? 0
					: /*pageAnimationDirection*/ ctx[14] === "up" ? 198 : -198
				});
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tbody);
			if_blocks[current_block_type_index].d();
			if (detaching && tbody_outro) tbody_outro.end();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_key_block_1.name,
		type: "key",
		source: "(443:4) {#key page}",
		ctx
	});

	return block;
}

// (406:2) {#key view}
function create_key_block(ctx) {
	let table;
	let t;
	let previous_key = /*page*/ ctx[11];
	let table_class_value;
	let table_intro;
	let table_outro;
	let current;
	let if_block = /*view*/ ctx[1] === "days" && create_if_block_3(ctx);
	let key_block = create_key_block_1(ctx);

	const block = {
		c: function create() {
			table = element_1("table");
			if (if_block) if_block.c();
			t = space();
			key_block.c();
			attr_dev(table, "class", table_class_value = "calendar-view-table view-" + /*view*/ ctx[1] + " svelte-2np5h6");
			attr_dev(table, "role", "grid");
			add_location(table, file, 406, 3, 16034);
		},
		m: function mount(target, anchor) {
			insert_dev(target, table, anchor);
			if (if_block) if_block.m(table, null);
			append_dev(table, t);
			key_block.m(table, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*view*/ ctx[1] === "days") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3(ctx);
					if_block.c();
					if_block.m(table, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*page*/ 2048 && safe_not_equal(previous_key, previous_key = /*page*/ ctx[11])) {
				group_outros();
				transition_out(key_block, 1, 1, noop);
				check_outros();
				key_block = create_key_block_1(ctx);
				key_block.c();
				transition_in(key_block, 1);
				key_block.m(table, null);
			} else {
				key_block.p(ctx, dirty);
			}

			if (!current || dirty[0] & /*view*/ 2 && table_class_value !== (table_class_value = "calendar-view-table view-" + /*view*/ ctx[1] + " svelte-2np5h6")) {
				attr_dev(table, "class", table_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(key_block);

			add_render_callback(() => {
				if (table_outro) table_outro.end(1);

				table_intro = create_in_transition(table, fadeScale, {
					duration: /*viewAnimationDirection*/ ctx[13] !== "neutral"
					? 500
					: 0,
					easing: circOut,
					baseScale: /*viewAnimationDirection*/ ctx[13] === "up"
					? 1.29
					: 0.84,
					delay: /*viewAnimationDirection*/ ctx[13] !== "neutral"
					? 150
					: 0
				});

				table_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(key_block);
			if (table_intro) table_intro.invalidate();

			if (local) {
				table_outro = create_out_transition(table, fadeScale, {
					duration: /*viewAnimationDirection*/ ctx[13] !== "neutral"
					? 150
					: 0,
					easing: circOut,
					baseScale: /*viewAnimationDirection*/ ctx[13] === "up"
					? 0.84
					: 1.29,
					delay: 0
				});
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(table);
			if (if_block) if_block.d();
			key_block.d(detaching);
			if (detaching && table_outro) table_outro.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_key_block.name,
		type: "key",
		source: "(406:2) {#key view}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div3;
	let header_1;
	let div0;
	let button0;
	let t0;
	let button0_disabled_value;
	let t1;
	let div1;
	let button1;
	let svg0;
	let path0;
	let button1_disabled_value;
	let t2;
	let button2;
	let svg1;
	let path1;
	let button2_disabled_value;
	let t3;
	let div2;
	let previous_key = /*view*/ ctx[1];
	let div3_class_value;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	let key_block = create_key_block(ctx);

	let div3_levels = [
		{
			class: div3_class_value = "calendar-view " + /*className*/ ctx[10]
		},
		/*$$restProps*/ ctx[26]
	];

	let div3_data = {};

	for (let i = 0; i < div3_levels.length; i += 1) {
		div3_data = assign(div3_data, div3_levels[i]);
	}

	const block = {
		c: function create() {
			div3 = element_1("div");
			header_1 = element_1("header");
			div0 = element_1("div");
			button0 = element_1("button");
			t0 = text(/*header*/ ctx[12]);
			t1 = space();
			div1 = element_1("div");
			button1 = element_1("button");
			svg0 = svg_element("svg");
			path0 = svg_element("path");
			t2 = space();
			button2 = element_1("button");
			svg1 = svg_element("svg");
			path1 = svg_element("path");
			t3 = space();
			div2 = element_1("div");
			key_block.c();
			button0.disabled = button0_disabled_value = /*view*/ ctx[1] === "years";
			attr_dev(button0, "class", "svelte-2np5h6");
			add_location(button0, file, 382, 3, 14968);
			attr_dev(div0, "class", "calendar-view-header-text svelte-2np5h6");
			attr_dev(div0, "role", "heading");
			attr_dev(div0, "aria-live", "polite");
			add_location(div0, file, 381, 2, 14891);
			attr_dev(path0, "d", "M4.95681 10.998C4.14912 10.998 3.67466 10.09 4.13591 9.42698L6.76854 5.64257C7.36532 4.78469 8.63448 4.7847 9.23126 5.64257L11.8639 9.42698C12.3251 10.09 11.8507 10.998 11.043 10.998H4.95681Z");
			add_location(path0, file, 390, 5, 15327);
			attr_dev(svg0, "width", "16");
			attr_dev(svg0, "height", "16");
			attr_dev(svg0, "viewBox", "0 0 16 16");
			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg0, "class", "svelte-2np5h6");
			add_location(svg0, file, 389, 4, 15238);
			button1.disabled = button1_disabled_value = /*view*/ ctx[1] && /*min*/ ctx[6] >= /*page*/ ctx[11];
			attr_dev(button1, "class", "svelte-2np5h6");
			add_location(button1, file, 388, 3, 15162);
			attr_dev(path1, "d", "M4.95681 5C4.14912 5 3.67466 5.90803 4.13591 6.57107L6.76854 10.3555C7.36532 11.2134 8.63448 11.2133 9.23126 10.3555L11.8639 6.57106C12.3251 5.90803 11.8507 5 11.043 5H4.95681Z");
			add_location(path1, file, 397, 5, 15729);
			attr_dev(svg1, "width", "16");
			attr_dev(svg1, "height", "16");
			attr_dev(svg1, "viewBox", "0 0 16 16");
			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg1, "class", "svelte-2np5h6");
			add_location(svg1, file, 396, 4, 15640);
			button2.disabled = button2_disabled_value = /*max*/ ctx[7] < /*nextPage*/ ctx[16];
			attr_dev(button2, "class", "svelte-2np5h6");
			add_location(button2, file, 395, 3, 15570);
			attr_dev(div1, "class", "calendar-view-pagination-controls svelte-2np5h6");
			add_location(div1, file, 387, 2, 15111);
			attr_dev(header_1, "class", "calendar-view-header svelte-2np5h6");
			add_location(header_1, file, 380, 1, 14851);
			attr_dev(div2, "class", "calendar-view-table-wrapper svelte-2np5h6");
			add_location(div2, file, 404, 1, 15975);
			set_attributes(div3, div3_data);
			toggle_class(div3, "floating", /*__floating*/ ctx[9]);
			toggle_class(div3, "svelte-2np5h6", true);
			add_location(div3, file, 373, 0, 14721);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, header_1);
			append_dev(header_1, div0);
			append_dev(div0, button0);
			append_dev(button0, t0);
			append_dev(header_1, t1);
			append_dev(header_1, div1);
			append_dev(div1, button1);
			append_dev(button1, svg0);
			append_dev(svg0, path0);
			append_dev(div1, t2);
			append_dev(div1, button2);
			append_dev(button2, svg1);
			append_dev(svg1, path1);
			append_dev(div3, t3);
			append_dev(div3, div2);
			key_block.m(div2, null);
			/*div3_binding*/ ctx[37](div3);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button0, "click", /*click_handler*/ ctx[28], false, false, false),
					listen_dev(button1, "click", /*click_handler_1*/ ctx[29], false, false, false),
					listen_dev(button2, "click", /*click_handler_2*/ ctx[30], false, false, false),
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[17].call(null, div3))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*header*/ 4096) set_data_dev(t0, /*header*/ ctx[12]);

			if (!current || dirty[0] & /*view*/ 2 && button0_disabled_value !== (button0_disabled_value = /*view*/ ctx[1] === "years")) {
				prop_dev(button0, "disabled", button0_disabled_value);
			}

			if (!current || dirty[0] & /*view, min, page*/ 2114 && button1_disabled_value !== (button1_disabled_value = /*view*/ ctx[1] && /*min*/ ctx[6] >= /*page*/ ctx[11])) {
				prop_dev(button1, "disabled", button1_disabled_value);
			}

			if (!current || dirty[0] & /*max, nextPage*/ 65664 && button2_disabled_value !== (button2_disabled_value = /*max*/ ctx[7] < /*nextPage*/ ctx[16])) {
				prop_dev(button2, "disabled", button2_disabled_value);
			}

			if (dirty[0] & /*view*/ 2 && safe_not_equal(previous_key, previous_key = /*view*/ ctx[1])) {
				group_outros();
				transition_out(key_block, 1, 1, noop);
				check_outros();
				key_block = create_key_block(ctx);
				key_block.c();
				transition_in(key_block, 1);
				key_block.m(div2, null);
			} else {
				key_block.p(ctx, dirty);
			}

			set_attributes(div3, div3_data = get_spread_update(div3_levels, [
				(!current || dirty[0] & /*className*/ 1024 && div3_class_value !== (div3_class_value = "calendar-view " + /*className*/ ctx[10])) && { class: div3_class_value },
				dirty[0] & /*$$restProps*/ 67108864 && /*$$restProps*/ ctx[26]
			]));

			toggle_class(div3, "floating", /*__floating*/ ctx[9]);
			toggle_class(div3, "svelte-2np5h6", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(key_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(key_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			key_block.d(detaching);
			/*div3_binding*/ ctx[37](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getWeekdayLocale(day, { locale = undefined, format = "long", offset = 0 } = {}) {
	return new Intl.DateTimeFormat(locale, { weekday: format, timeZone: "UTC" }).format(new Date(Date.UTC(2000, 1, day + offset - 1)));
}

function getMonthLocale(month, { locale = undefined, format = "long" } = {}) {
	return new Intl.DateTimeFormat(locale, { month: format }).format(new Date(2000, month));
}

function getMonthLength(year, month) {
	return new Date(year, month + 1, 0).getDate() - 1;
}

function getMonthDays(year, month) {
	const days = [];

	for (let i = 0; i < getMonthLength(year, month) + 1; i++) {
		days.push(new Date(year, month, i + 1));
	}

	return days;
}

function getYearMonths(year) {
	const days = [];

	for (let i = 0; i < 12; i++) {
		days.push(new Date(year, i, 1));
	}

	return days;
}

function compareDates(a, b, precision = "time") {
	switch (precision) {
		case "time":
			return a.getTime() === b.getTime();
		case "day":
			return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
		case "month":
			return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth();
		case "year":
			return a.getFullYear() === b.getFullYear();
		case "decade":
			return Math.floor(a.getFullYear() / 10) * 10 === Math.floor(b.getFullYear() / 10) * 10;
	}
}

function indexOfDate(array, date, precision = "time") {
	return array.findIndex(d => compareDates(d, date, precision));
}

function getCalendarMonths(date) {
	const year = date.getFullYear();
	let months = [];
	return months.concat(getYearMonths(year), getYearMonths(year + 1).slice(0, 4));
}

function getCalendarYears(date) {
	const decadeStart = Math.floor(date.getFullYear() / 10) * 10;
	let years = [];

	for (let i = 0; i < 12; i++) {
		years.push(new Date(decadeStart + i, 0, 1));
	}

	if (decadeStart % 20 === 0) {
		for (let i = 0; i < 2; i++) {
			years.unshift(new Date(decadeStart - (i + 1), 0, 1));
		}

		for (let i = 0; i < 4; i++) {
			years.push(new Date(decadeStart + i + 12, 0, 1));
		}
	} else {
		for (let i = 0; i < 6; i++) {
			years.push(new Date(decadeStart + i + 12, 0, 1));
		}
	}

	return years;
}

function getPageByOffset(offset, page, view) {
	if (view === "days") {
		return new Date(page.getFullYear(), page.getMonth() + offset, 1);
	} else if (view === "months") {
		return new Date(page.getFullYear() + offset, 0, 1);
	} else if (view === "years") {
		return new Date(Math.floor(page.getFullYear() / 10) * 10 + offset * 10, 0, 1);
	}
}

function fadeScale(node, { delay = 0, duration = 0, easing = x => x, baseScale = 0 }) {
	const o = +getComputedStyle(node).opacity;
	const is = 1 - baseScale;

	return {
		delay,
		duration,
		css: t => {
			const eased = easing(t);
			return `opacity: ${eased * o}; transform: scale(${eased * is + baseScale})`;
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let nextPage;

	const omit_props_names = [
		"locale","multiple","headers","value","blackout","min","max","view","weekStart","__floating","class","element"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CalendarView', slots, []);
	let { locale = undefined } = $$props;
	let { multiple = false } = $$props;
	let { headers = false } = $$props;
	let { value = null } = $$props;
	let { blackout = undefined } = $$props;
	let { min = undefined } = $$props;
	let { max = undefined } = $$props;
	let { view = "days" } = $$props;
	let { weekStart = 0 } = $$props;
	let { __floating = false } = $$props;
	let { class: className = "" } = $$props;
	let { element = null } = $$props;
	const dispatch = createEventDispatcher();
	const forwardEvents = createEventForwarder(get_current_component(), ["change"]);
	const bodyElementBinding = node => bodyElement = node; // bind:this breaks with our page transition for some reason
	let header = "";
	let viewAnimationDirection = "neutral";
	let pageAnimationDirection = "neutral";
	let pageAnimationDuration = 0;
	let bodyElement = null;
	let firstValue = Array.isArray(value) ? value[0] : value;

	let page = (!min || firstValue >= min) && (!max || firstValue < max)
	? new Date((firstValue !== null && firstValue !== void 0
			? firstValue
			: new Date()).getFullYear(),
		(firstValue !== null && firstValue !== void 0
			? firstValue
			: new Date()).getMonth(),
		1)
	: firstValue < min
		? new Date(min.getFullYear(), min.getMonth(), 1)
		: new Date(max.getFullYear(), max.getMonth(), 1);

	onMount(() => {
		$$invalidate(15, pageAnimationDuration = getCSSDuration("--fds-control-slow-duration"));
	});

	function getCalendarDays(date) {
		const year = date.getFullYear();
		const month = date.getMonth();
		const firstWeekday = new Date(year, month, 1).getDay();
		const calendarRows = 6;
		let days = [];
		let nextMonth = month + 1;
		let lastMonth = month - 1;
		let nextMonthYear = year;
		let lastMonthYear = year;
		const daysBefore = (firstWeekday - weekStart + 7) % 7;

		if (daysBefore > 0) {
			if (lastMonth === -1) {
				lastMonth = 11;
				lastMonthYear = year - 1;
			}

			days = getMonthDays(lastMonthYear, lastMonth).slice(-daysBefore);
		}

		days = days.concat(getMonthDays(year, month));

		if (nextMonth === 12) {
			nextMonth = 0;
			nextMonthYear = year + 1;
		}

		const daysAfter = 7 * calendarRows - days.length;
		days = days.concat(getMonthDays(nextMonthYear, nextMonth).slice(0, daysAfter));
		return days;
	}

	function updatePage(amount = 0, directionOverride = undefined) {
		$$invalidate(11, page = getPageByOffset(amount, page, view));

		if (directionOverride) {
			$$invalidate(14, pageAnimationDirection = directionOverride);
			return;
		}

		if (amount <= -1) {
			$$invalidate(14, pageAnimationDirection = "up");
		} else if (amount >= 1) {
			$$invalidate(14, pageAnimationDirection = "down");
		} else {
			$$invalidate(14, pageAnimationDirection = "neutral");
		}
	}

	function updateView(newView) {
		if (view === "days" && newView === "months" || view === "months" && newView === "years") {
			$$invalidate(13, viewAnimationDirection = "up");
		} else if (view === "years" && newView === "months" || view === "months" && newView === "days") {
			$$invalidate(13, viewAnimationDirection = "down");
		} else {
			$$invalidate(13, viewAnimationDirection = "neutral");
		}

		$$invalidate(14, pageAnimationDirection = "neutral");
		$$invalidate(1, view = newView);
	}

	async function handleKeyDown(event, date) {
		const { key } = event;

		if (key === "ArrowUp" || key === "ArrowDown" || key === "ArrowLeft" || key === "ArrowRight" || key === "Home" || key === "End") {
			event.preventDefault();
		}

		if (event.ctrlKey && (key === "ArrowUp" || key === "ArrowDown")) {
			if (key === "ArrowUp") {
				updateView(view === "days" ? "months" : "years");
			} else if (key === "ArrowDown") {
				updateView(view === "years" ? "months" : "days");
			}

			return;
		}

		let focusOrder = bodyElement.querySelectorAll("button");
		let focusedDate = date;
		const focusIndex = Array.from(focusOrder).indexOf(document.activeElement);
		if (focusOrder.length === 0) return;

		if (view === "days") {
			let focusIncrementAmount = {
				ArrowUp: -7,
				ArrowDown: 7,
				ArrowLeft: -1,
				ArrowRight: 1
			};

			if (!focusIncrementAmount[key] || event.shiftKey) return;
			focusedDate = new Date(new Date(focusedDate).setDate(focusedDate.getDate() + focusIncrementAmount[key]));
			const nextDateIsBlackout = blackout && indexOfDate(blackout, focusedDate, "day") > -1;

			if (nextDateIsBlackout) {
				focusedDate.setDate(focusedDate.getDate() + focusIncrementAmount[key]);
			}

			const calendarDays = getCalendarDays(focusedDate);
			const newFocusedDate = calendarDays.find(day => compareDates(day, focusedDate, "time"));
			if (min > newFocusedDate || max < newFocusedDate) return;

			if (focusedDate.getMonth() !== page.getMonth()) {
				if (key === "ArrowLeft" || key === "ArrowUp") {
					updatePage(-1, "neutral");
				} else if (key === "ArrowRight" || key === "ArrowDown") {
					updatePage(1, "neutral");
				}

				await tick();
				focusOrder = bodyElement.querySelectorAll("button");
				focusedDate = newFocusedDate;

				focusOrder === null || focusOrder === void 0
				? void 0
				: focusOrder[calendarDays.indexOf(newFocusedDate)].focus();

				return;
			}

			focusOrder === null || focusOrder === void 0
			? void 0
			: focusOrder[focusIndex + focusIncrementAmount[key] * (nextDateIsBlackout ? 2 : 1)].focus();
		} else if (view === "months" || view === "years") {
			let calendar = [];

			const focusIncrementAmount = {
				ArrowUp: -4,
				ArrowDown: 4,
				ArrowLeft: -1,
				ArrowRight: 1
			};

			if (!focusIncrementAmount[key] || event.shiftKey) return;

			if (view === "months") {
				focusedDate = new Date(new Date(focusedDate).setMonth(focusedDate.getMonth() + focusIncrementAmount[key], 1));
			} else {
				focusedDate = new Date(new Date(focusedDate).setFullYear(focusedDate.getFullYear() + focusIncrementAmount[key]));
			}

			calendar = view === "months"
			? getCalendarMonths(focusedDate)
			: getCalendarYears(focusedDate);

			const newFocusedDate = calendar.find(day => compareDates(day, focusedDate, view === "months" ? "month" : "year"));

			const aboveMinimumMonths = (min === null || min === void 0 ? void 0 : min.getMonth()) > newFocusedDate.getMonth() && (min === null || min === void 0
			? void 0
			: min.getFullYear()) === newFocusedDate.getFullYear();

			const aboveMinimumYears = (min === null || min === void 0
			? void 0
			: min.getFullYear()) > newFocusedDate.getFullYear();

			if ((view === "months"
			? aboveMinimumMonths
			: aboveMinimumYears) || max < newFocusedDate) return;

			if (!compareDates(focusedDate, page, view === "months" ? "year" : "decade")) {
				if (key === "ArrowLeft" || key === "ArrowUp") {
					updatePage(-1, "neutral");
				} else if (key === "ArrowRight" || key === "ArrowDown") {
					updatePage(1, "neutral");
				}

				await tick();
				focusedDate = newFocusedDate;
				focusOrder = bodyElement.querySelectorAll("button");

				focusOrder === null || focusOrder === void 0
				? void 0
				: focusOrder[calendar.indexOf(newFocusedDate)].focus();

				return;
			}

			focusOrder === null || focusOrder === void 0
			? void 0
			: focusOrder[focusIndex + focusIncrementAmount[key]].focus();
		}
	}

	function selectDay(day) {
		if (multiple) {
			if (!Array.isArray(value)) {
				if (value !== null) {
					$$invalidate(0, value = [value]);
				} else {
					$$invalidate(0, value = [day]);
					return;
				}
			}

			if (indexOfDate(value, day) === -1) {
				value.push(day);
				$$invalidate(0, value);
			} else {
				$$invalidate(0, value = value.slice(0, indexOfDate(value, day)).concat(value.slice(indexOfDate(value, day) + 1)));
			}
		} else {
			if (Array.isArray(value)) $$invalidate(0, value = null);

			if (day.getTime() === (value === null || value === void 0
			? void 0
			: value.getTime())) {
				$$invalidate(0, value = null);
			} else {
				$$invalidate(0, value = day);
			}
		}

		dispatch("change", value);
	}

	function selectMonth(month) {
		$$invalidate(11, page = new Date(new Date(month.setDate(1))));
		updateView("days");
	}

	function selectYear(month) {
		page.setFullYear(month.getFullYear());
		updateView("months");
	}

	const click_handler = () => updateView(view === "days" ? "months" : "years");
	const click_handler_1 = () => updatePage(-1);
	const click_handler_2 = () => updatePage(1);
	const click_handler_3 = day => selectDay(day);
	const keydown_handler = (day, e) => handleKeyDown(e, day);
	const click_handler_4 = month => selectMonth(month);
	const keydown_handler_1 = (month, e) => handleKeyDown(e, month);
	const click_handler_5 = year => selectYear(year);
	const keydown_handler_2 = (year, e) => handleKeyDown(e, year);

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(2, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('locale' in $$new_props) $$invalidate(3, locale = $$new_props.locale);
		if ('multiple' in $$new_props) $$invalidate(27, multiple = $$new_props.multiple);
		if ('headers' in $$new_props) $$invalidate(4, headers = $$new_props.headers);
		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ('blackout' in $$new_props) $$invalidate(5, blackout = $$new_props.blackout);
		if ('min' in $$new_props) $$invalidate(6, min = $$new_props.min);
		if ('max' in $$new_props) $$invalidate(7, max = $$new_props.max);
		if ('view' in $$new_props) $$invalidate(1, view = $$new_props.view);
		if ('weekStart' in $$new_props) $$invalidate(8, weekStart = $$new_props.weekStart);
		if ('__floating' in $$new_props) $$invalidate(9, __floating = $$new_props.__floating);
		if ('class' in $$new_props) $$invalidate(10, className = $$new_props.class);
		if ('element' in $$new_props) $$invalidate(2, element = $$new_props.element);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		tick,
		fly,
		circOut,
		get_current_component,
		createEventForwarder,
		getCSSDuration,
		CalendarViewItem,
		locale,
		multiple,
		headers,
		value,
		blackout,
		min,
		max,
		view,
		weekStart,
		__floating,
		className,
		element,
		dispatch,
		forwardEvents,
		bodyElementBinding,
		header,
		viewAnimationDirection,
		pageAnimationDirection,
		pageAnimationDuration,
		bodyElement,
		firstValue,
		page,
		getWeekdayLocale,
		getMonthLocale,
		getMonthLength,
		getMonthDays,
		getYearMonths,
		compareDates,
		indexOfDate,
		getCalendarDays,
		getCalendarMonths,
		getCalendarYears,
		getPageByOffset,
		updatePage,
		updateView,
		handleKeyDown,
		selectDay,
		selectMonth,
		selectYear,
		fadeScale,
		nextPage
	});

	$$self.$inject_state = $$new_props => {
		if ('locale' in $$props) $$invalidate(3, locale = $$new_props.locale);
		if ('multiple' in $$props) $$invalidate(27, multiple = $$new_props.multiple);
		if ('headers' in $$props) $$invalidate(4, headers = $$new_props.headers);
		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
		if ('blackout' in $$props) $$invalidate(5, blackout = $$new_props.blackout);
		if ('min' in $$props) $$invalidate(6, min = $$new_props.min);
		if ('max' in $$props) $$invalidate(7, max = $$new_props.max);
		if ('view' in $$props) $$invalidate(1, view = $$new_props.view);
		if ('weekStart' in $$props) $$invalidate(8, weekStart = $$new_props.weekStart);
		if ('__floating' in $$props) $$invalidate(9, __floating = $$new_props.__floating);
		if ('className' in $$props) $$invalidate(10, className = $$new_props.className);
		if ('element' in $$props) $$invalidate(2, element = $$new_props.element);
		if ('header' in $$props) $$invalidate(12, header = $$new_props.header);
		if ('viewAnimationDirection' in $$props) $$invalidate(13, viewAnimationDirection = $$new_props.viewAnimationDirection);
		if ('pageAnimationDirection' in $$props) $$invalidate(14, pageAnimationDirection = $$new_props.pageAnimationDirection);
		if ('pageAnimationDuration' in $$props) $$invalidate(15, pageAnimationDuration = $$new_props.pageAnimationDuration);
		if ('bodyElement' in $$props) bodyElement = $$new_props.bodyElement;
		if ('firstValue' in $$props) firstValue = $$new_props.firstValue;
		if ('page' in $$props) $$invalidate(11, page = $$new_props.page);
		if ('nextPage' in $$props) $$invalidate(16, nextPage = $$new_props.nextPage);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value*/ 1) {
			$: firstValue = Array.isArray(value) ? value[0] : value;
		}

		if ($$self.$$.dirty[0] & /*view*/ 2) {
			$: (view, updatePage(0));
		}

		if ($$self.$$.dirty[0] & /*page, view*/ 2050) {
			$: $$invalidate(16, nextPage = getPageByOffset(1, page, view));
		}

		if ($$self.$$.dirty[0] & /*view, locale, page*/ 2058) {
			$: if (view === "days") {
				$$invalidate(12, header = new Intl.DateTimeFormat(locale, { year: "numeric", month: "long" }).format(page));
			} else if (view === "months") {
				$$invalidate(12, header = new Intl.DateTimeFormat(locale, { year: "numeric" }).format(page));
			} else if (view === "years") {
				const decadeStart = Math.floor(page.getFullYear() / 10) * 10;
				const decadeEnd = decadeStart + 9;

				// https://github.com/microsoft/TypeScript/issues/46905
				$$invalidate(12, header = new Intl.DateTimeFormat(locale, { year: "numeric" }).formatRange(new Date(decadeStart, 0, 1), new Date(decadeEnd, 0, 1)));
			}
		}
	};

	return [
		value,
		view,
		element,
		locale,
		headers,
		blackout,
		min,
		max,
		weekStart,
		__floating,
		className,
		page,
		header,
		viewAnimationDirection,
		pageAnimationDirection,
		pageAnimationDuration,
		nextPage,
		forwardEvents,
		bodyElementBinding,
		getCalendarDays,
		updatePage,
		updateView,
		handleKeyDown,
		selectDay,
		selectMonth,
		selectYear,
		$$restProps,
		multiple,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		keydown_handler,
		click_handler_4,
		keydown_handler_1,
		click_handler_5,
		keydown_handler_2,
		div3_binding
	];
}

class CalendarView extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				locale: 3,
				multiple: 27,
				headers: 4,
				value: 0,
				blackout: 5,
				min: 6,
				max: 7,
				view: 1,
				weekStart: 8,
				__floating: 9,
				class: 10,
				element: 2
			},
			add_css,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CalendarView",
			options,
			id: create_fragment.name
		});
	}

	get locale() {
		throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set locale(value) {
		throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiple() {
		throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiple(value) {
		throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get headers() {
		throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set headers(value) {
		throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get blackout() {
		throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set blackout(value) {
		throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get view() {
		throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set view(value) {
		throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get weekStart() {
		throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set weekStart(value) {
		throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get __floating() {
		throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set __floating(value) {
		throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get element() {
		throw new Error("<CalendarView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set element(value) {
		throw new Error("<CalendarView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default CalendarView;