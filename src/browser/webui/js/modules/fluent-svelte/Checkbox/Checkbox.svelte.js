/* Checkbox.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	action_destroyer,
	add_location,
	add_render_callback,
	append_dev,
	append_styles,
	assign,
	attr_dev,
	binding_callbacks,
	check_outros,
	compute_rest_props,
	compute_slots,
	create_slot,
	detach_dev,
	dispatch_dev,
	element,
	exclude_internal_props,
	get_all_dirty_from_scope,
	get_slot_changes,
	get_spread_update,
	group_outros,
	init,
	insert_dev,
	listen_dev,
	run_all,
	safe_not_equal,
	set_attributes,
	space,
	svg_element,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base,
	validate_slots
} from "nereid://.svelte/internal/index.mjs";

import { get_current_component } from "nereid://.svelte/internal/index.mjs";
import { createEventForwarder } from "../internal.js";
const file = "Checkbox.svelte";

function add_css(target) {
	append_styles(target, "svelte-4ss5hf", ".checkbox.svelte-4ss5hf.svelte-4ss5hf{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-clip:padding-box;background-color:var(--fds-control-alt-fill-secondary);block-size:20px;border:1px solid var(--fds-control-strong-stroke-default);border-radius:var(--fds-control-corner-radius);font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;inline-size:20px;line-height:20px;margin:0;outline:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.checkbox.svelte-4ss5hf.svelte-4ss5hf:focus-visible{box-shadow:var(--fds-focus-stroke)}.checkbox.svelte-4ss5hf.svelte-4ss5hf:hover{background-color:var(--fds-control-alt-fill-tertiary)}.checkbox.svelte-4ss5hf.svelte-4ss5hf:active{background-color:var(--fds-control-alt-fill-quarternary);border-color:var(--fds-control-strong-stroke-disabled)}.checkbox.svelte-4ss5hf:active+.checkbox-glyph.svelte-4ss5hf{color:var(--fds-text-on-accent-secondary)}.checkbox.svelte-4ss5hf.svelte-4ss5hf:disabled{background-color:var(--fds-control-alt-fill-disabled);border-color:var(--fds-control-strong-stroke-disabled);pointer-events:none}.checkbox.svelte-4ss5hf.svelte-4ss5hf:checked,.checkbox.svelte-4ss5hf.svelte-4ss5hf:indeterminate{background-color:var(--fds-accent-default);border:none}.checkbox.svelte-4ss5hf.svelte-4ss5hf:checked:hover,.checkbox.svelte-4ss5hf.svelte-4ss5hf:indeterminate:hover{background-color:var(--fds-accent-secondary)}.checkbox.svelte-4ss5hf.svelte-4ss5hf:checked:active,.checkbox.svelte-4ss5hf.svelte-4ss5hf:indeterminate:active{background-color:var(--fds-accent-tertiary)}.checkbox.svelte-4ss5hf.svelte-4ss5hf:checked:disabled,.checkbox.svelte-4ss5hf.svelte-4ss5hf:indeterminate:disabled{background-color:var(--fds-accent-disabled);border-color:var(--fds-control-strong-stroke-disabled)}.checkbox.svelte-4ss5hf:checked:disabled+.checkbox-glyph.svelte-4ss5hf,.checkbox.svelte-4ss5hf:indeterminate:disabled+.checkbox-glyph.svelte-4ss5hf{color:var(--fds-text-on-accent-disabled)}.checkbox:checked+.checkbox-glyph.svelte-4ss5hf .path-checkmark.svelte-4ss5hf,.checkbox:indeterminate+.checkbox-glyph.svelte-4ss5hf .path-checkmark.svelte-4ss5hf{stroke-dashoffset:0;transition:var(--fds-control-normal-duration) cubic-bezier(.55,0,0,1) stroke-dashoffset}.checkbox-container.svelte-4ss5hf.svelte-4ss5hf{align-items:center;color:var(--fds-text-primary);display:inline-flex;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;min-block-size:32px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.checkbox-container.svelte-4ss5hf>span.svelte-4ss5hf{-webkit-padding-start:8px;padding-inline-start:8px}.checkbox-container.disabled.svelte-4ss5hf>span.svelte-4ss5hf{color:var(--fds-text-disabled)}.checkbox-inner.svelte-4ss5hf.svelte-4ss5hf{align-items:center;display:flex;justify-content:center;position:relative}.checkbox-glyph.svelte-4ss5hf.svelte-4ss5hf{block-size:12px;color:inherit;color:var(--fds-text-on-accent-primary);inline-size:12px;position:absolute}.checkbox-glyph.svelte-4ss5hf path.svelte-4ss5hf{transform-origin:center}.checkbox-glyph.svelte-4ss5hf .path-checkmark.svelte-4ss5hf{stroke:currentColor;stroke-width:2;stroke-linecap:round;stroke-linejoin:round;stroke-dasharray:20.5;stroke-dashoffset:20.5;transform:scale(1.2)}.checkbox-glyph.svelte-4ss5hf .path-indeterminate.svelte-4ss5hf{fill:currentColor;transform:scale(.6666666667) translateX(80px) translateY(240px)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hlY2tib3guc3ZlbHRlIiwic291cmNlcyI6WyJDaGVja2JveC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCA+aW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSBcInN2ZWx0ZS9pbnRlcm5hbFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVFdmVudEZvcndhcmRlciB9IGZyb20gXCIuLi9pbnRlcm5hbFwiO1xyXG4vKiogQ29udHJvbHMgd2hldGhlciB0aGUgY2hlY2tib3ggaXMgY2hlY2tlZCBvciBub3QuICovXHJcbmV4cG9ydCBsZXQgY2hlY2tlZCA9IGZhbHNlO1xyXG4vKiogQ29udHJvbHMgd2hldGhlciB0aGUgY2hlY2tib3ggaXMgaW4gYW4gaW5kZXRlcm1pbmF0ZSBzdGF0ZS4gKi9cclxuZXhwb3J0IGxldCBpbmRldGVybWluYXRlID0gZmFsc2U7XHJcbi8qKiBTZXRzIHRoZSBpbnB1dCBlbGVtZW50J3MgbmF0aXZlIGB2YWx1ZWAgYXR0cmlidXRlIGZvciB1c2FnZSBpbiBmb3Jtcy4gKi9cclxuZXhwb3J0IGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcclxuLyoqIENvbnRyb2xzIHdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGludGVuZGVkIGZvciB1c2VyIGludGVyYWN0aW9uLCBhbmQgc3R5bGVzIGl0IGFjY29yZGluZ2x5LiAqL1xyXG5leHBvcnQgbGV0IGRpc2FibGVkID0gZmFsc2U7XHJcbi8qKiBTcGVjaWZpZXMgYSBjdXN0b20gY2xhc3MgbmFtZSBmb3IgdGhlIGNoZWNrYm94LiAqL1xyXG5sZXQgY2xhc3NOYW1lID0gXCJcIjtcclxuZXhwb3J0IHsgY2xhc3NOYW1lIGFzIGNsYXNzIH07XHJcbi8qKiBPYnRhaW5zIGEgYm91bmQgRE9NIHJlZmVyZW5jZSB0byB0aGUgY2hlY2tib3gncyA8aW5wdXQgLz4gZWxlbWVudC4gKi9cclxuZXhwb3J0IGxldCBpbnB1dEVsZW1lbnQgPSBudWxsO1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIGNoZWNrYm94J3Mgb3V0ZXIgY29udGFpbmVyIGVsZW1lbnQuICovXHJcbmV4cG9ydCBsZXQgY29udGFpbmVyRWxlbWVudCA9IG51bGw7XHJcbmNvbnN0IGZvcndhcmRFdmVudHMgPSBjcmVhdGVFdmVudEZvcndhcmRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XHJcbjwvc2NyaXB0PlxuXG48IS0tXG5AY29tcG9uZW50XG5DaGVja2JveGVzIHJlcHJlc2VudCBhIGNvbnRyb2wgdGhhdCBhIHVzZXIgY2FuIHNlbGVjdCAoY2hlY2spIG9yIGNsZWFyICh1bmNoZWNrKS4gQSBDaGVja2JveCBjYW4gYWxzbyByZXBvcnQgaXRzIHZhbHVlIGFzIGluZGV0ZXJtaW5hdGUuIFtEb2NzXShodHRwczovL2ZsdWVudC1zdmVsdGUudmVyY2VsLmFwcC9kb2NzL2NvbXBvbmVudHMvY2hlY2tib3gpXG4tIFVzYWdlOlxuICAgIGBgYHRzeFxuICAgIDxDaGVja2JveCBiaW5kOmNoZWNrZWQgLz5cbiAgICBgYGBcbi0tPlxuPCEtLSBzdmVsdGUtaWdub3JlIGExMXktbGFiZWwtaGFzLWFzc29jaWF0ZWQtY29udHJvbCAtLT5cbjwhLS0gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzUzMjMgLS0+XG48bGFiZWwgY2xhc3M9XCJjaGVja2JveC1jb250YWluZXJcIiBjbGFzczpkaXNhYmxlZCBjbGFzczppbmRldGVybWluYXRlIGJpbmQ6dGhpcz17Y29udGFpbmVyRWxlbWVudH0+XG5cdDxkaXYgY2xhc3M9XCJjaGVja2JveC1pbm5lclwiPlxuXHRcdDxpbnB1dFxuXHRcdFx0dXNlOmZvcndhcmRFdmVudHNcblx0XHRcdGJpbmQ6Y2hlY2tlZFxuXHRcdFx0YmluZDppbmRldGVybWluYXRlXG5cdFx0XHRiaW5kOnRoaXM9e2lucHV0RWxlbWVudH1cblx0XHRcdHR5cGU9XCJjaGVja2JveFwiXG5cdFx0XHRjbGFzcz1cImNoZWNrYm94IHtjbGFzc05hbWV9XCJcblx0XHRcdHt2YWx1ZX1cblx0XHRcdHtkaXNhYmxlZH1cblx0XHRcdHsuLi4kJHJlc3RQcm9wc31cblx0XHQvPlxuXHRcdDxzdmdcblx0XHRcdGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG5cdFx0XHRjbGFzcz1cImNoZWNrYm94LWdseXBoXCJcblx0XHRcdHZpZXdCb3g9e2luZGV0ZXJtaW5hdGUgPyBcIjE3MSA0NzAgNjgzIDg1XCIgOiBcIjAgMCAyNCAyNFwifVxuXHRcdD5cblx0XHRcdHsjaWYgaW5kZXRlcm1pbmF0ZX1cblx0XHRcdFx0PHBhdGhcblx0XHRcdFx0XHRjbGFzcz1cInBhdGgtaW5kZXRlcm1pbmF0ZVwiXG5cdFx0XHRcdFx0ZD1cIk0yMTMuNSw1NTQuNUMyMDcuNSw1NTQuNSAyMDEuOTE3LDU1My40MTcgMTk2Ljc1LDU1MS4yNUMxOTEuNTgzLDU0OS4wODMgMTg3LjA4Myw1NDYuMDgzIDE4My4yNSw1NDIuMjVDMTc5LjQxNyw1MzguNDE3IDE3Ni4zMzMsNTMzLjkxNyAxNzQsNTI4Ljc1QzE3MS42NjcsNTIzLjU4MyAxNzAuNSw1MTggMTcwLjUsNTEyQzE3MC41LDUwNiAxNzEuNjY3LDUwMC40MTcgMTc0LDQ5NS4yNUMxNzYuMzMzLDQ5MC4wODMgMTc5LjQxNyw0ODUuNTgzIDE4My4yNSw0ODEuNzVDMTg3LjA4Myw0NzcuOTE3IDE5MS41ODMsNDc0LjkxNyAxOTYuNzUsNDcyLjc1QzIwMS45MTcsNDcwLjU4MyAyMDcuNSw0NjkuNSAyMTMuNSw0NjkuNUw4MTAuNSw0NjkuNUM4MTYuNSw0NjkuNSA4MjIuMDgzLDQ3MC41ODMgODI3LjI1LDQ3Mi43NUM4MzIuNDE3LDQ3NC45MTcgODM2LjkxNyw0NzcuOTE3IDg0MC43NSw0ODEuNzVDODQ0LjU4Myw0ODUuNTgzIDg0Ny42NjcsNDkwLjA4MyA4NTAsNDk1LjI1Qzg1Mi4zMzMsNTAwLjQxNyA4NTMuNSw1MDYgODUzLjUsNTEyQzg1My41LDUxOCA4NTIuMzMzLDUyMy41ODMgODUwLDUyOC43NUM4NDcuNjY3LDUzMy45MTcgODQ0LjU4Myw1MzguNDE3IDg0MC43NSw1NDIuMjVDODM2LjkxNyw1NDYuMDgzIDgzMi40MTcsNTQ5LjA4MyA4MjcuMjUsNTUxLjI1QzgyMi4wODMsNTUzLjQxNyA4MTYuNSw1NTQuNSA4MTAuNSw1NTQuNVpcIlxuXHRcdFx0XHQvPlxuXHRcdFx0ezplbHNlfVxuXHRcdFx0XHQ8cGF0aFxuXHRcdFx0XHRcdGNsYXNzPVwicGF0aC1jaGVja21hcmtcIlxuXHRcdFx0XHRcdGQ9XCJNIDQuNTMwMyAxMi45Njk3IEwgOC41IDE2LjkzOTMgTCAxOC45Njk3IDYuNDY5N1wiXG5cdFx0XHRcdFx0ZmlsbD1cIm5vbmVcIlxuXHRcdFx0XHQvPlxuXHRcdFx0ey9pZn1cblx0XHQ8L3N2Zz5cblx0PC9kaXY+XG5cdHsjaWYgJCRzbG90cy5kZWZhdWx0fVxuXHRcdDxzcGFuPlxuXHRcdFx0PHNsb3QgLz5cblx0XHQ8L3NwYW4+XG5cdHsvaWZ9XG48L2xhYmVsPlxuXG48c3R5bGUgPi5jaGVja2JveHstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTstbW96LWFwcGVhcmFuY2U6bm9uZTthcHBlYXJhbmNlOm5vbmU7YmFja2dyb3VuZC1jbGlwOnBhZGRpbmctYm94O2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLWNvbnRyb2wtYWx0LWZpbGwtc2Vjb25kYXJ5KTtibG9jay1zaXplOjIwcHg7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mZHMtY29udHJvbC1zdHJvbmctc3Ryb2tlLWRlZmF1bHQpO2JvcmRlci1yYWRpdXM6dmFyKC0tZmRzLWNvbnRyb2wtY29ybmVyLXJhZGl1cyk7Zm9udC1mYW1pbHk6dmFyKC0tZmRzLWZvbnQtZmFtaWx5LXRleHQpO2ZvbnQtc2l6ZTp2YXIoLS1mZHMtYm9keS1mb250LXNpemUpO2ZvbnQtd2VpZ2h0OjQwMDtpbmxpbmUtc2l6ZToyMHB4O2xpbmUtaGVpZ2h0OjIwcHg7bWFyZ2luOjA7b3V0bGluZTpub25lOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uY2hlY2tib3g6Zm9jdXMtdmlzaWJsZXtib3gtc2hhZG93OnZhcigtLWZkcy1mb2N1cy1zdHJva2UpfS5jaGVja2JveDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZkcy1jb250cm9sLWFsdC1maWxsLXRlcnRpYXJ5KX0uY2hlY2tib3g6YWN0aXZle2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLWNvbnRyb2wtYWx0LWZpbGwtcXVhcnRlcm5hcnkpO2JvcmRlci1jb2xvcjp2YXIoLS1mZHMtY29udHJvbC1zdHJvbmctc3Ryb2tlLWRpc2FibGVkKX0uY2hlY2tib3g6YWN0aXZlKy5jaGVja2JveC1nbHlwaHtjb2xvcjp2YXIoLS1mZHMtdGV4dC1vbi1hY2NlbnQtc2Vjb25kYXJ5KX0uY2hlY2tib3g6ZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtY29udHJvbC1hbHQtZmlsbC1kaXNhYmxlZCk7Ym9yZGVyLWNvbG9yOnZhcigtLWZkcy1jb250cm9sLXN0cm9uZy1zdHJva2UtZGlzYWJsZWQpO3BvaW50ZXItZXZlbnRzOm5vbmV9LmNoZWNrYm94OmNoZWNrZWQsLmNoZWNrYm94OmluZGV0ZXJtaW5hdGV7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtYWNjZW50LWRlZmF1bHQpO2JvcmRlcjpub25lfS5jaGVja2JveDpjaGVja2VkOmhvdmVyLC5jaGVja2JveDppbmRldGVybWluYXRlOmhvdmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLWFjY2VudC1zZWNvbmRhcnkpfS5jaGVja2JveDpjaGVja2VkOmFjdGl2ZSwuY2hlY2tib3g6aW5kZXRlcm1pbmF0ZTphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtYWNjZW50LXRlcnRpYXJ5KX0uY2hlY2tib3g6Y2hlY2tlZDpkaXNhYmxlZCwuY2hlY2tib3g6aW5kZXRlcm1pbmF0ZTpkaXNhYmxlZHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZkcy1hY2NlbnQtZGlzYWJsZWQpO2JvcmRlci1jb2xvcjp2YXIoLS1mZHMtY29udHJvbC1zdHJvbmctc3Ryb2tlLWRpc2FibGVkKX0uY2hlY2tib3g6Y2hlY2tlZDpkaXNhYmxlZCsuY2hlY2tib3gtZ2x5cGgsLmNoZWNrYm94OmluZGV0ZXJtaW5hdGU6ZGlzYWJsZWQrLmNoZWNrYm94LWdseXBoe2NvbG9yOnZhcigtLWZkcy10ZXh0LW9uLWFjY2VudC1kaXNhYmxlZCl9LmNoZWNrYm94OmNoZWNrZWQrLmNoZWNrYm94LWdseXBoIC5wYXRoLWNoZWNrbWFyaywuY2hlY2tib3g6aW5kZXRlcm1pbmF0ZSsuY2hlY2tib3gtZ2x5cGggLnBhdGgtY2hlY2ttYXJre3N0cm9rZS1kYXNob2Zmc2V0OjA7dHJhbnNpdGlvbjp2YXIoLS1mZHMtY29udHJvbC1ub3JtYWwtZHVyYXRpb24pIGN1YmljLWJlemllciguNTUsMCwwLDEpIHN0cm9rZS1kYXNob2Zmc2V0fS5jaGVja2JveC1jb250YWluZXJ7YWxpZ24taXRlbXM6Y2VudGVyO2NvbG9yOnZhcigtLWZkcy10ZXh0LXByaW1hcnkpO2Rpc3BsYXk6aW5saW5lLWZsZXg7Zm9udC1mYW1pbHk6dmFyKC0tZmRzLWZvbnQtZmFtaWx5LXRleHQpO2ZvbnQtc2l6ZTp2YXIoLS1mZHMtYm9keS1mb250LXNpemUpO2ZvbnQtd2VpZ2h0OjQwMDtsaW5lLWhlaWdodDoyMHB4O21pbi1ibG9jay1zaXplOjMycHg7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5jaGVja2JveC1jb250YWluZXI+c3Bhbnstd2Via2l0LXBhZGRpbmctc3RhcnQ6OHB4O3BhZGRpbmctaW5saW5lLXN0YXJ0OjhweH0uY2hlY2tib3gtY29udGFpbmVyLmRpc2FibGVkPnNwYW57Y29sb3I6dmFyKC0tZmRzLXRleHQtZGlzYWJsZWQpfS5jaGVja2JveC1pbm5lcnthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7cG9zaXRpb246cmVsYXRpdmV9LmNoZWNrYm94LWdseXBoe2Jsb2NrLXNpemU6MTJweDtjb2xvcjppbmhlcml0O2NvbG9yOnZhcigtLWZkcy10ZXh0LW9uLWFjY2VudC1wcmltYXJ5KTtpbmxpbmUtc2l6ZToxMnB4O3Bvc2l0aW9uOmFic29sdXRlfS5jaGVja2JveC1nbHlwaCBwYXRoe3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyfS5jaGVja2JveC1nbHlwaCAucGF0aC1jaGVja21hcmt7c3Ryb2tlOmN1cnJlbnRDb2xvcjtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLWRhc2hhcnJheToyMC41O3N0cm9rZS1kYXNob2Zmc2V0OjIwLjU7dHJhbnNmb3JtOnNjYWxlKDEuMil9LmNoZWNrYm94LWdseXBoIC5wYXRoLWluZGV0ZXJtaW5hdGV7ZmlsbDpjdXJyZW50Q29sb3I7dHJhbnNmb3JtOnNjYWxlKC42NjY2NjY2NjY3KSB0cmFuc2xhdGVYKDgwcHgpIHRyYW5zbGF0ZVkoMjQwcHgpfTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBcUVRLHFDQUFTLENBQUMsbUJBQW1CLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLFdBQVcsSUFBSSxDQUFDLGdCQUFnQixXQUFXLENBQUMsaUJBQWlCLElBQUksZ0NBQWdDLENBQUMsQ0FBQyxXQUFXLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxtQ0FBbUMsQ0FBQyxDQUFDLGNBQWMsSUFBSSwyQkFBMkIsQ0FBQyxDQUFDLFlBQVksSUFBSSxzQkFBc0IsQ0FBQyxDQUFDLFVBQVUsSUFBSSxvQkFBb0IsQ0FBQyxDQUFDLFlBQVksR0FBRyxDQUFDLFlBQVksSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLG9CQUFvQixJQUFJLENBQUMsaUJBQWlC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 */");
}

// (54:3) {:else}
function create_else_block(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			attr_dev(path, "class", "path-checkmark svelte-4ss5hf");
			attr_dev(path, "d", "M 4.5303 12.9697 L 8.5 16.9393 L 18.9697 6.4697");
			attr_dev(path, "fill", "none");
			add_location(path, file, 54, 4, 2594);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(54:3) {:else}",
		ctx
	});

	return block;
}

// (49:3) {#if indeterminate}
function create_if_block_1(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			attr_dev(path, "class", "path-indeterminate svelte-4ss5hf");
			attr_dev(path, "d", "M213.5,554.5C207.5,554.5 201.917,553.417 196.75,551.25C191.583,549.083 187.083,546.083 183.25,542.25C179.417,538.417 176.333,533.917 174,528.75C171.667,523.583 170.5,518 170.5,512C170.5,506 171.667,500.417 174,495.25C176.333,490.083 179.417,485.583 183.25,481.75C187.083,477.917 191.583,474.917 196.75,472.75C201.917,470.583 207.5,469.5 213.5,469.5L810.5,469.5C816.5,469.5 822.083,470.583 827.25,472.75C832.417,474.917 836.917,477.917 840.75,481.75C844.583,485.583 847.667,490.083 850,495.25C852.333,500.417 853.5,506 853.5,512C853.5,518 852.333,523.583 850,528.75C847.667,533.917 844.583,538.417 840.75,542.25C836.917,546.083 832.417,549.083 827.25,551.25C822.083,553.417 816.5,554.5 810.5,554.5Z");
			add_location(path, file, 49, 4, 1827);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(49:3) {#if indeterminate}",
		ctx
	});

	return block;
}

// (63:1) {#if $$slots.default}
function create_if_block(ctx) {
	let span;
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			attr_dev(span, "class", "svelte-4ss5hf");
			add_location(span, file, 63, 2, 2760);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(63:1) {#if $$slots.default}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let label;
	let div;
	let input;
	let input_class_value;
	let forwardEvents_action;
	let t0;
	let svg;
	let svg_viewBox_value;
	let t1;
	let current;
	let mounted;
	let dispose;

	let input_levels = [
		{ type: "checkbox" },
		{
			class: input_class_value = "checkbox " + /*className*/ ctx[6]
		},
		{ __value: /*value*/ ctx[4] },
		{ disabled: /*disabled*/ ctx[5] },
		/*$$restProps*/ ctx[8]
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	function select_block_type(ctx, dirty) {
		if (/*indeterminate*/ ctx[1]) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*$$slots*/ ctx[9].default && create_if_block(ctx);

	const block = {
		c: function create() {
			label = element("label");
			div = element("div");
			input = element("input");
			t0 = space();
			svg = svg_element("svg");
			if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			set_attributes(input, input_data);
			if (/*checked*/ ctx[0] === void 0 || /*indeterminate*/ ctx[1] === void 0) add_render_callback(() => /*input_change_handler*/ ctx[12].call(input));
			toggle_class(input, "svelte-4ss5hf", true);
			add_location(input, file, 32, 2, 1486);
			attr_dev(svg, "aria-hidden", "true");
			attr_dev(svg, "class", "checkbox-glyph svelte-4ss5hf");

			attr_dev(svg, "viewBox", svg_viewBox_value = /*indeterminate*/ ctx[1]
			? "171 470 683 85"
			: "0 0 24 24");

			add_location(svg, file, 43, 2, 1683);
			attr_dev(div, "class", "checkbox-inner svelte-4ss5hf");
			add_location(div, file, 31, 1, 1455);
			attr_dev(label, "class", "checkbox-container svelte-4ss5hf");
			toggle_class(label, "disabled", /*disabled*/ ctx[5]);
			toggle_class(label, "indeterminate", /*indeterminate*/ ctx[1]);
			add_location(label, file, 30, 0, 1355);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, div);
			append_dev(div, input);
			if (input.autofocus) input.focus();
			input.checked = /*checked*/ ctx[0];
			input.indeterminate = /*indeterminate*/ ctx[1];
			/*input_binding*/ ctx[13](input);
			append_dev(div, t0);
			append_dev(div, svg);
			if_block0.m(svg, null);
			append_dev(label, t1);
			if (if_block1) if_block1.m(label, null);
			/*label_binding*/ ctx[14](label);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[7].call(null, input)),
					listen_dev(input, "change", /*input_change_handler*/ ctx[12])
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				{ type: "checkbox" },
				(!current || dirty & /*className*/ 64 && input_class_value !== (input_class_value = "checkbox " + /*className*/ ctx[6])) && { class: input_class_value },
				(!current || dirty & /*value*/ 16) && { __value: /*value*/ ctx[4] },
				(!current || dirty & /*disabled*/ 32) && { disabled: /*disabled*/ ctx[5] },
				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8]
			]));

			if (dirty & /*checked*/ 1) {
				input.checked = /*checked*/ ctx[0];
			}

			if (dirty & /*indeterminate*/ 2) {
				input.indeterminate = /*indeterminate*/ ctx[1];
			}

			toggle_class(input, "svelte-4ss5hf", true);

			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(svg, null);
				}
			}

			if (!current || dirty & /*indeterminate*/ 2 && svg_viewBox_value !== (svg_viewBox_value = /*indeterminate*/ ctx[1]
			? "171 470 683 85"
			: "0 0 24 24")) {
				attr_dev(svg, "viewBox", svg_viewBox_value);
			}

			if (/*$$slots*/ ctx[9].default) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$$slots*/ 512) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(label, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty & /*disabled*/ 32) {
				toggle_class(label, "disabled", /*disabled*/ ctx[5]);
			}

			if (dirty & /*indeterminate*/ 2) {
				toggle_class(label, "indeterminate", /*indeterminate*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			/*input_binding*/ ctx[13](null);
			if_block0.d();
			if (if_block1) if_block1.d();
			/*label_binding*/ ctx[14](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"checked","indeterminate","value","disabled","class","inputElement","containerElement"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Checkbox', slots, ['default']);
	const $$slots = compute_slots(slots);
	let { checked = false } = $$props;
	let { indeterminate = false } = $$props;
	let { value = undefined } = $$props;
	let { disabled = false } = $$props;
	let { class: className = "" } = $$props;
	let { inputElement = null } = $$props;
	let { containerElement = null } = $$props;
	const forwardEvents = createEventForwarder(get_current_component());

	function input_change_handler() {
		checked = this.checked;
		indeterminate = this.indeterminate;
		$$invalidate(0, checked);
		$$invalidate(1, indeterminate);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputElement = $$value;
			$$invalidate(2, inputElement);
		});
	}

	function label_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			containerElement = $$value;
			$$invalidate(3, containerElement);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ('indeterminate' in $$new_props) $$invalidate(1, indeterminate = $$new_props.indeterminate);
		if ('value' in $$new_props) $$invalidate(4, value = $$new_props.value);
		if ('disabled' in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
		if ('class' in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ('inputElement' in $$new_props) $$invalidate(2, inputElement = $$new_props.inputElement);
		if ('containerElement' in $$new_props) $$invalidate(3, containerElement = $$new_props.containerElement);
		if ('$$scope' in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		createEventForwarder,
		checked,
		indeterminate,
		value,
		disabled,
		className,
		inputElement,
		containerElement,
		forwardEvents
	});

	$$self.$inject_state = $$new_props => {
		if ('checked' in $$props) $$invalidate(0, checked = $$new_props.checked);
		if ('indeterminate' in $$props) $$invalidate(1, indeterminate = $$new_props.indeterminate);
		if ('value' in $$props) $$invalidate(4, value = $$new_props.value);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$new_props.disabled);
		if ('className' in $$props) $$invalidate(6, className = $$new_props.className);
		if ('inputElement' in $$props) $$invalidate(2, inputElement = $$new_props.inputElement);
		if ('containerElement' in $$props) $$invalidate(3, containerElement = $$new_props.containerElement);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		checked,
		indeterminate,
		inputElement,
		containerElement,
		value,
		disabled,
		className,
		forwardEvents,
		$$restProps,
		$$slots,
		$$scope,
		slots,
		input_change_handler,
		input_binding,
		label_binding
	];
}

class Checkbox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				checked: 0,
				indeterminate: 1,
				value: 4,
				disabled: 5,
				class: 6,
				inputElement: 2,
				containerElement: 3
			},
			add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Checkbox",
			options,
			id: create_fragment.name
		});
	}

	get checked() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indeterminate() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indeterminate(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputElement() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputElement(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get containerElement() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set containerElement(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Checkbox;