/* ComboBox.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	action_destroyer,
	add_flush_callback,
	add_location,
	append_dev,
	append_styles,
	assign,
	attr_dev,
	bind,
	binding_callbacks,
	bubble,
	check_outros,
	compute_rest_props,
	create_component,
	create_slot,
	destroy_component,
	destroy_each,
	detach_dev,
	dispatch_dev,
	element,
	exclude_internal_props,
	get_all_dirty_from_scope,
	get_slot_changes,
	get_spread_update,
	group_outros,
	init,
	insert_dev,
	listen_dev,
	mount_component,
	noop,
	run_all,
	safe_not_equal,
	set_attributes,
	set_data_dev,
	set_input_value,
	set_style,
	space,
	svg_element,
	text,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base,
	validate_each_argument,
	validate_slots
} from "nereid://.svelte/internal/index.mjs";

import { createEventDispatcher, tick } from "nereid://.svelte/index.mjs";
import { get_current_component, onMount } from "nereid://.svelte/internal/index.mjs";
import { createEventForwarder, externalMouseEvents, uid } from "../internal.js";
import ComboBoxItem from "./ComboBoxItem.svelte.js";
import Button from "../Button/Button.svelte.js";
import TextBox from "../TextBox/TextBox.svelte.js";
import TextBoxButton from "../TextBox/TextBoxButton.svelte.js";
const file = "ComboBox.svelte";

function add_css(target) {
	append_styles(target, "svelte-1iqhotm", "@-webkit-keyframes svelte-1iqhotm-menu-in{0%{-webkit-clip-path:var(--fds-grow-clip-path);clip-path:var(--fds-grow-clip-path)}to{-webkit-clip-path:polygon(0 0,100% 0,100% 100%,0 100%);clip-path:polygon(0 0,100% 0,100% 100%,0 100%)}}@keyframes svelte-1iqhotm-menu-in{0%{-webkit-clip-path:var(--fds-grow-clip-path);clip-path:var(--fds-grow-clip-path)}to{-webkit-clip-path:polygon(0 0,100% 0,100% 100%,0 100%);clip-path:polygon(0 0,100% 0,100% 100%,0 100%)}}@-webkit-keyframes svelte-1iqhotm-shadow-in{0%{box-shadow:none}to{box-shadow:var(--fds-flyout-shadow)}}@keyframes svelte-1iqhotm-shadow-in{0%{box-shadow:none}to{box-shadow:var(--fds-flyout-shadow)}}.combo-box.svelte-1iqhotm.svelte-1iqhotm{display:inline-flex;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.combo-box.svelte-1iqhotm .button,.combo-box.svelte-1iqhotm .text-box{flex:1 1 auto}.combo-box.svelte-1iqhotm .text-box{border-color:var(--fds-control-border-default)}.combo-box.svelte-1iqhotm .text-box-underline:after{border-color:transparent}.combo-box.svelte-1iqhotm .text-box-container{cursor:default}.combo-box.svelte-1iqhotm .text-box-container:focus-visible{cursor:text}.combo-box.editable.svelte-1iqhotm .combo-box-textbox:not(:focus-within){border-color:var(--fds-control-border-default);cursor:default}.combo-box.editable.svelte-1iqhotm .combo-box-textbox:not(:focus-within) .text-box-underline:after{content:none}.combo-box.editable.svelte-1iqhotm .combo-box-textbox.disabled{border-color:var(--fds-control-stroke-default)}.combo-box.editable.open.svelte-1iqhotm .combo-box-textbox{background-color:var(--fds-control-fill-input-active);cursor:text}.combo-box.editable.open.svelte-1iqhotm .combo-box-textbox .text-box-underline:after{border-bottom:2px solid var(--fds-accent-default);content:\"\"}.combo-box.editable.open.svelte-1iqhotm .combo-box-textbox input::-moz-placeholder{color:var(--fds-text-tertiary)}.combo-box.editable.open.svelte-1iqhotm .combo-box-textbox input:-ms-input-placeholder{color:var(--fds-text-tertiary)}.combo-box.editable.open.svelte-1iqhotm .combo-box-textbox input::placeholder{color:var(--fds-text-tertiary)}.combo-box.editable.open.svelte-1iqhotm .text-box-underline{border-end-end-radius:0;border-end-start-radius:0}.combo-box.editable.svelte-1iqhotm .combo-box-dropdown.svelte-1iqhotm{border-radius:var(--fds-overlay-corner-radius);border-start-end-radius:0;border-start-start-radius:0;inline-size:100%;inset-block-start:100%;inset-inline-start:0;margin:0}.combo-box.editable.svelte-1iqhotm .combo-box-icon.svelte-1iqhotm{margin:0}.combo-box-label.svelte-1iqhotm.svelte-1iqhotm{flex:1 1 auto;min-block-size:20px;text-align:start}.combo-box-label.placeholder.svelte-1iqhotm.svelte-1iqhotm{color:var(--fds-text-secondary)}.combo-box.disabled.svelte-1iqhotm .placeholder.svelte-1iqhotm{color:var(--fds-text-disabled)}.combo-box-icon.svelte-1iqhotm.svelte-1iqhotm{-webkit-margin-start:8px;block-size:12px;inline-size:12px;margin-inline-start:8px}.combo-box-dropdown.svelte-1iqhotm.svelte-1iqhotm{-webkit-margin-before:-6px;-webkit-margin-start:-5px;-webkit-animation:svelte-1iqhotm-menu-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing),svelte-1iqhotm-shadow-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing) var(--fds-control-normal-duration);animation:svelte-1iqhotm-menu-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing),svelte-1iqhotm-shadow-in var(--fds-control-normal-duration) var(--fds-control-fast-out-slow-in-easing) var(--fds-control-normal-duration);background-clip:padding-box;background-color:var(--fds-solid-background-quarternary);border:1px solid var(--fds-surface-stroke-flyout);border-radius:var(--fds-overlay-corner-radius);box-shadow:var(--fds-flyout-shadow);box-sizing:border-box;inline-size:calc(100% + 8px);inset-block-start:var(--fds-menu-offset,0);inset-inline-start:0;margin:0;margin-block-start:-6px;margin-inline-start:-5px;max-block-size:504px;overflow:auto;padding:1px;position:absolute;z-index:100}@supports (overflow:overlay){.combo-box-dropdown.svelte-1iqhotm.svelte-1iqhotm{overflow:overlay}}.combo-box-dropdown.direction-top.svelte-1iqhotm.svelte-1iqhotm{--fds-grow-clip-path:polygon(0 0,100% 0,100% 25%,0 25%)}.combo-box-dropdown.direction-center.svelte-1iqhotm.svelte-1iqhotm{--fds-grow-clip-path:polygon(0 25%,100% 24%,100% 75%,0 75%)}.combo-box-dropdown.direction-bottom.svelte-1iqhotm.svelte-1iqhotm{--fds-grow-clip-path:polygon(0 75%,100% 75%,100% 100%,0 100%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29tYm9Cb3guc3ZlbHRlIiwic291cmNlcyI6WyJDb21ib0JveC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCA+aW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCB0aWNrIH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG5pbXBvcnQgeyBnZXRfY3VycmVudF9jb21wb25lbnQsIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlL2ludGVybmFsXCI7XHJcbmltcG9ydCB7IGNyZWF0ZUV2ZW50Rm9yd2FyZGVyLCBleHRlcm5hbE1vdXNlRXZlbnRzLCB1aWQgfSBmcm9tIFwiLi4vaW50ZXJuYWxcIjtcclxuaW1wb3J0IENvbWJvQm94SXRlbSBmcm9tIFwiLi9Db21ib0JveEl0ZW0uc3ZlbHRlXCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uL0J1dHRvbi9CdXR0b24uc3ZlbHRlXCI7XHJcbmltcG9ydCBUZXh0Qm94IGZyb20gXCIuLi9UZXh0Qm94L1RleHRCb3guc3ZlbHRlXCI7XHJcbmltcG9ydCBUZXh0Qm94QnV0dG9uIGZyb20gXCIuLi9UZXh0Qm94L1RleHRCb3hCdXR0b24uc3ZlbHRlXCI7XHJcbi8qKiBEZXRlcm1pbmVzIHdoaWNoIHNwZWNpZmllZCBpdGVtIGlzIHNlbGVjdGVkLiBDb3JyZXNwb25kJ3MgdG8gYSBnaXZlbiBpdGVtJ3MgYHZhbHVlYCBrZXkuICovXHJcbmV4cG9ydCBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XHJcbi8qKiBDdXJyZW50IHZhbHVlIG9mIHRoZSBDb21ib0JveCdzIHNlYXJjaCBib3guIE9ubHkgYXBwbGljYWJsZSBpZiBgc2VhcmNoYWJsZWAgaXMgc2V0IHRvIGB0cnVlYC4gKi9cclxuZXhwb3J0IGxldCBzZWFyY2hWYWx1ZSA9IHVuZGVmaW5lZDtcclxuLyoqIFRoZSBpbml0aWFsIHBsYWNlaG9sZGVyIHRleHQgZGlzcGxheWVkIGlmIG5vIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkLiAqL1xyXG5leHBvcnQgbGV0IHBsYWNlaG9sZGVyID0gXCJcIjtcclxuLyoqIEFycmF5IG9mIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBkcm9wZG93biBpdGVtcy4gKi9cclxuZXhwb3J0IGxldCBpdGVtcyA9IFtdO1xyXG4vKiogRGV0ZXJtaW5lcyBpZiB0aGUgQ29tYm9Cb3ggY2FuIGJlIHNlYXJjaGVkLiAqL1xyXG5leHBvcnQgbGV0IGVkaXRhYmxlID0gZmFsc2U7XHJcbi8qKiBTcGVjaWZpZXMgd2hldGhlciB0aGUgY29tYm9ib3ggaXMgZGlzYWJsZWQuICovXHJcbmV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcclxuLyoqIFRoZSBjdXJyZW50IHZpc2liaWxpdHkgc3RhdGUgb2YgdGhlIGRyb3Bkb3duIG1lbnUuICovXHJcbmV4cG9ydCBsZXQgb3BlbiA9IGZhbHNlO1xyXG4vKiogU3BlY2lmaWVzIGEgY3VzdG9tIGNsYXNzIG5hbWUgZm9yIHRoZSBvdXRlciBjb21ib2JveCBjb250YWluZXIuICovXHJcbmxldCBjbGFzc05hbWUgPSBcIlwiO1xyXG5leHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcclxuLyoqIE9idGFpbnMgYSBib3VuZCBET00gcmVmZXJlbmNlIHRvIHRoZSBDb21ib0JveCdzIHZhbHVlIGlucHV0IGVsZW1lbnQuICovXHJcbmV4cG9ydCBsZXQgaW5wdXRFbGVtZW50ID0gbnVsbDtcclxuLyoqIE9idGFpbnMgYSBib3VuZCBET00gcmVmZXJlbmNlIHRvIHRoZSBDb21ib0JveCdzIHNlYXJjaGJveCBpbnB1dCBlbGVtZW50LiBPbmx5IGFwcGxpY2FibGUgaWYgYHNlYXJjaGFibGVgIGlzIHNldCB0byBgdHJ1ZWAuICovXHJcbmV4cG9ydCBsZXQgc2VhcmNoSW5wdXRFbGVtZW50ID0gbnVsbDtcclxuLyoqIE9idGFpbnMgYSBib3VuZCBET00gcmVmZXJlbmNlIHRvIHRoZSBDb21ib0JveCdzIG91dGVyIGNvbnRhaW5lciBlbGVtZW50LiAqL1xyXG5leHBvcnQgbGV0IGNvbnRhaW5lckVsZW1lbnQgPSBudWxsO1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIENvbWJvQm94J3MgbWVudSBkcm9wZG93biBsaXN0IGVsZW1lbnQuICovXHJcbmV4cG9ydCBsZXQgbWVudUVsZW1lbnQgPSBudWxsO1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIENvbWJvQm94J3MgdHJpZ2dlciBidXR0b24gZWxlbWVudC4gKi9cclxuZXhwb3J0IGxldCBidXR0b25FbGVtZW50ID0gbnVsbDtcclxuY29uc3QgZm9yd2FyZEV2ZW50cyA9IGNyZWF0ZUV2ZW50Rm9yd2FyZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpLCBbXHJcbiAgICBcIm9wZW5cIixcclxuICAgIFwiY2xvc2VcIixcclxuICAgIFwic2VsZWN0XCIsXHJcbiAgICBcImNoYW5nZVwiLFxyXG4gICAgXCJpbnB1dFwiLFxyXG4gICAgXCJiZWZvcmVpbnB1dFwiLFxyXG4gICAgXCJrZXlkb3duXCJcclxuXSk7XHJcbmNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XHJcbmNvbnN0IGJ1dHRvbklkID0gdWlkKFwiZmRzLWNvbWJvLWJveC1idXR0b24tXCIpO1xyXG5jb25zdCBkcm9wZG93bklkID0gdWlkKFwiZmRzLWNvbWJvLWJveC1kcm9wZG93bi1cIik7XHJcbiQ6IHNlbGVjdGFibGVJdGVtcyA9IGl0ZW1zLmZpbHRlcihpdGVtID0+ICFpdGVtLmRpc2FibGVkKTtcclxuJDogc2VsZWN0aW9uID0gaXRlbXMuZmluZChpID0+IGkudmFsdWUgPT09IHZhbHVlKTtcclxuJDogaWYgKG1lbnVFbGVtZW50ICYmIG1lbnVFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgIWVkaXRhYmxlKSB7XHJcbiAgICBpZiAoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgbWVudUVsZW1lbnQuY2hpbGRyZW5baXRlbXMuaW5kZXhPZihzZWxlY3Rpb24pXS5mb2N1cygpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbWVudUVsZW1lbnQuY2hpbGRyZW5bMF0uZm9jdXMoKTtcclxuICAgIH1cclxufVxyXG4kOiBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xyXG4gICAgaWYgKG9wZW4pIHtcclxuICAgICAgICBkaXNwYXRjaChcIm9wZW5cIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkaXNwYXRjaChcImNsb3NlXCIpO1xyXG4gICAgfVxyXG59XHJcbiQ6IGRpc3BhdGNoKFwic2VsZWN0XCIsIHNlbGVjdGlvbik7XHJcbiQ6IG1lbnVHcm93RGlyZWN0aW9uID1cclxuICAgICFzZWxlY3Rpb24gfHwgaXRlbXNbaXRlbXMuaW5kZXhPZihzZWxlY3Rpb24pXSA9PT0gaXRlbXNbTWF0aC5mbG9vcihpdGVtcy5sZW5ndGggLyAyKV1cclxuICAgICAgICA/IFwiY2VudGVyXCJcclxuICAgICAgICA6IGl0ZW1zLmluZGV4T2Yoc2VsZWN0aW9uKSA8IGl0ZW1zLmluZGV4T2YoaXRlbXNbTWF0aC5mbG9vcihpdGVtcy5sZW5ndGggLyAyKV0pXHJcbiAgICAgICAgICAgID8gXCJ0b3BcIlxyXG4gICAgICAgICAgICA6IFwiYm90dG9tXCI7XHJcbmxldCBpbnB1dEZvY3VzZWQgPSBmYWxzZTtcclxubGV0IGl0ZW1IZWlnaHQgPSAzNjtcclxuY29uc3QgbWF4SXRlbXMgPSAxNDsgLy8gNTA0IChgbWF4LWJsb2NrLXNpemVgIGluIENvbWJvQm94LnNjc3MpIC8gMzYgKGl0ZW1IZWlnaHQpXHJcbmxldCBtZW51T2Zmc2V0ID0gaXRlbUhlaWdodCAqXHJcbiAgICAtKHNlbGVjdGlvblxyXG4gICAgICAgID8gaXRlbXMuaW5kZXhPZihzZWxlY3Rpb24pXHJcbiAgICAgICAgOiBNYXRoLmZsb29yKGl0ZW1zLmxlbmd0aCA+IG1heEl0ZW1zID8gbWF4SXRlbXMgLyAyIDogaXRlbXMubGVuZ3RoIC8gMikpO1xyXG5vbk1vdW50KCgpID0+IHtcclxuICAgIGlmICghc2VhcmNoVmFsdWUpXHJcbiAgICAgICAgc2VhcmNoVmFsdWUgPSB2YWx1ZTtcclxufSk7XHJcbmZ1bmN0aW9uIHVwZGF0ZU9mZnNldCh0YXJnZXQpIHtcclxuXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgY29uc3QgeyB0b3A6IGNvbnRhaW5lclRvcCB9ID0gY29udGFpbmVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGNvbnN0IHsgdG9wOiB0YXJnZXRUb3AgfSA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIG1lbnVPZmZzZXQgKz0gY29udGFpbmVyVG9wIC0gdGFyZ2V0VG9wO1xyXG5cdH0pXHJcbn1cclxuZnVuY3Rpb24gc2VsZWN0SXRlbShpdGVtKSB7XHJcbiAgICBpZiAoaXRlbS5kaXNhYmxlZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YWx1ZSA9IGl0ZW0udmFsdWU7XHJcbiAgICBzZWFyY2hWYWx1ZSA9IGl0ZW0ubmFtZTtcclxuICAgIG9wZW4gPSBmYWxzZTtcclxuICAgIGlmIChjb250YWluZXJFbGVtZW50ICYmICFlZGl0YWJsZSlcclxuICAgICAgICBjb250YWluZXJFbGVtZW50LmNoaWxkcmVuWzBdLmZvY3VzKCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gb3Blbk1lbnUoKSB7XHJcbiAgICBvcGVuID0gIW9wZW47XHJcbiAgICBhd2FpdCB0aWNrKCk7XHJcbiAgICBpZiAoZWRpdGFibGUgJiYgc2VhcmNoSW5wdXRFbGVtZW50KVxyXG4gICAgICAgIHNlYXJjaElucHV0RWxlbWVudC5mb2N1cygpO1xyXG4gICAgaWYgKG1lbnVFbGVtZW50ICYmIHNlbGVjdGlvbilcclxuICAgICAgICB1cGRhdGVPZmZzZXQobWVudUVsZW1lbnQuY2hpbGRyZW5baXRlbXMuaW5kZXhPZihzZWxlY3Rpb24pXSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlS2V5Ym9hcmROYXZpZ2F0aW9uKGV2ZW50KSB7XHJcbiAgICBjb25zdCB7IGtleSB9ID0gZXZlbnQ7XHJcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIGNvbnN0IGVkaXRhYmxlQ2xvc2VkID0gZWRpdGFibGUgJiYgIW9wZW47XHJcbiAgICAvLyBDb25kaXRpb25zIGZvciBjbG9zaW5nIHRoZSBtZW51LlxyXG4gICAgaWYgKGtleSA9PT0gXCJUYWJcIiB8fCBrZXkgPT09IFwiRXNjXCIgfHwga2V5ID09PSBcIkVzY2FwZVwiKVxyXG4gICAgICAgIG9wZW4gPSBmYWxzZTtcclxuICAgIC8vIE9oIGJveSwgaGVyZSB3ZSBnby4uLlxyXG4gICAgaWYgKGtleSA9PT0gXCJBcnJvd0Rvd25cIiAmJlxyXG4gICAgICAgICFlZGl0YWJsZUNsb3NlZCAmJlxyXG4gICAgICAgICEoaXRlbXMuaW5kZXhPZihzZWxlY3Rpb24pID49IGl0ZW1zLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBzZWxlY3RhYmxlSXRlbXNbc2VsZWN0YWJsZUl0ZW1zLmluZGV4T2Yoc2VsZWN0aW9uKSArIDFdLnZhbHVlOyAvLyBJZiBkb3duIGFycm93IGlzIHByZXNzZWQsIGNoZWNrIGN1cnJlbnQgc2VsZWN0aW9uIGFuZCBtb3ZlIHRvIG5leHQgbm9uLWRpc2FibGVkIGl0ZW0uXHJcbiAgICAgICAgc2VhcmNoVmFsdWUgPSBzZWxlY3RhYmxlSXRlbXNbc2VsZWN0YWJsZUl0ZW1zLmluZGV4T2Yoc2VsZWN0aW9uKSArIDFdLm5hbWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChrZXkgPT09IFwiQXJyb3dVcFwiICYmICFlZGl0YWJsZUNsb3NlZCAmJiAhKGl0ZW1zLmluZGV4T2Yoc2VsZWN0aW9uKSA8PSAwKSkge1xyXG4gICAgICAgIHZhbHVlID0gc2VsZWN0YWJsZUl0ZW1zW3NlbGVjdGFibGVJdGVtcy5pbmRleE9mKHNlbGVjdGlvbikgLSAxXS52YWx1ZTsgLy8gRG8gdGhlIHNhbWUgd2l0aCB1cCBhcnJvdy5cclxuICAgICAgICBzZWFyY2hWYWx1ZSA9IHNlbGVjdGFibGVJdGVtc1tzZWxlY3RhYmxlSXRlbXMuaW5kZXhPZihzZWxlY3Rpb24pIC0gMV0ubmFtZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGtleSA9PT0gXCJIb21lXCIpIHtcclxuICAgICAgICB2YWx1ZSA9IHNlbGVjdGFibGVJdGVtc1swXS52YWx1ZTsgLy8gSWYgaG9tZSBpcyBwcmVzc2VkLCBtb3ZlIHRvIGZpcnN0IG5vbi1kaXNhYmxlZCBpdGVtLlxyXG4gICAgICAgIHNlYXJjaFZhbHVlID0gc2VsZWN0YWJsZUl0ZW1zWzBdLm5hbWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChrZXkgPT09IFwiRW5kXCIpIHtcclxuICAgICAgICB2YWx1ZSA9IHNlbGVjdGFibGVJdGVtc1tzZWxlY3RhYmxlSXRlbXMubGVuZ3RoIC0gMV0udmFsdWU7IC8vIElmIGVuZCBpcyBwcmVzc2VkLCBtb3ZlIHRvIGxhc3Qgbm9uLWRpc2FibGVkIGl0ZW0uXHJcbiAgICAgICAgc2VhcmNoVmFsdWUgPSBzZWxlY3RhYmxlSXRlbXNbc2VsZWN0YWJsZUl0ZW1zLmxlbmd0aCAtIDFdLm5hbWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvcGVuICYmIChrZXkgPT09IFwiRW50ZXJcIiB8fCBrZXkgPT09IFwiIFwiKSkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgc2VsZWN0SXRlbShzZWxlY3Rpb24pOyAvLyBTZWxlY3QgaXRlbSB3aGVuIHRoZSBlbnRlci9zcGFjZSBrZXkgaXMgcHJlc3NlZCBhbmQgdGhlIG1lbnUgaXMgb3BlblxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2VhcmNoSW5wdXRFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHNlYXJjaElucHV0RWxlbWVudCkge1xyXG4gICAgICAgIHNlYXJjaElucHV0RWxlbWVudC5mb2N1cygpOyAvLyBJZiB0aGUgaW5wdXQgZWxlbWVudCBoYXMgbG9zdCBmb2N1cywgcmVnYWluIGl0LlxyXG4gICAgfVxyXG4gICAgLy8gUHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgc2Nyb2xsaW5nIGJlaGF2aW9yIGZvciB0aGVzZSBrZXlzXHJcbiAgICBpZiAoa2V5ID09PSBcIkFycm93RG93blwiIHx8IGtleSA9PT0gXCJBcnJvd1VwXCIgfHwga2V5ID09PSBcIkhvbWVcIiB8fCBrZXkgPT09IFwiRW5kXCIpXHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIC8vIEtleWJpbmRpbmdzIGZvciBvcGVuaW5nIHRoZSBtZW51IHdoZW4gaW4gZWRpdGFibGUgbW9kZSB1c2luZyBhcnJvdyBrZXlzXHJcbiAgICBpZiAoa2V5ID09PSBcIkFycm93RG93blwiIHx8IChrZXkgPT09IFwiQXJyb3dVcFwiICYmIGVkaXRhYmxlKSkge1xyXG4gICAgICAgIGlmIChvcGVuKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRpY2soKTtcclxuICAgICAgICAgICAgc2VhcmNoSW5wdXRFbGVtZW50ID09PSBudWxsIHx8IHNlYXJjaElucHV0RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VhcmNoSW5wdXRFbGVtZW50LnNlbGVjdCgpOyAvLyBTZWxlY3QgdGV4dCB3aGVuIGFuIGl0ZW0gaXMgY2hvc2VuLlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3BlbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUlucHV0Rm9jdXMoKSB7XHJcbiAgICBzZWFyY2hJbnB1dEVsZW1lbnQuc2VsZWN0KCk7XHJcbiAgICBpbnB1dEZvY3VzZWQgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUlucHV0Qmx1cigpIHtcclxuICAgIGlucHV0Rm9jdXNlZCA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUlucHV0KGV2ZW50KSB7XHJcbiAgICBjb25zdCBtYXRjaCA9IHNlbGVjdGFibGVJdGVtcy5maW5kKGkgPT4gaS5uYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChzZWFyY2hWYWx1ZS50b0xvd2VyQ2FzZSgpKSk7XHJcbiAgICBpZiAoIW1hdGNoKVxyXG4gICAgICAgIHZhbHVlID0gbnVsbDtcclxuICAgIGlmIChtYXRjaCAmJiBldmVudC5pbnB1dFR5cGUgPT09IFwiaW5zZXJ0VGV4dFwiICYmIHNlYXJjaFZhbHVlLnRyaW0oKSAhPT0gXCJcIikge1xyXG4gICAgICAgIHNlYXJjaElucHV0RWxlbWVudC52YWx1ZSA9IG1hdGNoLm5hbWU7XHJcbiAgICAgICAgc2VhcmNoSW5wdXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKHNlYXJjaFZhbHVlLmxlbmd0aCwgbWF0Y2gubmFtZS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1hdGNoICYmICFtYXRjaC5kaXNhYmxlZClcclxuICAgICAgICB2YWx1ZSA9IG1hdGNoLnZhbHVlO1xyXG4gICAgc2VhcmNoVmFsdWUgPSBzZWFyY2hJbnB1dEVsZW1lbnQudmFsdWU7XHJcbn1cclxuPC9zY3JpcHQ+XHJcblxyXG48IS0tXHJcbkBjb21wb25lbnRcclxuVXNlIGEgY29tYm8gYm94IChhbHNvIGtub3duIGFzIGEgZHJvcC1kb3duIGxpc3QpIHRvIHByZXNlbnQgYSBsaXN0IG9mIGl0ZW1zIHRoYXQgYSB1c2VyIGNhbiBzZWxlY3QgZnJvbS4gQSBjb21ibyBib3ggc3RhcnRzIGluIGEgY29tcGFjdCBzdGF0ZSBhbmQgZXhwYW5kcyB0byBzaG93IGEgbGlzdCBvZiBzZWxlY3RhYmxlIGl0ZW1zLiBcclxuXHJcbldoZW4gdGhlIGNvbWJvIGJveCBpcyBjbG9zZWQsIGl0IGVpdGhlciBkaXNwbGF5cyB0aGUgY3VycmVudCBzZWxlY3Rpb24gb3IgaXMgZW1wdHkgaWYgdGhlcmUgaXMgbm8gc2VsZWN0ZWQgaXRlbS4gV2hlbiB0aGUgdXNlciBleHBhbmRzIHRoZSBjb21ibyBib3gsIGl0IGRpc3BsYXlzIHRoZSBsaXN0IG9mIHNlbGVjdGFibGUgaXRlbXMuXHJcbltEb2NzXShodHRwczovL2ZsdWVudC1zdmVsdGUudmVyY2VsLmFwcC9kb2NzL2NvbXBvbmVudHMvY29tYm9ib3gpXHJcblxyXG4tIFVzYWdlOlxyXG4gICAgYGBgdHN4XHJcbiAgICA8Q29tYm9Cb3ggaXRlbXM9e1tcclxuXHRcdHsgbmFtZTogXCJJdGVtIDBcIiwgdmFsdWU6IDAgfSxcclxuXHRcdHsgbmFtZTogXCJJdGVtIDFcIiwgdmFsdWU6IDEgfSxcclxuXHRcdHsgbmFtZTogXCJJdGVtIDJcIiwgdmFsdWU6IDIgfSxcclxuXHRdfSAvPlxyXG4gICAgYGBgXHJcbi0tPlxyXG48ZGl2XHJcblx0dXNlOmZvcndhcmRFdmVudHNcclxuXHR1c2U6ZXh0ZXJuYWxNb3VzZUV2ZW50cz17eyB0eXBlOiBcIm1vdXNlZG93blwiIH19XHJcblx0Y2xhc3M9XCJjb21iby1ib3gge2NsYXNzTmFtZX1cIlxyXG5cdGNsYXNzOmRpc2FibGVkXHJcblx0Y2xhc3M6ZWRpdGFibGVcclxuXHRjbGFzczpvcGVuXHJcblx0b246b3V0ZXJtb3VzZWRvd249eygpID0+IHtcclxuXHRcdGlmIChvcGVuKSBvcGVuID0gZmFsc2U7XHJcblx0fX1cclxuXHRiaW5kOnRoaXM9e2NvbnRhaW5lckVsZW1lbnR9XHJcblx0ey4uLiQkcmVzdFByb3BzfVxyXG4+XHJcblx0eyNpZiBlZGl0YWJsZX1cclxuXHRcdDxUZXh0Qm94XHJcblx0XHRcdGNsZWFyQnV0dG9uPXtmYWxzZX1cclxuXHRcdFx0Y2xhc3M9XCJjb21iby1ib3gtdGV4dC1ib3hcIlxyXG5cdFx0XHRyb2xlPVwiY29tYm9ib3hcIlxyXG5cdFx0XHRhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9e2lucHV0Rm9jdXNlZH1cclxuXHRcdFx0YXJpYS1hdXRvY29tcGxldGU9XCJib3RoXCJcclxuXHRcdFx0YXJpYS1jb250cm9scz17ZHJvcGRvd25JZH1cclxuXHRcdFx0YXJpYS1leHBhbmRlZD17b3Blbn1cclxuXHRcdFx0YXJpYS1oYXNwb3B1cD17b3BlbiA/IFwibGlzdGJveFwiIDogdW5kZWZpbmVkfVxyXG5cdFx0XHRiaW5kOnZhbHVlPXtzZWFyY2hWYWx1ZX1cclxuXHRcdFx0YmluZDppbnB1dEVsZW1lbnQ9e3NlYXJjaElucHV0RWxlbWVudH1cclxuXHRcdFx0b246a2V5ZG93bj17aGFuZGxlS2V5Ym9hcmROYXZpZ2F0aW9ufVxyXG5cdFx0XHRvbjppbnB1dD17aGFuZGxlSW5wdXR9XHJcblx0XHRcdG9uOmZvY3VzPXtoYW5kbGVJbnB1dEZvY3VzfVxyXG5cdFx0XHRvbjpibHVyPXtoYW5kbGVJbnB1dEJsdXJ9XHJcblx0XHRcdG9uOmNoYW5nZVxyXG5cdFx0XHRvbjppbnB1dFxyXG5cdFx0XHRvbjpiZWZvcmVpbnB1dFxyXG5cdFx0XHRvbjprZXlkb3duXHJcblx0XHRcdHtwbGFjZWhvbGRlcn1cclxuXHRcdFx0e2Rpc2FibGVkfVxyXG5cdFx0PlxyXG5cdFx0XHQ8VGV4dEJveEJ1dHRvblxyXG5cdFx0XHRcdGFyaWEtZXhwYW5kZWQ9e29wZW59XHJcblx0XHRcdFx0YXJpYS1sYWJlbD1cIk9wZW4gZHJvcGRvd25cIlxyXG5cdFx0XHRcdGFyaWEtY29udHJvbHM9e2Ryb3Bkb3duSWR9XHJcblx0XHRcdFx0Y2xhc3M9XCJjb21iby1ib3gtZHJvcGRvd24tYnV0dG9uXCJcclxuXHRcdFx0XHRvbjpjbGljaz17b3Blbk1lbnV9XHJcblx0XHRcdFx0YmluZDplbGVtZW50PXtidXR0b25FbGVtZW50fVxyXG5cdFx0XHRcdHNsb3Q9XCJidXR0b25zXCJcclxuXHRcdFx0PlxyXG5cdFx0XHRcdDxzdmdcclxuXHRcdFx0XHRcdGFyaWEtaGlkZGVuPVwidHJ1ZVwiXHJcblx0XHRcdFx0XHRjbGFzcz1cImNvbWJvLWJveC1pY29uXCJcclxuXHRcdFx0XHRcdHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxyXG5cdFx0XHRcdFx0d2lkdGg9XCI0OFwiXHJcblx0XHRcdFx0XHRoZWlnaHQ9XCI0OFwiXHJcblx0XHRcdFx0XHR2aWV3Qm94PVwiMCAwIDQ4IDQ4XCJcclxuXHRcdFx0XHQ+XHJcblx0XHRcdFx0XHQ8cGF0aFxyXG5cdFx0XHRcdFx0XHRmaWxsPVwiY3VycmVudENvbG9yXCJcclxuXHRcdFx0XHRcdFx0ZD1cIk04LjM2NjEyIDE2LjExNjFDNy44Nzc5NiAxNi42MDQzIDcuODc3OTYgMTcuMzk1NyA4LjM2NjEyIDE3Ljg4MzlMMjMuMTE2MSAzMi42MzM5QzIzLjYwNDMgMzMuMTIyIDI0LjM5NTcgMzMuMTIyIDI0Ljg4MzkgMzIuNjMzOUwzOS42MzM5IDE3Ljg4MzlDNDAuMTIyIDE3LjM5NTcgNDAuMTIyIDE2LjYwNDMgMzkuNjMzOSAxNi4xMTYxQzM5LjE0NTcgMTUuNjI4IDM4LjM1NDMgMTUuNjI4IDM3Ljg2NjEgMTYuMTE2MUwyNCAyOS45ODIyTDEwLjEzMzkgMTYuMTE2MUM5LjY0NTczIDE1LjYyOCA4Ljg1NDI3IDE1LjYyOCA4LjM2NjEyIDE2LjExNjFaXCJcclxuXHRcdFx0XHRcdC8+XHJcblx0XHRcdFx0PC9zdmc+XHJcblx0XHRcdDwvVGV4dEJveEJ1dHRvbj5cclxuXHRcdDwvVGV4dEJveD5cclxuXHR7OmVsc2V9XHJcblx0XHQ8QnV0dG9uXHJcblx0XHRcdHR5cGU9XCJidXR0b25cIlxyXG5cdFx0XHRjbGFzcz1cImNvbWJvLWJveC1idXR0b25cIlxyXG5cdFx0XHRpZD17YnV0dG9uSWR9XHJcblx0XHRcdGFyaWEtbGFiZWxsZWRieT17YnV0dG9uSWR9XHJcblx0XHRcdGFyaWEtaGFzcG9wdXA9e29wZW4gPyBcImxpc3Rib3hcIiA6IHVuZGVmaW5lZH1cclxuXHRcdFx0YXJpYS1jb250cm9scz17ZHJvcGRvd25JZH1cclxuXHRcdFx0b246a2V5ZG93bj17aGFuZGxlS2V5Ym9hcmROYXZpZ2F0aW9ufVxyXG5cdFx0XHRvbjprZXlkb3duXHJcblx0XHRcdG9uOmNsaWNrPXtvcGVuTWVudX1cclxuXHRcdFx0YmluZDplbGVtZW50PXtidXR0b25FbGVtZW50fVxyXG5cdFx0XHR7ZGlzYWJsZWR9XHJcblx0XHQ+XHJcblx0XHRcdDxzcGFuIGNsYXNzPVwiY29tYm8tYm94LWxhYmVsXCIgY2xhc3M6cGxhY2Vob2xkZXI9eyFzZWxlY3Rpb259PlxyXG5cdFx0XHRcdHtzZWxlY3Rpb24/Lm5hbWUgfHwgcGxhY2Vob2xkZXJ9XHJcblx0XHRcdDwvc3Bhbj5cclxuXHRcdFx0PHN2Z1xyXG5cdFx0XHRcdGFyaWEtaGlkZGVuPVwidHJ1ZVwiXHJcblx0XHRcdFx0Y2xhc3M9XCJjb21iby1ib3gtaWNvblwiXHJcblx0XHRcdFx0eG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXHJcblx0XHRcdFx0d2lkdGg9XCI0OFwiXHJcblx0XHRcdFx0aGVpZ2h0PVwiNDhcIlxyXG5cdFx0XHRcdHZpZXdCb3g9XCIwIDAgNDggNDhcIlxyXG5cdFx0XHQ+XHJcblx0XHRcdFx0PHBhdGhcclxuXHRcdFx0XHRcdGZpbGw9XCJjdXJyZW50Q29sb3JcIlxyXG5cdFx0XHRcdFx0ZD1cIk04LjM2NjEyIDE2LjExNjFDNy44Nzc5NiAxNi42MDQzIDcuODc3OTYgMTcuMzk1NyA4LjM2NjEyIDE3Ljg4MzlMMjMuMTE2MSAzMi42MzM5QzIzLjYwNDMgMzMuMTIyIDI0LjM5NTcgMzMuMTIyIDI0Ljg4MzkgMzIuNjMzOUwzOS42MzM5IDE3Ljg4MzlDNDAuMTIyIDE3LjM5NTcgNDAuMTIyIDE2LjYwNDMgMzkuNjMzOSAxNi4xMTYxQzM5LjE0NTcgMTUuNjI4IDM4LjM1NDMgMTUuNjI4IDM3Ljg2NjEgMTYuMTE2MUwyNCAyOS45ODIyTDEwLjEzMzkgMTYuMTE2MUM5LjY0NTczIDE1LjYyOCA4Ljg1NDI3IDE1LjYyOCA4LjM2NjEyIDE2LjExNjFaXCJcclxuXHRcdFx0XHQvPlxyXG5cdFx0XHQ8L3N2Zz5cclxuXHRcdDwvQnV0dG9uPlxyXG5cdHsvaWZ9XHJcblx0eyNpZiAhZGlzYWJsZWQgJiYgaXRlbXMubGVuZ3RoID4gMH1cclxuXHRcdHsjaWYgb3Blbn1cclxuXHRcdFx0PHVsXHJcblx0XHRcdFx0YmluZDp0aGlzPXttZW51RWxlbWVudH1cclxuXHRcdFx0XHRvbjpibHVyPXsoKSA9PiAob3BlbiA9IGZhbHNlKX1cclxuXHRcdFx0XHRpZD17ZHJvcGRvd25JZH1cclxuXHRcdFx0XHRhcmlhLWxhYmVsbGVkYnk9e2J1dHRvbklkfVxyXG5cdFx0XHRcdGFyaWEtYWN0aXZlZGVzY2VuZGFudD17ZWRpdGFibGVcclxuXHRcdFx0XHRcdD8gdW5kZWZpbmVkXHJcblx0XHRcdFx0XHQ6IGAke2Ryb3Bkb3duSWR9LWl0ZW0tJHtpdGVtcy5pbmRleE9mKHNlbGVjdGlvbil9YH1cclxuXHRcdFx0XHRyb2xlPVwibGlzdGJveFwiXHJcblx0XHRcdFx0Y2xhc3M9XCJjb21iby1ib3gtZHJvcGRvd24gZGlyZWN0aW9uLXshZWRpdGFibGVcclxuXHRcdFx0XHRcdD8gbWVudUdyb3dEaXJlY3Rpb24gPz8gJ2NlbnRlcidcclxuXHRcdFx0XHRcdDogJ3RvcCd9XCJcclxuXHRcdFx0XHRzdHlsZT1cIi0tZmRzLW1lbnUtb2Zmc2V0OiB7bWVudU9mZnNldH1weDsgc2Nyb2xsLWJlaGF2aW9yOiBhdXRvO1wiXHJcblx0XHRcdD5cclxuXHRcdFx0XHR7I2VhY2ggaXRlbXMgYXMgaXRlbSwgaX1cclxuXHRcdFx0XHRcdDxDb21ib0JveEl0ZW1cclxuXHRcdFx0XHRcdFx0cm9sZT1cIm9wdGlvblwiXHJcblx0XHRcdFx0XHRcdHNlbGVjdGVkPXtpdGVtLnZhbHVlID09PSB2YWx1ZX1cclxuXHRcdFx0XHRcdFx0ZGlzYWJsZWQ9e2l0ZW0uZGlzYWJsZWR9XHJcblx0XHRcdFx0XHRcdGlkPVwie2Ryb3Bkb3duSWR9LWl0ZW0te2l9XCJcclxuXHRcdFx0XHRcdFx0b246a2V5ZG93bj17aGFuZGxlS2V5Ym9hcmROYXZpZ2F0aW9ufVxyXG5cdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4gc2VsZWN0SXRlbShpdGVtKX1cclxuXHRcdFx0XHRcdD5cclxuXHRcdFx0XHRcdFx0e2l0ZW0ubmFtZX1cclxuXHRcdFx0XHRcdDwvQ29tYm9Cb3hJdGVtPlxyXG5cdFx0XHRcdHsvZWFjaH1cclxuXHRcdFx0PC91bD5cclxuXHRcdHsvaWZ9XHJcblxyXG5cdFx0PGlucHV0XHJcblx0XHRcdHR5cGU9XCJoaWRkZW5cIlxyXG5cdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIlxyXG5cdFx0XHRiaW5kOnRoaXM9e2lucHV0RWxlbWVudH1cclxuXHRcdFx0YmluZDp2YWx1ZVxyXG5cdFx0XHRvbjpjaGFuZ2VcclxuXHRcdFx0b246aW5wdXRcclxuXHRcdFx0b246YmVmb3JlaW5wdXRcclxuXHRcdC8+XHJcblx0XHQ8c2xvdCAvPlxyXG5cdHsvaWZ9XHJcbjwvZGl2PlxyXG5cclxuPHN0eWxlID5ALXdlYmtpdC1rZXlmcmFtZXMgbWVudS1pbnswJXstd2Via2l0LWNsaXAtcGF0aDp2YXIoLS1mZHMtZ3Jvdy1jbGlwLXBhdGgpO2NsaXAtcGF0aDp2YXIoLS1mZHMtZ3Jvdy1jbGlwLXBhdGgpfXRvey13ZWJraXQtY2xpcC1wYXRoOnBvbHlnb24oMCAwLDEwMCUgMCwxMDAlIDEwMCUsMCAxMDAlKTtjbGlwLXBhdGg6cG9seWdvbigwIDAsMTAwJSAwLDEwMCUgMTAwJSwwIDEwMCUpfX1Aa2V5ZnJhbWVzIG1lbnUtaW57MCV7LXdlYmtpdC1jbGlwLXBhdGg6dmFyKC0tZmRzLWdyb3ctY2xpcC1wYXRoKTtjbGlwLXBhdGg6dmFyKC0tZmRzLWdyb3ctY2xpcC1wYXRoKX10b3std2Via2l0LWNsaXAtcGF0aDpwb2x5Z29uKDAgMCwxMDAlIDAsMTAwJSAxMDAlLDAgMTAwJSk7Y2xpcC1wYXRoOnBvbHlnb24oMCAwLDEwMCUgMCwxMDAlIDEwMCUsMCAxMDAlKX19QC13ZWJraXQta2V5ZnJhbWVzIHNoYWRvdy1pbnswJXtib3gtc2hhZG93Om5vbmV9dG97Ym94LXNoYWRvdzp2YXIoLS1mZHMtZmx5b3V0LXNoYWRvdyl9fUBrZXlmcmFtZXMgc2hhZG93LWluezAle2JveC1zaGFkb3c6bm9uZX10b3tib3gtc2hhZG93OnZhcigtLWZkcy1mbHlvdXQtc2hhZG93KX19LmNvbWJvLWJveHtkaXNwbGF5OmlubGluZS1mbGV4O3Bvc2l0aW9uOnJlbGF0aXZlOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uY29tYm8tYm94IDpnbG9iYWwoLmJ1dHRvbiksLmNvbWJvLWJveCA6Z2xvYmFsKC50ZXh0LWJveCl7ZmxleDoxIDEgYXV0b30uY29tYm8tYm94IDpnbG9iYWwoLnRleHQtYm94KXtib3JkZXItY29sb3I6dmFyKC0tZmRzLWNvbnRyb2wtYm9yZGVyLWRlZmF1bHQpfS5jb21iby1ib3ggOmdsb2JhbCgudGV4dC1ib3gtdW5kZXJsaW5lOmFmdGVyKXtib3JkZXItY29sb3I6dHJhbnNwYXJlbnR9LmNvbWJvLWJveCA6Z2xvYmFsKC50ZXh0LWJveC1jb250YWluZXIpe2N1cnNvcjpkZWZhdWx0fS5jb21iby1ib3ggOmdsb2JhbCgudGV4dC1ib3gtY29udGFpbmVyOmZvY3VzLXZpc2libGUpe2N1cnNvcjp0ZXh0fS5jb21iby1ib3guZWRpdGFibGUgOmdsb2JhbCguY29tYm8tYm94LXRleHRib3g6bm90KDpmb2N1cy13aXRoaW4pKXtib3JkZXItY29sb3I6dmFyKC0tZmRzLWNvbnRyb2wtYm9yZGVyLWRlZmF1bHQpO2N1cnNvcjpkZWZhdWx0fS5jb21iby1ib3guZWRpdGFibGUgOmdsb2JhbCguY29tYm8tYm94LXRleHRib3g6bm90KDpmb2N1cy13aXRoaW4pKSA6Z2xvYmFsKC50ZXh0LWJveC11bmRlcmxpbmU6YWZ0ZXIpe2NvbnRlbnQ6bm9uZX0uY29tYm8tYm94LmVkaXRhYmxlIDpnbG9iYWwoLmNvbWJvLWJveC10ZXh0Ym94LmRpc2FibGVkKXtib3JkZXItY29sb3I6dmFyKC0tZmRzLWNvbnRyb2wtc3Ryb2tlLWRlZmF1bHQpfS5jb21iby1ib3guZWRpdGFibGUub3BlbiA6Z2xvYmFsKC5jb21iby1ib3gtdGV4dGJveCl7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtY29udHJvbC1maWxsLWlucHV0LWFjdGl2ZSk7Y3Vyc29yOnRleHR9LmNvbWJvLWJveC5lZGl0YWJsZS5vcGVuIDpnbG9iYWwoLmNvbWJvLWJveC10ZXh0Ym94KSA6Z2xvYmFsKC50ZXh0LWJveC11bmRlcmxpbmU6YWZ0ZXIpe2JvcmRlci1ib3R0b206MnB4IHNvbGlkIHZhcigtLWZkcy1hY2NlbnQtZGVmYXVsdCk7Y29udGVudDpcIlwifS5jb21iby1ib3guZWRpdGFibGUub3BlbiA6Z2xvYmFsKC5jb21iby1ib3gtdGV4dGJveCkgOmdsb2JhbChpbnB1dDo6LW1vei1wbGFjZWhvbGRlcil7Y29sb3I6dmFyKC0tZmRzLXRleHQtdGVydGlhcnkpfS5jb21iby1ib3guZWRpdGFibGUub3BlbiA6Z2xvYmFsKC5jb21iby1ib3gtdGV4dGJveCkgOmdsb2JhbChpbnB1dDotbXMtaW5wdXQtcGxhY2Vob2xkZXIpe2NvbG9yOnZhcigtLWZkcy10ZXh0LXRlcnRpYXJ5KX0uY29tYm8tYm94LmVkaXRhYmxlLm9wZW4gOmdsb2JhbCguY29tYm8tYm94LXRleHRib3gpIDpnbG9iYWwoaW5wdXQ6OnBsYWNlaG9sZGVyKXtjb2xvcjp2YXIoLS1mZHMtdGV4dC10ZXJ0aWFyeSl9LmNvbWJvLWJveC5lZGl0YWJsZS5vcGVuIDpnbG9iYWwoLnRleHQtYm94LXVuZGVybGluZSl7Ym9yZGVyLWVuZC1lbmQtcmFkaXVzOjA7Ym9yZGVyLWVuZC1zdGFydC1yYWRpdXM6MH0uY29tYm8tYm94LmVkaXRhYmxlIC5jb21iby1ib3gtZHJvcGRvd257Ym9yZGVyLXJhZGl1czp2YXIoLS1mZHMtb3ZlcmxheS1jb3JuZXItcmFkaXVzKTtib3JkZXItc3RhcnQtZW5kLXJhZGl1czowO2JvcmRlci1zdGFydC1zdGFydC1yYWRpdXM6MDtpbmxpbmUtc2l6ZToxMDAlO2luc2V0LWJsb2NrLXN0YXJ0OjEwMCU7aW5zZXQtaW5saW5lLXN0YXJ0OjA7bWFyZ2luOjB9LmNvbWJvLWJveC5lZGl0YWJsZSAuY29tYm8tYm94LWljb257bWFyZ2luOjB9LmNvbWJvLWJveC1sYWJlbHtmbGV4OjEgMSBhdXRvO21pbi1ibG9jay1zaXplOjIwcHg7dGV4dC1hbGlnbjpzdGFydH0uY29tYm8tYm94LWxhYmVsLnBsYWNlaG9sZGVye2NvbG9yOnZhcigtLWZkcy10ZXh0LXNlY29uZGFyeSl9LmNvbWJvLWJveC5kaXNhYmxlZCAucGxhY2Vob2xkZXJ7Y29sb3I6dmFyKC0tZmRzLXRleHQtZGlzYWJsZWQpfS5jb21iby1ib3gtaWNvbnstd2Via2l0LW1hcmdpbi1zdGFydDo4cHg7YmxvY2stc2l6ZToxMnB4O2lubGluZS1zaXplOjEycHg7bWFyZ2luLWlubGluZS1zdGFydDo4cHh9LmNvbWJvLWJveC1kcm9wZG93bnstd2Via2l0LW1hcmdpbi1iZWZvcmU6LTZweDstd2Via2l0LW1hcmdpbi1zdGFydDotNXB4Oy13ZWJraXQtYW5pbWF0aW9uOm1lbnUtaW4gdmFyKC0tZmRzLWNvbnRyb2wtbm9ybWFsLWR1cmF0aW9uKSB2YXIoLS1mZHMtY29udHJvbC1mYXN0LW91dC1zbG93LWluLWVhc2luZyksc2hhZG93LWluIHZhcigtLWZkcy1jb250cm9sLW5vcm1hbC1kdXJhdGlvbikgdmFyKC0tZmRzLWNvbnRyb2wtZmFzdC1vdXQtc2xvdy1pbi1lYXNpbmcpIHZhcigtLWZkcy1jb250cm9sLW5vcm1hbC1kdXJhdGlvbik7YW5pbWF0aW9uOm1lbnUtaW4gdmFyKC0tZmRzLWNvbnRyb2wtbm9ybWFsLWR1cmF0aW9uKSB2YXIoLS1mZHMtY29udHJvbC1mYXN0LW91dC1zbG93LWluLWVhc2luZyksc2hhZG93LWluIHZhcigtLWZkcy1jb250cm9sLW5vcm1hbC1kdXJhdGlvbikgdmFyKC0tZmRzLWNvbnRyb2wtZmFzdC1vdXQtc2xvdy1pbi1lYXNpbmcpIHZhcigtLWZkcy1jb250cm9sLW5vcm1hbC1kdXJhdGlvbik7YmFja2dyb3VuZC1jbGlwOnBhZGRpbmctYm94O2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLXNvbGlkLWJhY2tncm91bmQtcXVhcnRlcm5hcnkpO2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmRzLXN1cmZhY2Utc3Ryb2tlLWZseW91dCk7Ym9yZGVyLXJhZGl1czp2YXIoLS1mZHMtb3ZlcmxheS1jb3JuZXItcmFkaXVzKTtib3gtc2hhZG93OnZhcigtLWZkcy1mbHlvdXQtc2hhZG93KTtib3gtc2l6aW5nOmJvcmRlci1ib3g7aW5saW5lLXNpemU6Y2FsYygxMDAlICsgOHB4KTtpbnNldC1ibG9jay1zdGFydDp2YXIoLS1mZHMtbWVudS1vZmZzZXQsMCk7aW5zZXQtaW5saW5lLXN0YXJ0OjA7bWFyZ2luOjA7bWFyZ2luLWJsb2NrLXN0YXJ0Oi02cHg7bWFyZ2luLWlubGluZS1zdGFydDotNXB4O21heC1ibG9jay1zaXplOjUwNHB4O292ZXJmbG93OmF1dG87cGFkZGluZzoxcHg7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoxMDB9QHN1cHBvcnRzIChvdmVyZmxvdzpvdmVybGF5KXsuY29tYm8tYm94LWRyb3Bkb3due292ZXJmbG93Om92ZXJsYXl9fS5jb21iby1ib3gtZHJvcGRvd24uZGlyZWN0aW9uLXRvcHstLWZkcy1ncm93LWNsaXAtcGF0aDpwb2x5Z29uKDAgMCwxMDAlIDAsMTAwJSAyNSUsMCAyNSUpfS5jb21iby1ib3gtZHJvcGRvd24uZGlyZWN0aW9uLWNlbnRlcnstLWZkcy1ncm93LWNsaXAtcGF0aDpwb2x5Z29uKDAgMjUlLDEwMCUgMjQlLDEwMCUgNzUlLDAgNzUlKX0uY29tYm8tYm94LWRyb3Bkb3duLmRpcmVjdGlvbi1ib3R0b217LS1mZHMtZ3Jvdy1jbGlwLXBhdGg6cG9seWdvbigwIDc1JSwxMDAlIDc1JSwxMDAlIDEwMCUsMCAxMDAlKX08L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBc1VRLG1CQUFtQixzQkFBTyxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsSUFBSSxvQkFBb0IsQ0FBQyxDQUFDLFVBQVUsSUFBSSxvQkFBb0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFD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 */");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[52] = list[i];
	child_ctx[54] = i;
	return child_ctx;
}

// (251:1) {:else}
function create_else_block(ctx) {
	let button;
	let updating_element;
	let current;

	function button_element_binding(value) {
		/*button_element_binding*/ ctx[38](value);
	}

	let button_props = {
		type: "button",
		class: "combo-box-button",
		id: /*buttonId*/ ctx[18],
		"aria-labelledby": /*buttonId*/ ctx[18],
		"aria-haspopup": /*open*/ ctx[1] ? "listbox" : undefined,
		"aria-controls": /*dropdownId*/ ctx[19],
		disabled: /*disabled*/ ctx[11],
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	};

	if (/*buttonElement*/ ctx[7] !== void 0) {
		button_props.element = /*buttonElement*/ ctx[7];
	}

	button = new Button({ props: button_props, $$inline: true });
	binding_callbacks.push(() => bind(button, 'element', button_element_binding));
	button.$on("keydown", /*handleKeyboardNavigation*/ ctx[22]);
	button.$on("keydown", /*keydown_handler_1*/ ctx[39]);
	button.$on("click", /*openMenu*/ ctx[21]);

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};
			if (dirty[0] & /*open*/ 2) button_changes["aria-haspopup"] = /*open*/ ctx[1] ? "listbox" : undefined;
			if (dirty[0] & /*disabled*/ 2048) button_changes.disabled = /*disabled*/ ctx[11];

			if (dirty[0] & /*selection, placeholder*/ 8448 | dirty[1] & /*$$scope*/ 65536) {
				button_changes.$$scope = { dirty, ctx };
			}

			if (!updating_element && dirty[0] & /*buttonElement*/ 128) {
				updating_element = true;
				button_changes.element = /*buttonElement*/ ctx[7];
				add_flush_callback(() => updating_element = false);
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(251:1) {:else}",
		ctx
	});

	return block;
}

// (204:1) {#if editable}
function create_if_block_2(ctx) {
	let textbox;
	let updating_value;
	let updating_inputElement;
	let current;

	function textbox_value_binding(value) {
		/*textbox_value_binding*/ ctx[32](value);
	}

	function textbox_inputElement_binding(value) {
		/*textbox_inputElement_binding*/ ctx[33](value);
	}

	let textbox_props = {
		clearButton: false,
		class: "combo-box-text-box",
		role: "combobox",
		"aria-activedescendant": /*inputFocused*/ ctx[14],
		"aria-autocomplete": "both",
		"aria-controls": /*dropdownId*/ ctx[19],
		"aria-expanded": /*open*/ ctx[1],
		"aria-haspopup": /*open*/ ctx[1] ? "listbox" : undefined,
		placeholder: /*placeholder*/ ctx[8],
		disabled: /*disabled*/ ctx[11],
		$$slots: { buttons: [create_buttons_slot] },
		$$scope: { ctx }
	};

	if (/*searchValue*/ ctx[3] !== void 0) {
		textbox_props.value = /*searchValue*/ ctx[3];
	}

	if (/*searchInputElement*/ ctx[5] !== void 0) {
		textbox_props.inputElement = /*searchInputElement*/ ctx[5];
	}

	textbox = new TextBox({ props: textbox_props, $$inline: true });
	binding_callbacks.push(() => bind(textbox, 'value', textbox_value_binding));
	binding_callbacks.push(() => bind(textbox, 'inputElement', textbox_inputElement_binding));
	textbox.$on("keydown", /*handleKeyboardNavigation*/ ctx[22]);
	textbox.$on("input", /*handleInput*/ ctx[25]);
	textbox.$on("focus", /*handleInputFocus*/ ctx[23]);
	textbox.$on("blur", /*handleInputBlur*/ ctx[24]);
	textbox.$on("change", /*change_handler*/ ctx[34]);
	textbox.$on("input", /*input_handler*/ ctx[35]);
	textbox.$on("beforeinput", /*beforeinput_handler*/ ctx[36]);
	textbox.$on("keydown", /*keydown_handler*/ ctx[37]);

	const block = {
		c: function create() {
			create_component(textbox.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(textbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textbox_changes = {};
			if (dirty[0] & /*inputFocused*/ 16384) textbox_changes["aria-activedescendant"] = /*inputFocused*/ ctx[14];
			if (dirty[0] & /*open*/ 2) textbox_changes["aria-expanded"] = /*open*/ ctx[1];
			if (dirty[0] & /*open*/ 2) textbox_changes["aria-haspopup"] = /*open*/ ctx[1] ? "listbox" : undefined;
			if (dirty[0] & /*placeholder*/ 256) textbox_changes.placeholder = /*placeholder*/ ctx[8];
			if (dirty[0] & /*disabled*/ 2048) textbox_changes.disabled = /*disabled*/ ctx[11];

			if (dirty[0] & /*open, buttonElement*/ 130 | dirty[1] & /*$$scope*/ 65536) {
				textbox_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value && dirty[0] & /*searchValue*/ 8) {
				updating_value = true;
				textbox_changes.value = /*searchValue*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_inputElement && dirty[0] & /*searchInputElement*/ 32) {
				updating_inputElement = true;
				textbox_changes.inputElement = /*searchInputElement*/ ctx[5];
				add_flush_callback(() => updating_inputElement = false);
			}

			textbox.$set(textbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(204:1) {#if editable}",
		ctx
	});

	return block;
}

// (252:2) <Button     type="button"     class="combo-box-button"     id={buttonId}     aria-labelledby={buttonId}     aria-haspopup={open ? "listbox" : undefined}     aria-controls={dropdownId}     on:keydown={handleKeyboardNavigation}     on:keydown     on:click={openMenu}     bind:element={buttonElement}     {disabled}    >
function create_default_slot_2(ctx) {
	let span;
	let t0_value = (/*selection*/ ctx[13]?.name || /*placeholder*/ ctx[8]) + "";
	let t0;
	let t1;
	let svg;
	let path;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(span, "class", "combo-box-label svelte-1iqhotm");
			toggle_class(span, "placeholder", !/*selection*/ ctx[13]);
			add_location(span, file, 264, 3, 9828);
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", "M8.36612 16.1161C7.87796 16.6043 7.87796 17.3957 8.36612 17.8839L23.1161 32.6339C23.6043 33.122 24.3957 33.122 24.8839 32.6339L39.6339 17.8839C40.122 17.3957 40.122 16.6043 39.6339 16.1161C39.1457 15.628 38.3543 15.628 37.8661 16.1161L24 29.9822L10.1339 16.1161C9.64573 15.628 8.85427 15.628 8.36612 16.1161Z");
			add_location(path, file, 275, 4, 10110);
			attr_dev(svg, "aria-hidden", "true");
			attr_dev(svg, "class", "combo-box-icon svelte-1iqhotm");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "48");
			attr_dev(svg, "height", "48");
			attr_dev(svg, "viewBox", "0 0 48 48");
			add_location(svg, file, 267, 3, 9944);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*selection, placeholder*/ 8448 && t0_value !== (t0_value = (/*selection*/ ctx[13]?.name || /*placeholder*/ ctx[8]) + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*selection*/ 8192) {
				toggle_class(span, "placeholder", !/*selection*/ ctx[13]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(252:2) <Button     type=\\\"button\\\"     class=\\\"combo-box-button\\\"     id={buttonId}     aria-labelledby={buttonId}     aria-haspopup={open ? \\\"listbox\\\" : undefined}     aria-controls={dropdownId}     on:keydown={handleKeyboardNavigation}     on:keydown     on:click={openMenu}     bind:element={buttonElement}     {disabled}    >",
		ctx
	});

	return block;
}

// (227:3) <TextBoxButton      aria-expanded={open}      aria-label="Open dropdown"      aria-controls={dropdownId}      class="combo-box-dropdown-button"      on:click={openMenu}      bind:element={buttonElement}      slot="buttons"     >
function create_default_slot_1(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", "M8.36612 16.1161C7.87796 16.6043 7.87796 17.3957 8.36612 17.8839L23.1161 32.6339C23.6043 33.122 24.3957 33.122 24.8839 32.6339L39.6339 17.8839C40.122 17.3957 40.122 16.6043 39.6339 16.1161C39.1457 15.628 38.3543 15.628 37.8661 16.1161L24 29.9822L10.1339 16.1161C9.64573 15.628 8.85427 15.628 8.36612 16.1161Z");
			add_location(path, file, 243, 5, 9084);
			attr_dev(svg, "aria-hidden", "true");
			attr_dev(svg, "class", "combo-box-icon svelte-1iqhotm");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "48");
			attr_dev(svg, "height", "48");
			attr_dev(svg, "viewBox", "0 0 48 48");
			add_location(svg, file, 235, 4, 8910);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(227:3) <TextBoxButton      aria-expanded={open}      aria-label=\\\"Open dropdown\\\"      aria-controls={dropdownId}      class=\\\"combo-box-dropdown-button\\\"      on:click={openMenu}      bind:element={buttonElement}      slot=\\\"buttons\\\"     >",
		ctx
	});

	return block;
}

// (227:3) 
function create_buttons_slot(ctx) {
	let textboxbutton;
	let updating_element;
	let current;

	function textboxbutton_element_binding(value) {
		/*textboxbutton_element_binding*/ ctx[31](value);
	}

	let textboxbutton_props = {
		"aria-expanded": /*open*/ ctx[1],
		"aria-label": "Open dropdown",
		"aria-controls": /*dropdownId*/ ctx[19],
		class: "combo-box-dropdown-button",
		slot: "buttons",
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	};

	if (/*buttonElement*/ ctx[7] !== void 0) {
		textboxbutton_props.element = /*buttonElement*/ ctx[7];
	}

	textboxbutton = new TextBoxButton({
			props: textboxbutton_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(textboxbutton, 'element', textboxbutton_element_binding));
	textboxbutton.$on("click", /*openMenu*/ ctx[21]);

	const block = {
		c: function create() {
			create_component(textboxbutton.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(textboxbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textboxbutton_changes = {};
			if (dirty[0] & /*open*/ 2) textboxbutton_changes["aria-expanded"] = /*open*/ ctx[1];

			if (dirty[1] & /*$$scope*/ 65536) {
				textboxbutton_changes.$$scope = { dirty, ctx };
			}

			if (!updating_element && dirty[0] & /*buttonElement*/ 128) {
				updating_element = true;
				textboxbutton_changes.element = /*buttonElement*/ ctx[7];
				add_flush_callback(() => updating_element = false);
			}

			textboxbutton.$set(textboxbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textboxbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textboxbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textboxbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_buttons_slot.name,
		type: "slot",
		source: "(227:3) ",
		ctx
	});

	return block;
}

// (283:1) {#if !disabled && items.length > 0}
function create_if_block(ctx) {
	let t0;
	let input;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block = /*open*/ ctx[1] && create_if_block_1(ctx);
	const default_slot_template = /*#slots*/ ctx[27].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[47], null);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t0 = space();
			input = element("input");
			t1 = space();
			if (default_slot) default_slot.c();
			attr_dev(input, "type", "hidden");
			attr_dev(input, "aria-hidden", "true");
			add_location(input, file, 313, 2, 11343);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, input, anchor);
			/*input_binding*/ ctx[43](input);
			set_input_value(input, /*value*/ ctx[0]);
			insert_dev(target, t1, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[44]),
					listen_dev(input, "change", /*change_handler_1*/ ctx[28], false, false, false),
					listen_dev(input, "input", /*input_handler_1*/ ctx[29], false, false, false),
					listen_dev(input, "beforeinput", /*beforeinput_handler_1*/ ctx[30], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*open*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*open*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty[0] & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 65536)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[47],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[47])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[47], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(input);
			/*input_binding*/ ctx[43](null);
			if (detaching) detach_dev(t1);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(283:1) {#if !disabled && items.length > 0}",
		ctx
	});

	return block;
}

// (284:2) {#if open}
function create_if_block_1(ctx) {
	let ul;
	let ul_aria_activedescendant_value;
	let ul_class_value;
	let current;
	let mounted;
	let dispose;
	let each_value = /*items*/ ctx[9];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(ul, "id", /*dropdownId*/ ctx[19]);
			attr_dev(ul, "aria-labelledby", /*buttonId*/ ctx[18]);

			attr_dev(ul, "aria-activedescendant", ul_aria_activedescendant_value = /*editable*/ ctx[10]
			? undefined
			: `${/*dropdownId*/ ctx[19]}-item-${/*items*/ ctx[9].indexOf(/*selection*/ ctx[13])}`);

			attr_dev(ul, "role", "listbox");

			attr_dev(ul, "class", ul_class_value = "combo-box-dropdown direction-" + (!/*editable*/ ctx[10]
			? /*menuGrowDirection*/ ctx[16] ?? 'center'
			: 'top') + " svelte-1iqhotm");

			set_style(ul, "--fds-menu-offset", /*menuOffset*/ ctx[15] + "px");
			set_style(ul, "scroll-behavior", "auto");
			add_location(ul, file, 284, 3, 10557);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			/*ul_binding*/ ctx[41](ul);
			current = true;

			if (!mounted) {
				dispose = listen_dev(ul, "blur", /*blur_handler*/ ctx[42], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*items, value, dropdownId, handleKeyboardNavigation, selectItem*/ 5767681) {
				each_value = /*items*/ ctx[9];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty[0] & /*editable, items, selection*/ 9728 && ul_aria_activedescendant_value !== (ul_aria_activedescendant_value = /*editable*/ ctx[10]
			? undefined
			: `${/*dropdownId*/ ctx[19]}-item-${/*items*/ ctx[9].indexOf(/*selection*/ ctx[13])}`)) {
				attr_dev(ul, "aria-activedescendant", ul_aria_activedescendant_value);
			}

			if (!current || dirty[0] & /*editable, menuGrowDirection*/ 66560 && ul_class_value !== (ul_class_value = "combo-box-dropdown direction-" + (!/*editable*/ ctx[10]
			? /*menuGrowDirection*/ ctx[16] ?? 'center'
			: 'top') + " svelte-1iqhotm")) {
				attr_dev(ul, "class", ul_class_value);
			}

			if (!current || dirty[0] & /*menuOffset*/ 32768) {
				set_style(ul, "--fds-menu-offset", /*menuOffset*/ ctx[15] + "px");
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
			/*ul_binding*/ ctx[41](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(284:2) {#if open}",
		ctx
	});

	return block;
}

// (300:5) <ComboBoxItem        role="option"        selected={item.value === value}        disabled={item.disabled}        id="{dropdownId}-item-{i}"        on:keydown={handleKeyboardNavigation}        on:click={() => selectItem(item)}       >
function create_default_slot(ctx) {
	let t0_value = /*item*/ ctx[52].name + "";
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*items*/ 512 && t0_value !== (t0_value = /*item*/ ctx[52].name + "")) set_data_dev(t0, t0_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(300:5) <ComboBoxItem        role=\\\"option\\\"        selected={item.value === value}        disabled={item.disabled}        id=\\\"{dropdownId}-item-{i}\\\"        on:keydown={handleKeyboardNavigation}        on:click={() => selectItem(item)}       >",
		ctx
	});

	return block;
}

// (299:4) {#each items as item, i}
function create_each_block(ctx) {
	let comboboxitem;
	let current;

	function click_handler() {
		return /*click_handler*/ ctx[40](/*item*/ ctx[52]);
	}

	comboboxitem = new ComboBoxItem({
			props: {
				role: "option",
				selected: /*item*/ ctx[52].value === /*value*/ ctx[0],
				disabled: /*item*/ ctx[52].disabled,
				id: "" + (/*dropdownId*/ ctx[19] + "-item-" + /*i*/ ctx[54]),
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	comboboxitem.$on("keydown", /*handleKeyboardNavigation*/ ctx[22]);
	comboboxitem.$on("click", click_handler);

	const block = {
		c: function create() {
			create_component(comboboxitem.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(comboboxitem, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const comboboxitem_changes = {};
			if (dirty[0] & /*items, value*/ 513) comboboxitem_changes.selected = /*item*/ ctx[52].value === /*value*/ ctx[0];
			if (dirty[0] & /*items*/ 512) comboboxitem_changes.disabled = /*item*/ ctx[52].disabled;

			if (dirty[0] & /*items*/ 512 | dirty[1] & /*$$scope*/ 65536) {
				comboboxitem_changes.$$scope = { dirty, ctx };
			}

			comboboxitem.$set(comboboxitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(comboboxitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(comboboxitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(comboboxitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(299:4) {#each items as item, i}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t;
	let div_class_value;
	let forwardEvents_action;
	let externalMouseEvents_action;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_2, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*editable*/ ctx[10]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1]);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = !/*disabled*/ ctx[11] && /*items*/ ctx[9].length > 0 && create_if_block(ctx);

	let div_levels = [
		{
			class: div_class_value = "combo-box " + /*className*/ ctx[12]
		},
		/*$$restProps*/ ctx[26]
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			set_attributes(div, div_data);
			toggle_class(div, "disabled", /*disabled*/ ctx[11]);
			toggle_class(div, "editable", /*editable*/ ctx[10]);
			toggle_class(div, "open", /*open*/ ctx[1]);
			toggle_class(div, "svelte-1iqhotm", true);
			add_location(div, file, 190, 0, 7823);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t);
			if (if_block1) if_block1.m(div, null);
			/*div_binding*/ ctx[46](div);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[17].call(null, div)),
					action_destroyer(externalMouseEvents_action = externalMouseEvents.call(null, div, { type: "mousedown" })),
					listen_dev(div, "outermousedown", /*outermousedown_handler*/ ctx[45], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, t);
			}

			if (!/*disabled*/ ctx[11] && /*items*/ ctx[9].length > 0) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*disabled, items*/ 2560) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*className*/ 4096 && div_class_value !== (div_class_value = "combo-box " + /*className*/ ctx[12])) && { class: div_class_value },
				dirty[0] & /*$$restProps*/ 67108864 && /*$$restProps*/ ctx[26]
			]));

			toggle_class(div, "disabled", /*disabled*/ ctx[11]);
			toggle_class(div, "editable", /*editable*/ ctx[10]);
			toggle_class(div, "open", /*open*/ ctx[1]);
			toggle_class(div, "svelte-1iqhotm", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			/*div_binding*/ ctx[46](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const maxItems = 14; // 504 (`max-block-size` in ComboBox.scss) / 36 (itemHeight)

function instance($$self, $$props, $$invalidate) {
	let selectableItems;
	let selection;
	let menuGrowDirection;

	const omit_props_names = [
		"value","searchValue","placeholder","items","editable","disabled","open","class","inputElement","searchInputElement","containerElement","menuElement","buttonElement"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ComboBox', slots, ['default']);
	let { value = undefined } = $$props;
	let { searchValue = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { items = [] } = $$props;
	let { editable = false } = $$props;
	let { disabled = false } = $$props;
	let { open = false } = $$props;
	let { class: className = "" } = $$props;
	let { inputElement = null } = $$props;
	let { searchInputElement = null } = $$props;
	let { containerElement = null } = $$props;
	let { menuElement = null } = $$props;
	let { buttonElement = null } = $$props;
	const forwardEvents = createEventForwarder(get_current_component(), ["open", "close", "select", "change", "input", "beforeinput", "keydown"]);
	const dispatch = createEventDispatcher();
	const buttonId = uid("fds-combo-box-button-");
	const dropdownId = uid("fds-combo-box-dropdown-");
	let inputFocused = false;
	let itemHeight = 36;

	let menuOffset = itemHeight * -(selection
	? items.indexOf(selection)
	: Math.floor(items.length > maxItems
		? maxItems / 2
		: items.length / 2));

	onMount(() => {
		if (!searchValue) $$invalidate(3, searchValue = value);
	});

	function updateOffset(target) {
		requestAnimationFrame(() => {
			const { top: containerTop } = containerElement.getBoundingClientRect();
			const { top: targetTop } = target.getBoundingClientRect();
			$$invalidate(15, menuOffset += containerTop - targetTop);
		});
	}

	function selectItem(item) {
		if (item.disabled) return;
		$$invalidate(0, value = item.value);
		$$invalidate(3, searchValue = item.name);
		$$invalidate(1, open = false);
		if (containerElement && !editable) containerElement.children[0].focus();
	}

	async function openMenu() {
		$$invalidate(1, open = !open);
		await tick();
		if (editable && searchInputElement) searchInputElement.focus();
		if (menuElement && selection) updateOffset(menuElement.children[items.indexOf(selection)]);
	}

	async function handleKeyboardNavigation(event) {
		const { key } = event;
		event.stopPropagation();
		const editableClosed = editable && !open;

		// Conditions for closing the menu.
		if (key === "Tab" || key === "Esc" || key === "Escape") $$invalidate(1, open = false);

		// Oh boy, here we go...
		if (key === "ArrowDown" && !editableClosed && !(items.indexOf(selection) >= items.length - 1)) {
			$$invalidate(0, value = selectableItems[selectableItems.indexOf(selection) + 1].value); // If down arrow is pressed, check current selection and move to next non-disabled item.
			$$invalidate(3, searchValue = selectableItems[selectableItems.indexOf(selection) + 1].name);
		} else if (key === "ArrowUp" && !editableClosed && !(items.indexOf(selection) <= 0)) {
			$$invalidate(0, value = selectableItems[selectableItems.indexOf(selection) - 1].value); // Do the same with up arrow.
			$$invalidate(3, searchValue = selectableItems[selectableItems.indexOf(selection) - 1].name);
		} else if (key === "Home") {
			$$invalidate(0, value = selectableItems[0].value); // If home is pressed, move to first non-disabled item.
			$$invalidate(3, searchValue = selectableItems[0].name);
		} else if (key === "End") {
			$$invalidate(0, value = selectableItems[selectableItems.length - 1].value); // If end is pressed, move to last non-disabled item.
			$$invalidate(3, searchValue = selectableItems[selectableItems.length - 1].name);
		} else if (open && (key === "Enter" || key === " ")) {
			event.preventDefault();
			selectItem(selection); // Select item when the enter/space key is pressed and the menu is open
		} else if (searchInputElement && document.activeElement !== searchInputElement) {
			searchInputElement.focus(); // If the input element has lost focus, regain it.
		}

		// Prevent the browser's default scrolling behavior for these keys
		if (key === "ArrowDown" || key === "ArrowUp" || key === "Home" || key === "End") event.preventDefault();

		// Keybindings for opening the menu when in editable mode using arrow keys
		if (key === "ArrowDown" || key === "ArrowUp" && editable) {
			if (open) {
				await tick();

				searchInputElement === null || searchInputElement === void 0
				? void 0
				: searchInputElement.select(); // Select text when an item is chosen.
			} else {
				$$invalidate(1, open = true);
			}
		}
	}

	function handleInputFocus() {
		searchInputElement.select();
		$$invalidate(14, inputFocused = true);
	}

	function handleInputBlur() {
		$$invalidate(14, inputFocused = false);
	}

	function handleInput(event) {
		const match = selectableItems.find(i => i.name.toLowerCase().startsWith(searchValue.toLowerCase()));
		if (!match) $$invalidate(0, value = null);

		if (match && event.inputType === "insertText" && searchValue.trim() !== "") {
			$$invalidate(5, searchInputElement.value = match.name, searchInputElement);
			searchInputElement.setSelectionRange(searchValue.length, match.name.length);
		}

		if (match && !match.disabled) $$invalidate(0, value = match.value);
		$$invalidate(3, searchValue = searchInputElement.value);
	}

	function change_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function beforeinput_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function textboxbutton_element_binding(value) {
		buttonElement = value;
		$$invalidate(7, buttonElement);
	}

	function textbox_value_binding(value) {
		searchValue = value;
		$$invalidate(3, searchValue);
	}

	function textbox_inputElement_binding(value) {
		searchInputElement = value;
		$$invalidate(5, searchInputElement);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeinput_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function button_element_binding(value) {
		buttonElement = value;
		$$invalidate(7, buttonElement);
	}

	function keydown_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler = item => selectItem(item);

	function ul_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			menuElement = $$value;
			$$invalidate(2, menuElement);
		});
	}

	const blur_handler = () => $$invalidate(1, open = false);

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputElement = $$value;
			$$invalidate(4, inputElement);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const outermousedown_handler = () => {
		if (open) $$invalidate(1, open = false);
	};

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			containerElement = $$value;
			$$invalidate(6, containerElement);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ('searchValue' in $$new_props) $$invalidate(3, searchValue = $$new_props.searchValue);
		if ('placeholder' in $$new_props) $$invalidate(8, placeholder = $$new_props.placeholder);
		if ('items' in $$new_props) $$invalidate(9, items = $$new_props.items);
		if ('editable' in $$new_props) $$invalidate(10, editable = $$new_props.editable);
		if ('disabled' in $$new_props) $$invalidate(11, disabled = $$new_props.disabled);
		if ('open' in $$new_props) $$invalidate(1, open = $$new_props.open);
		if ('class' in $$new_props) $$invalidate(12, className = $$new_props.class);
		if ('inputElement' in $$new_props) $$invalidate(4, inputElement = $$new_props.inputElement);
		if ('searchInputElement' in $$new_props) $$invalidate(5, searchInputElement = $$new_props.searchInputElement);
		if ('containerElement' in $$new_props) $$invalidate(6, containerElement = $$new_props.containerElement);
		if ('menuElement' in $$new_props) $$invalidate(2, menuElement = $$new_props.menuElement);
		if ('buttonElement' in $$new_props) $$invalidate(7, buttonElement = $$new_props.buttonElement);
		if ('$$scope' in $$new_props) $$invalidate(47, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		tick,
		get_current_component,
		onMount,
		createEventForwarder,
		externalMouseEvents,
		uid,
		ComboBoxItem,
		Button,
		TextBox,
		TextBoxButton,
		value,
		searchValue,
		placeholder,
		items,
		editable,
		disabled,
		open,
		className,
		inputElement,
		searchInputElement,
		containerElement,
		menuElement,
		buttonElement,
		forwardEvents,
		dispatch,
		buttonId,
		dropdownId,
		inputFocused,
		itemHeight,
		maxItems,
		menuOffset,
		updateOffset,
		selectItem,
		openMenu,
		handleKeyboardNavigation,
		handleInputFocus,
		handleInputBlur,
		handleInput,
		selectableItems,
		selection,
		menuGrowDirection
	});

	$$self.$inject_state = $$new_props => {
		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
		if ('searchValue' in $$props) $$invalidate(3, searchValue = $$new_props.searchValue);
		if ('placeholder' in $$props) $$invalidate(8, placeholder = $$new_props.placeholder);
		if ('items' in $$props) $$invalidate(9, items = $$new_props.items);
		if ('editable' in $$props) $$invalidate(10, editable = $$new_props.editable);
		if ('disabled' in $$props) $$invalidate(11, disabled = $$new_props.disabled);
		if ('open' in $$props) $$invalidate(1, open = $$new_props.open);
		if ('className' in $$props) $$invalidate(12, className = $$new_props.className);
		if ('inputElement' in $$props) $$invalidate(4, inputElement = $$new_props.inputElement);
		if ('searchInputElement' in $$props) $$invalidate(5, searchInputElement = $$new_props.searchInputElement);
		if ('containerElement' in $$props) $$invalidate(6, containerElement = $$new_props.containerElement);
		if ('menuElement' in $$props) $$invalidate(2, menuElement = $$new_props.menuElement);
		if ('buttonElement' in $$props) $$invalidate(7, buttonElement = $$new_props.buttonElement);
		if ('inputFocused' in $$props) $$invalidate(14, inputFocused = $$new_props.inputFocused);
		if ('itemHeight' in $$props) itemHeight = $$new_props.itemHeight;
		if ('menuOffset' in $$props) $$invalidate(15, menuOffset = $$new_props.menuOffset);
		if ('selectableItems' in $$props) selectableItems = $$new_props.selectableItems;
		if ('selection' in $$props) $$invalidate(13, selection = $$new_props.selection);
		if ('menuGrowDirection' in $$props) $$invalidate(16, menuGrowDirection = $$new_props.menuGrowDirection);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*items*/ 512) {
			$: selectableItems = items.filter(item => !item.disabled);
		}

		if ($$self.$$.dirty[0] & /*items, value*/ 513) {
			$: $$invalidate(13, selection = items.find(i => i.value === value));
		}

		if ($$self.$$.dirty[0] & /*menuElement, editable, selection, items*/ 9732) {
			$: if (menuElement && menuElement.children.length > 0 && !editable) {
				if (selection) {
					menuElement.children[items.indexOf(selection)].focus();
				} else {
					menuElement.children[0].focus();
				}
			}
		}

		if ($$self.$$.dirty[0] & /*items, open*/ 514) {
			$: if (items.length > 0) {
				if (open) {
					dispatch("open");
				} else {
					dispatch("close");
				}
			}
		}

		if ($$self.$$.dirty[0] & /*selection*/ 8192) {
			$: dispatch("select", selection);
		}

		if ($$self.$$.dirty[0] & /*selection, items*/ 8704) {
			$: $$invalidate(16, menuGrowDirection = !selection || items[items.indexOf(selection)] === items[Math.floor(items.length / 2)]
			? "center"
			: items.indexOf(selection) < items.indexOf(items[Math.floor(items.length / 2)])
				? "top"
				: "bottom");
		}
	};

	return [
		value,
		open,
		menuElement,
		searchValue,
		inputElement,
		searchInputElement,
		containerElement,
		buttonElement,
		placeholder,
		items,
		editable,
		disabled,
		className,
		selection,
		inputFocused,
		menuOffset,
		menuGrowDirection,
		forwardEvents,
		buttonId,
		dropdownId,
		selectItem,
		openMenu,
		handleKeyboardNavigation,
		handleInputFocus,
		handleInputBlur,
		handleInput,
		$$restProps,
		slots,
		change_handler_1,
		input_handler_1,
		beforeinput_handler_1,
		textboxbutton_element_binding,
		textbox_value_binding,
		textbox_inputElement_binding,
		change_handler,
		input_handler,
		beforeinput_handler,
		keydown_handler,
		button_element_binding,
		keydown_handler_1,
		click_handler,
		ul_binding,
		blur_handler,
		input_binding,
		input_input_handler,
		outermousedown_handler,
		div_binding,
		$$scope
	];
}

class ComboBox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				value: 0,
				searchValue: 3,
				placeholder: 8,
				items: 9,
				editable: 10,
				disabled: 11,
				open: 1,
				class: 12,
				inputElement: 4,
				searchInputElement: 5,
				containerElement: 6,
				menuElement: 2,
				buttonElement: 7
			},
			add_css,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ComboBox",
			options,
			id: create_fragment.name
		});
	}

	get value() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchValue() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchValue(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get editable() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set editable(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputElement() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputElement(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchInputElement() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchInputElement(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get containerElement() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set containerElement(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get menuElement() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set menuElement(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buttonElement() {
		throw new Error("<ComboBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buttonElement(value) {
		throw new Error("<ComboBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ComboBox;