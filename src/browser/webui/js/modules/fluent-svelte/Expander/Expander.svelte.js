/* Expander.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	action_destroyer,
	add_location,
	append_dev,
	append_styles,
	assign,
	attr_dev,
	binding_callbacks,
	check_outros,
	compute_rest_props,
	compute_slots,
	create_slot,
	detach_dev,
	dispatch_dev,
	element,
	exclude_internal_props,
	get_all_dirty_from_scope,
	get_slot_changes,
	get_spread_update,
	group_outros,
	init,
	insert_dev,
	listen_dev,
	noop,
	run_all,
	safe_not_equal,
	set_attributes,
	space,
	svg_element,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base,
	validate_dynamic_element,
	validate_slots,
	validate_void_dynamic_element
} from "nereid://.svelte/internal/index.mjs";

import { createEventDispatcher } from "nereid://.svelte/index.mjs";
import { get_current_component } from "nereid://.svelte/internal/index.mjs";
import { createEventForwarder, uid } from "../internal.js";
const file = "Expander.svelte";

function add_css(target) {
	append_styles(target, "svelte-1p16tfx", ".expander.svelte-1p16tfx.svelte-1p16tfx{border-radius:var(--fds-control-corner-radius);color:var(--fds-text-primary);display:flex;flex-direction:column;inline-size:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.expander.direction-down.svelte-1p16tfx .expander-content.svelte-1p16tfx{-webkit-border-before:none;border-block-start:none;border-radius:var(--fds-control-corner-radius);border-start-end-radius:0;border-start-start-radius:0;transform:translateY(-100%)}.expander.direction-down.expanded.svelte-1p16tfx .expander-header.svelte-1p16tfx{border-end-end-radius:0;border-end-start-radius:0;border-radius:var(--fds-control-corner-radius)}.expander.direction-up.svelte-1p16tfx .expander-content.svelte-1p16tfx{border-bottom:none;border-end-end-radius:0;border-end-start-radius:0;border-radius:var(--fds-control-corner-radius);transform:translateY(100%)}.expander.direction-up.svelte-1p16tfx .expander-content-anchor.svelte-1p16tfx{order:-1}.expander.direction-up.expanded.svelte-1p16tfx .expander-header.svelte-1p16tfx{border-radius:var(--fds-control-corner-radius);border-start-end-radius:0;border-start-start-radius:0}.expander.expanded.svelte-1p16tfx .expander-content.svelte-1p16tfx{transform:none;transition:var(--fds-control-slow-duration) var(--fds-control-fast-out-slow-in-easing) transform}.expander.expanded.svelte-1p16tfx .expander-content-anchor.svelte-1p16tfx{max-block-size:6.019999999999999e+23vmax;transition:none}.expander.expanded.svelte-1p16tfx .expander-chevron svg.svelte-1p16tfx{transform:rotate(180deg)}.expander-icon.svelte-1p16tfx.svelte-1p16tfx{-webkit-margin-end:16px;block-size:16px;color:var(--fds-text-primary);flex:0 0 auto;inline-size:16px;margin-inline-end:16px}.expander-icon.svelte-1p16tfx>svg{fill:currentColor;block-size:auto;inline-size:16px}.expander-header.svelte-1p16tfx.svelte-1p16tfx{-webkit-padding-start:16px;align-items:center;background-clip:padding-box;background-color:var(--fds-card-background-default);border:1px solid var(--fds-card-stroke-default);border-radius:var(--fds-control-corner-radius);box-sizing:border-box;display:flex;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;outline:none;padding:8px;padding-inline-start:16px;text-align:start;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.expander-header-title.svelte-1p16tfx.svelte-1p16tfx{flex:1 1 auto}.expander-header.svelte-1p16tfx.svelte-1p16tfx:focus-visible{box-shadow:var(--fds-focus-stroke)}.expander-header.svelte-1p16tfx:hover .expander-chevron.svelte-1p16tfx{background-color:var(--fds-subtle-fill-secondary)}.expander-header.svelte-1p16tfx:active .expander-chevron.svelte-1p16tfx{background-color:var(--fds-subtle-fill-tertiary);color:var(--fds-text-secondary)}.expander-chevron.svelte-1p16tfx.svelte-1p16tfx{-webkit-margin-start:20px;align-items:center;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--fds-subtle-fill-transparent);block-size:32px;border:none;border-radius:var(--fds-control-corner-radius);color:var(--fds-text-primary);display:flex;flex:0 0 auto;inline-size:32px;justify-content:center;margin-inline-start:20px;outline:none}.expander-chevron.svelte-1p16tfx.svelte-1p16tfx:focus-visible{box-shadow:var(--fds-focus-stroke)}.expander-chevron.svelte-1p16tfx svg.svelte-1p16tfx{fill:currentColor;block-size:12px;inline-size:12px;transition:calc(var(--fds-control-faster-duration)*1.2) linear transform var(--fds-control-faster-duration)}.expander-content.svelte-1p16tfx.svelte-1p16tfx{background-clip:padding-box;background-color:var(--fds-card-background-secondary);border:1px solid var(--fds-card-stroke-default);font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;padding:16px;transition:var(--fds-control-fast-duration) cubic-bezier(1,1,0,1) transform;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.expander-content-anchor.svelte-1p16tfx.svelte-1p16tfx{max-height:0;overflow:hidden;position:relative;transition:0ms linear var(--fds-control-slow-duration) max-height}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXhwYW5kZXIuc3ZlbHRlIiwic291cmNlcyI6WyJFeHBhbmRlci5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCA+Ly8gVE9ETzogcHJvZ3Jlc3NpdmVseSBlbmhhbmNlIHRoaXNcclxuaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG5pbXBvcnQgeyBnZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tIFwic3ZlbHRlL2ludGVybmFsXCI7XHJcbmltcG9ydCB7IGNyZWF0ZUV2ZW50Rm9yd2FyZGVyLCB1aWQgfSBmcm9tIFwiLi4vaW50ZXJuYWxcIjtcclxuLyoqIERldGVybWluZXMgd2hldGhlciB0aGUgZXhwYW5kZXIgaXMgZXhwYW5kZWQgKG9wZW4pIG9yIG5vdC4gKi9cclxuZXhwb3J0IGxldCBleHBhbmRlZCA9IGZhbHNlO1xyXG4vKiogRGV0ZXJtaW5lcyB0aGUgZGlyZWN0aW9uIHRoYXQgdGhlIGV4cGFuZGVyIHdpbGwgZXh0ZW5kIHRvLiAqL1xyXG5leHBvcnQgbGV0IGRpcmVjdGlvbiA9IFwiZG93blwiO1xyXG4vLyBzdmVsdGUtaWdub3JlIHVudXNlZC1leHBvcnQtbGV0XHJcbi8qKiBEZXRlcm1pbmVzIHRoZSBleHBhbmRlciBoZWFkZXIncyBzZW1hbnRpYyBIVE1MIGhlYWRpbmcgdGFnIChoMS1oNikuICovXHJcbmV4cG9ydCBsZXQgaGVhZGluZ0xldmVsID0gMztcclxuLyoqIFNwZWNpZmllcyBhIGN1c3RvbSBjbGFzcyBuYW1lIGZvciB0aGUgZXhwYW5kZXIuICovXHJcbmxldCBjbGFzc05hbWUgPSBcIlwiO1xyXG5leHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcclxuLyoqIE9idGFpbnMgYSBib3VuZCBET00gcmVmZXJlbmNlIHRvIHRoZSBleHBhbmRlcidzIGNvbnRhaW5lciBlbGVtZW50LiAqL1xyXG5leHBvcnQgbGV0IGNvbnRhaW5lckVsZW1lbnQgPSBudWxsO1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIGV4cGFuZGVyJ3MgaGVhZGVyIGJ1dHRvbiBlbGVtZW50LiAqL1xyXG5leHBvcnQgbGV0IGhlYWRlckVsZW1lbnQgPSBudWxsO1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIGV4cGFuZGVyJ3MgY29udGVudCBjb250YWluZXIuICovXHJcbmV4cG9ydCBsZXQgY29udGVudEVsZW1lbnQgPSBudWxsO1xyXG5jb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xyXG5jb25zdCBmb3J3YXJkRXZlbnRzID0gY3JlYXRlRXZlbnRGb3J3YXJkZXIoZ2V0X2N1cnJlbnRfY29tcG9uZW50KCksIFtcImV4cGFuZFwiLCBcImNvbGxhcHNlXCJdKTtcclxuY29uc3QgaGVhZGVySWQgPSB1aWQoXCJmZHMtZXhwYW5kZXItaGVhZGVyLVwiKTtcclxuY29uc3QgY29udGVudElkID0gdWlkKFwiZmRzLWV4cGFuZGVyLWNvbnRlbnQtXCIpO1xyXG4kOiBpZiAoZXhwYW5kZWQpIHtcclxuICAgIGRpc3BhdGNoKFwiZXhwYW5kXCIpO1xyXG59XHJcbmVsc2Uge1xyXG4gICAgZGlzcGF0Y2goXCJjb2xsYXBzZVwiKTtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVLZXlkb3duKHsga2V5IH0pIHtcclxuICAgIGlmIChrZXkgPT09IFwiRW50ZXJcIiB8fCBrZXkgPT09IFwiIFwiKSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBleHBhbmRlZCA9ICFleHBhbmRlZDtcclxuICAgIH1cclxufVxyXG48L3NjcmlwdD5cblxuPCEtLVxuQGNvbXBvbmVudFxuRXhwYW5kZXJzIGFyZSBjb250cm9scyB0aGF0IGRpc3BsYXkgYSBoZWFkZXIgYW5kIGEgY29sbGFwc2FibGUgY29udGVudCBhcmVhLiBUaGUgY29udGVudCBhcmVhIGNhbiBiZSBleHBhbmRlZCBjbGlja2luZyBvbiB0aGUgaGVhZGVyLiBbRG9jc10oaHR0cHM6Ly9mbHVlbnQtc3ZlbHRlLnZlcmNlbC5hcHAvZG9jcy9jb21wb25lbnRzL2V4cGFuZGVyKVxuLSBVc2FnZTpcbiAgICBgYGB0c3hcbiAgICA8RXhwYW5kZXI+XG4gICAgICAgIEhlYWRlclxuICAgICAgICA8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJjb250ZW50XCI+XG4gICAgICAgICAgICBDb250ZW50XG4gICAgICAgIDwvc3ZlbHRlOmZyYWdtZW50PlxuICAgIDwvRXhwYW5kZXI+XG4gICAgYGBgXG4tLT5cbjxkaXZcblx0dXNlOmZvcndhcmRFdmVudHNcblx0Y2xhc3M9XCJleHBhbmRlciBkaXJlY3Rpb24te2RpcmVjdGlvbn0ge2NsYXNzTmFtZX1cIlxuXHRyb2xlPVwicmVnaW9uXCJcblx0Y2xhc3M6ZXhwYW5kZWRcblx0YmluZDp0aGlzPXtjb250YWluZXJFbGVtZW50fVxuXHR7Li4uJCRyZXN0UHJvcHN9XG4+XG5cdDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiaFwiPlxuXHRcdDxkaXZcblx0XHRcdHJvbGU9XCJidXR0b25cIlxuXHRcdFx0aWQ9e2hlYWRlcklkfVxuXHRcdFx0YXJpYS1jb250cm9scz17Y29udGVudElkfVxuXHRcdFx0Y2xhc3M9XCJleHBhbmRlci1oZWFkZXJcIlxuXHRcdFx0YXJpYS1leHBhbmRlZD17ZXhwYW5kZWR9XG5cdFx0XHR0YWJpbmRleD1cIjBcIlxuXHRcdFx0YmluZDp0aGlzPXtoZWFkZXJFbGVtZW50fVxuXHRcdFx0b246a2V5ZG93bj17aGFuZGxlS2V5ZG93bn1cblx0XHRcdG9uOmNsaWNrPXsoKSA9PiAoZXhwYW5kZWQgPSAhZXhwYW5kZWQpfVxuXHRcdD5cblx0XHRcdHsjaWYgJCRzbG90cy5pY29ufVxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiZXhwYW5kZXItaWNvblwiPlxuXHRcdFx0XHRcdDxzbG90IG5hbWU9XCJpY29uXCIgLz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR7L2lmfVxuXHRcdFx0PHNwYW4gY2xhc3M9XCJleHBhbmRlci1oZWFkZXItdGl0bGVcIj5cblx0XHRcdFx0PHNsb3QgLz5cblx0XHRcdDwvc3Bhbj5cblx0XHRcdDxidXR0b25cblx0XHRcdFx0Y2xhc3M9XCJleHBhbmRlci1jaGV2cm9uXCJcblx0XHRcdFx0dGFiaW5kZXg9XCItMVwiXG5cdFx0XHRcdGlkPXtjb250ZW50SWR9XG5cdFx0XHRcdGFyaWEtbGFiZWxsZWRieT17aGVhZGVySWR9XG5cdFx0XHQ+XG5cdFx0XHRcdDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCIxMlwiIHZpZXdCb3g9XCIwIDAgMTIgMTJcIj5cblx0XHRcdFx0XHR7I2lmIGRpcmVjdGlvbiA9PT0gXCJkb3duXCJ9XG5cdFx0XHRcdFx0XHQ8cGF0aFxuXHRcdFx0XHRcdFx0XHRmaWxsPVwiY3VycmVudENvbG9yXCJcblx0XHRcdFx0XHRcdFx0ZD1cIk0yLjE0NjQ1IDQuNjQ2NDVDMi4zNDE3MSA0LjQ1MTE4IDIuNjU4MjkgNC40NTExOCAyLjg1MzU1IDQuNjQ2NDVMNiA3Ljc5Mjg5TDkuMTQ2NDUgNC42NDY0NUM5LjM0MTcxIDQuNDUxMTggOS42NTgyOSA0LjQ1MTE4IDkuODUzNTUgNC42NDY0NUMxMC4wNDg4IDQuODQxNzEgMTAuMDQ4OCA1LjE1ODI5IDkuODUzNTUgNS4zNTM1NUw2LjM1MzU1IDguODUzNTVDNi4xNTgyOSA5LjA0ODgyIDUuODQxNzEgOS4wNDg4MiA1LjY0NjQ1IDguODUzNTVMMi4xNDY0NSA1LjM1MzU1QzEuOTUxMTggNS4xNTgyOSAxLjk1MTE4IDQuODQxNzEgMi4xNDY0NSA0LjY0NjQ1WlwiXG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0XHRcdDxwYXRoXG5cdFx0XHRcdFx0XHRcdGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuXHRcdFx0XHRcdFx0XHRkPVwiTTIuMTQ2NDUgNy4zNTM1NUMyLjM0MTcxIDcuNTQ4ODIgMi42NTgyOSA3LjU0ODgyIDIuODUzNTUgNy4zNTM1NUw2IDQuMjA3MTFMOS4xNDY0NSA3LjM1MzU1QzkuMzQxNzEgNy41NDg4MiA5LjY1ODI5IDcuNTQ4ODIgOS44NTM1NSA3LjM1MzU1QzEwLjA0ODggNy4xNTgyOSAxMC4wNDg4IDYuODQxNzEgOS44NTM1NSA2LjY0NjQ1TDYuMzUzNTUgMy4xNDY0NUM2LjE1ODI5IDIuOTUxMTggNS44NDE3MSAyLjk1MTE4IDUuNjQ2NDUgMy4xNDY0NUwyLjE0NjQ1IDYuNjQ2NDVDMS45NTExOCA2Ljg0MTcxIDEuOTUxMTggNy4xNTgyOSAyLjE0NjQ1IDcuMzUzNTVaXCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0PC9zdmc+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQ8L2Rpdj5cblx0PC9zdmVsdGU6ZWxlbWVudD5cblx0PGRpdiBjbGFzcz1cImV4cGFuZGVyLWNvbnRlbnQtYW5jaG9yXCI+XG5cdFx0PGRpdiBjbGFzcz1cImV4cGFuZGVyLWNvbnRlbnRcIiBiaW5kOnRoaXM9e2NvbnRlbnRFbGVtZW50fT5cblx0XHRcdDxzbG90IG5hbWU9XCJjb250ZW50XCIgLz5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj5cblxuPHN0eWxlID4uZXhwYW5kZXJ7Ym9yZGVyLXJhZGl1czp2YXIoLS1mZHMtY29udHJvbC1jb3JuZXItcmFkaXVzKTtjb2xvcjp2YXIoLS1mZHMtdGV4dC1wcmltYXJ5KTtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2lubGluZS1zaXplOjEwMCU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5leHBhbmRlci5kaXJlY3Rpb24tZG93biAuZXhwYW5kZXItY29udGVudHstd2Via2l0LWJvcmRlci1iZWZvcmU6bm9uZTtib3JkZXItYmxvY2stc3RhcnQ6bm9uZTtib3JkZXItcmFkaXVzOnZhcigtLWZkcy1jb250cm9sLWNvcm5lci1yYWRpdXMpO2JvcmRlci1zdGFydC1lbmQtcmFkaXVzOjA7Ym9yZGVyLXN0YXJ0LXN0YXJ0LXJhZGl1czowO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMDAlKX0uZXhwYW5kZXIuZGlyZWN0aW9uLWRvd24uZXhwYW5kZWQgLmV4cGFuZGVyLWhlYWRlcntib3JkZXItZW5kLWVuZC1yYWRpdXM6MDtib3JkZXItZW5kLXN0YXJ0LXJhZGl1czowO2JvcmRlci1yYWRpdXM6dmFyKC0tZmRzLWNvbnRyb2wtY29ybmVyLXJhZGl1cyl9LmV4cGFuZGVyLmRpcmVjdGlvbi11cCAuZXhwYW5kZXItY29udGVudHtib3JkZXItYm90dG9tOm5vbmU7Ym9yZGVyLWVuZC1lbmQtcmFkaXVzOjA7Ym9yZGVyLWVuZC1zdGFydC1yYWRpdXM6MDtib3JkZXItcmFkaXVzOnZhcigtLWZkcy1jb250cm9sLWNvcm5lci1yYWRpdXMpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDEwMCUpfS5leHBhbmRlci5kaXJlY3Rpb24tdXAgLmV4cGFuZGVyLWNvbnRlbnQtYW5jaG9ye29yZGVyOi0xfS5leHBhbmRlci5kaXJlY3Rpb24tdXAuZXhwYW5kZWQgLmV4cGFuZGVyLWhlYWRlcntib3JkZXItcmFkaXVzOnZhcigtLWZkcy1jb250cm9sLWNvcm5lci1yYWRpdXMpO2JvcmRlci1zdGFydC1lbmQtcmFkaXVzOjA7Ym9yZGVyLXN0YXJ0LXN0YXJ0LXJhZGl1czowfS5leHBhbmRlci5leHBhbmRlZCAuZXhwYW5kZXItY29udGVudHt0cmFuc2Zvcm06bm9uZTt0cmFuc2l0aW9uOnZhcigtLWZkcy1jb250cm9sLXNsb3ctZHVyYXRpb24pIHZhcigtLWZkcy1jb250cm9sLWZhc3Qtb3V0LXNsb3ctaW4tZWFzaW5nKSB0cmFuc2Zvcm19LmV4cGFuZGVyLmV4cGFuZGVkIC5leHBhbmRlci1jb250ZW50LWFuY2hvcnttYXgtYmxvY2stc2l6ZTo2LjAxOTk5OTk5OTk5OTk5OWUrMjN2bWF4O3RyYW5zaXRpb246bm9uZX0uZXhwYW5kZXIuZXhwYW5kZWQgLmV4cGFuZGVyLWNoZXZyb24gc3Zne3RyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKX0uZXhwYW5kZXI+aDN7ZGlzcGxheTpjb250ZW50c30uZXhwYW5kZXItaWNvbnstd2Via2l0LW1hcmdpbi1lbmQ6MTZweDtibG9jay1zaXplOjE2cHg7Y29sb3I6dmFyKC0tZmRzLXRleHQtcHJpbWFyeSk7ZmxleDowIDAgYXV0bztpbmxpbmUtc2l6ZToxNnB4O21hcmdpbi1pbmxpbmUtZW5kOjE2cHh9LmV4cGFuZGVyLWljb24+Omdsb2JhbChzdmcpe2ZpbGw6Y3VycmVudENvbG9yO2Jsb2NrLXNpemU6YXV0bztpbmxpbmUtc2l6ZToxNnB4fS5leHBhbmRlci1oZWFkZXJ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OjE2cHg7YWxpZ24taXRlbXM6Y2VudGVyO2JhY2tncm91bmQtY2xpcDpwYWRkaW5nLWJveDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZkcy1jYXJkLWJhY2tncm91bmQtZGVmYXVsdCk7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mZHMtY2FyZC1zdHJva2UtZGVmYXVsdCk7Ym9yZGVyLXJhZGl1czp2YXIoLS1mZHMtY29udHJvbC1jb3JuZXItcmFkaXVzKTtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpmbGV4O2ZvbnQtZmFtaWx5OnZhcigtLWZkcy1mb250LWZhbWlseS10ZXh0KTtmb250LXNpemU6dmFyKC0tZmRzLWJvZHktZm9udC1zaXplKTtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MjBweDtvdXRsaW5lOm5vbmU7cGFkZGluZzo4cHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MTZweDt0ZXh0LWFsaWduOnN0YXJ0Oy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uZXhwYW5kZXItaGVhZGVyLXRpdGxle2ZsZXg6MSAxIGF1dG99LmV4cGFuZGVyLWhlYWRlcjpmb2N1cy12aXNpYmxle2JveC1zaGFkb3c6dmFyKC0tZmRzLWZvY3VzLXN0cm9rZSl9LmV4cGFuZGVyLWhlYWRlcjpob3ZlciAuZXhwYW5kZXItY2hldnJvbntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZkcy1zdWJ0bGUtZmlsbC1zZWNvbmRhcnkpfS5leHBhbmRlci1oZWFkZXI6YWN0aXZlIC5leHBhbmRlci1jaGV2cm9ue2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLXN1YnRsZS1maWxsLXRlcnRpYXJ5KTtjb2xvcjp2YXIoLS1mZHMtdGV4dC1zZWNvbmRhcnkpfS5leHBhbmRlci1jaGV2cm9uey13ZWJraXQtbWFyZ2luLXN0YXJ0OjIwcHg7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtYXBwZWFyYW5jZTpub25lOy1tb3otYXBwZWFyYW5jZTpub25lO2FwcGVhcmFuY2U6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZkcy1zdWJ0bGUtZmlsbC10cmFuc3BhcmVudCk7YmxvY2stc2l6ZTozMnB4O2JvcmRlcjpub25lO2JvcmRlci1yYWRpdXM6dmFyKC0tZmRzLWNvbnRyb2wtY29ybmVyLXJhZGl1cyk7Y29sb3I6dmFyKC0tZmRzLXRleHQtcHJpbWFyeSk7ZGlzcGxheTpmbGV4O2ZsZXg6MCAwIGF1dG87aW5saW5lLXNpemU6MzJweDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbi1pbmxpbmUtc3RhcnQ6MjBweDtvdXRsaW5lOm5vbmV9LmV4cGFuZGVyLWNoZXZyb246Zm9jdXMtdmlzaWJsZXtib3gtc2hhZG93OnZhcigtLWZkcy1mb2N1cy1zdHJva2UpfS5leHBhbmRlci1jaGV2cm9uIHN2Z3tmaWxsOmN1cnJlbnRDb2xvcjtibG9jay1zaXplOjEycHg7aW5saW5lLXNpemU6MTJweDt0cmFuc2l0aW9uOmNhbGModmFyKC0tZmRzLWNvbnRyb2wtZmFzdGVyLWR1cmF0aW9uKSoxLjIpIGxpbmVhciB0cmFuc2Zvcm0gdmFyKC0tZmRzLWNvbnRyb2wtZmFzdGVyLWR1cmF0aW9uKX0uZXhwYW5kZXItY29udGVudHtiYWNrZ3JvdW5kLWNsaXA6cGFkZGluZy1ib3g7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtY2FyZC1iYWNrZ3JvdW5kLXNlY29uZGFyeSk7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mZHMtY2FyZC1zdHJva2UtZGVmYXVsdCk7Zm9udC1mYW1pbHk6dmFyKC0tZmRzLWZvbnQtZmFtaWx5LXRleHQpO2ZvbnQtc2l6ZTp2YXIoLS1mZHMtYm9keS1mb250LXNpemUpO2ZvbnQtd2VpZ2h0OjQwMDtsaW5lLWhlaWdodDoyMHB4O3BhZGRpbmc6MTZweDt0cmFuc2l0aW9uOnZhcigtLWZkcy1jb250cm9sLWZhc3QtZHVyYXRpb24pIGN1YmljLWJlemllcigxLDEsMCwxKSB0cmFuc2Zvcm07LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5leHBhbmRlci1jb250ZW50LWFuY2hvcnttYXgtaGVpZ2h0OjA7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO3RyYW5zaXRpb246MG1zIGxpbmVhciB2YXIoLS1mZHMtY29udHJvbC1zbG93LWR1cmF0aW9uKSBtYXgtaGVpZ2h0fTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNEdRLHVDQUFTLENBQUMsY0FBYyxJQUFJLDJCQUEyQixDQUFDLENBQUMsTUFBTSxJQUFJLGtCQUFrQixDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsZUFBZSxNQUFNLENBQUMsWUFBWSxJQUFJLENBQUMsb0JBQW9CLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxDQUFDLGdCQUFnQixJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsU0FBUyw4QkFBZSxDQUFDLGdDQUFpQixDQUFDLHNCQUFzQixJQUFJLENBQUMsbUJBQW1CLElBQUksQ0FBQyxjQUFjLElBQUksMkJBQTJCLENBQUMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLDBCQUEwQixDQUFDLENBQUMs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 */");
}

const get_content_slot_changes = dirty => ({});
const get_content_slot_context = ctx => ({});
const get_icon_slot_changes = dirty => ({});
const get_icon_slot_context = ctx => ({});

// (72:3) {#if $$slots.icon}
function create_if_block_3(ctx) {
	let current;

	const block = {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(72:3) {#if $$slots.icon}",
		ctx
	});

	return block;
}

// (92:5) {:else}
function create_else_block_1(ctx) {
	const block = { c: noop, m: noop, d: noop };

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(92:5) {:else}",
		ctx
	});

	return block;
}

// (87:5) {#if direction === "down"}
function create_if_block_2(ctx) {
	const block = { c: noop, m: noop, d: noop };

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(87:5) {#if direction === \\\"down\\\"}",
		ctx
	});

	return block;
}

// (72:3) {#if $$slots.icon}
function create_if_block_1(ctx) {
	let div;
	let current;
	const icon_slot_template = /*#slots*/ ctx[14].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[13], get_icon_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			if (icon_slot) icon_slot.c();
			attr_dev(div, "class", "expander-icon svelte-1p16tfx");
			add_location(div, file, 72, 4, 2314);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (icon_slot) {
				icon_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						icon_slot,
						icon_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(icon_slot_template, /*$$scope*/ ctx[13], dirty, get_icon_slot_changes),
						get_icon_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (icon_slot) icon_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(72:3) {#if $$slots.icon}",
		ctx
	});

	return block;
}

// (92:5) {:else}
function create_else_block(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", "M2.14645 7.35355C2.34171 7.54882 2.65829 7.54882 2.85355 7.35355L6 4.20711L9.14645 7.35355C9.34171 7.54882 9.65829 7.54882 9.85355 7.35355C10.0488 7.15829 10.0488 6.84171 9.85355 6.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645L2.14645 6.64645C1.95118 6.84171 1.95118 7.15829 2.14645 7.35355Z");
			add_location(path, file, 92, 6, 3079);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(92:5) {:else}",
		ctx
	});

	return block;
}

// (87:5) {#if direction === "down"}
function create_if_block(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", "M2.14645 4.64645C2.34171 4.45118 2.65829 4.45118 2.85355 4.64645L6 7.79289L9.14645 4.64645C9.34171 4.45118 9.65829 4.45118 9.85355 4.64645C10.0488 4.84171 10.0488 5.15829 9.85355 5.35355L6.35355 8.85355C6.15829 9.04882 5.84171 9.04882 5.64645 8.85355L2.14645 5.35355C1.95118 5.15829 1.95118 4.84171 2.14645 4.64645Z");
			add_location(path, file, 87, 6, 2691);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(87:5) {#if direction === \\\"down\\\"}",
		ctx
	});

	return block;
}

// (60:1) <svelte:element this="h">
function create_dynamic_element(ctx) {
	let svelte_element;
	let div;
	let t0;
	let span;
	let t1;
	let button;
	let svg;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*$$slots*/ ctx[11].icon && create_if_block_1(ctx);
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	function select_block_type(ctx, dirty) {
		if (/*direction*/ ctx[4] === "down") return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block1 = current_block_type(ctx);
	let svelte_element_levels = [];
	let svelte_element_data = {};

	for (let i = 0; i < svelte_element_levels.length; i += 1) {
		svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
	}

	const block = {
		c: function create() {
			svelte_element = element("h");
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			span = element("span");
			if (default_slot) default_slot.c();
			t1 = space();
			button = element("button");
			svg = svg_element("svg");
			if_block1.c();
			attr_dev(span, "class", "expander-header-title svelte-1p16tfx");
			add_location(span, file, 76, 3, 2391);
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "12");
			attr_dev(svg, "height", "12");
			attr_dev(svg, "viewBox", "0 0 12 12");
			attr_dev(svg, "class", "svelte-1p16tfx");
			add_location(svg, file, 85, 4, 2569);
			attr_dev(button, "class", "expander-chevron svelte-1p16tfx");
			attr_dev(button, "tabindex", "-1");
			attr_dev(button, "id", /*contentId*/ ctx[8]);
			attr_dev(button, "aria-labelledby", /*headerId*/ ctx[7]);
			add_location(button, file, 79, 3, 2455);
			attr_dev(div, "role", "button");
			attr_dev(div, "id", /*headerId*/ ctx[7]);
			attr_dev(div, "aria-controls", /*contentId*/ ctx[8]);
			attr_dev(div, "class", "expander-header svelte-1p16tfx");
			attr_dev(div, "aria-expanded", /*expanded*/ ctx[0]);
			attr_dev(div, "tabindex", "0");
			add_location(div, file, 60, 2, 2043);
			set_attributes(svelte_element, svelte_element_data);
			add_location(svelte_element, file, 59, 1, 2015);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svelte_element, anchor);
			append_dev(svelte_element, div);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, span);

			if (default_slot) {
				default_slot.m(span, null);
			}

			append_dev(div, t1);
			append_dev(div, button);
			append_dev(button, svg);
			if_block1.m(svg, null);
			/*div_binding*/ ctx[15](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div, "keydown", /*handleKeydown*/ ctx[9], false, false, false),
					listen_dev(div, "click", /*click_handler*/ ctx[16], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*$$slots*/ ctx[11].icon) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$$slots*/ 2048) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}

			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(svg, null);
				}
			}

			if (!current || dirty & /*expanded*/ 1) {
				attr_dev(div, "aria-expanded", /*expanded*/ ctx[0]);
			}

			set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, []));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svelte_element);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if_block1.d();
			/*div_binding*/ ctx[15](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_dynamic_element.name,
		type: "child_dynamic_element",
		source: "(60:1) <svelte:element this=\\\"h\\\">",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div3;
	let previous_tag = "h";
	let t2;
	let div2;
	let div1;
	let div3_class_value;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	validate_dynamic_element("h");
	validate_void_dynamic_element("h");
	let svelte_element = "h" && create_dynamic_element(ctx);
	const content_slot_template = /*#slots*/ ctx[14].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[13], get_content_slot_context);

	let div3_levels = [
		{
			class: div3_class_value = "expander direction-" + /*direction*/ ctx[4] + " " + /*className*/ ctx[5]
		},
		{ role: "region" },
		/*$$restProps*/ ctx[10]
	];

	let div3_data = {};

	for (let i = 0; i < div3_levels.length; i += 1) {
		div3_data = assign(div3_data, div3_levels[i]);
	}

	const block = {
		c: function create() {
			div3 = element("div");
			if (svelte_element) svelte_element.c();
			t2 = space();
			div2 = element("div");
			div1 = element("div");
			if (content_slot) content_slot.c();
			attr_dev(div1, "class", "expander-content svelte-1p16tfx");
			add_location(div1, file, 102, 2, 3552);
			attr_dev(div2, "class", "expander-content-anchor svelte-1p16tfx");
			add_location(div2, file, 101, 1, 3512);
			set_attributes(div3, div3_data);
			toggle_class(div3, "expanded", /*expanded*/ ctx[0]);
			toggle_class(div3, "svelte-1p16tfx", true);
			add_location(div3, file, 51, 0, 1857);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			if (svelte_element) svelte_element.m(div3, null);
			append_dev(div3, t2);
			append_dev(div3, div2);
			append_dev(div2, div1);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			/*div1_binding*/ ctx[17](div1);
			/*div3_binding*/ ctx[18](div3);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[6].call(null, div3));
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ("h") {
				if (!previous_tag) {
					svelte_element = create_dynamic_element(ctx);
					svelte_element.c();
					svelte_element.m(div3, t2);
				} else if (safe_not_equal(previous_tag, "h")) {
					svelte_element.d(1);
					validate_dynamic_element("h");
					validate_void_dynamic_element("h");
					svelte_element = create_dynamic_element(ctx);
					svelte_element.c();
					svelte_element.m(div3, t2);
				} else {
					svelte_element.p(ctx, dirty);
				}
			} else if (previous_tag) {
				svelte_element.d(1);
				svelte_element = null;
			}

			previous_tag = "h";

			if (content_slot) {
				if (content_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[13], dirty, get_content_slot_changes),
						get_content_slot_context
					);
				}
			}

			set_attributes(div3, div3_data = get_spread_update(div3_levels, [
				(!current || dirty & /*direction, className*/ 48 && div3_class_value !== (div3_class_value = "expander direction-" + /*direction*/ ctx[4] + " " + /*className*/ ctx[5])) && { class: div3_class_value },
				{ role: "region" },
				dirty & /*$$restProps*/ 1024 && /*$$restProps*/ ctx[10]
			]));

			toggle_class(div3, "expanded", /*expanded*/ ctx[0]);
			toggle_class(div3, "svelte-1p16tfx", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(svelte_element);
			transition_in(content_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(svelte_element);
			transition_out(content_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if (svelte_element) svelte_element.d(detaching);
			if (content_slot) content_slot.d(detaching);
			/*div1_binding*/ ctx[17](null);
			/*div3_binding*/ ctx[18](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"expanded","direction","headingLevel","class","containerElement","headerElement","contentElement"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Expander', slots, ['icon','default','content']);
	const $$slots = compute_slots(slots);
	let { expanded = false } = $$props;
	let { direction = "down" } = $$props;
	let { headingLevel = 3 } = $$props;
	let { class: className = "" } = $$props;
	let { containerElement = null } = $$props;
	let { headerElement = null } = $$props;
	let { contentElement = null } = $$props;
	const dispatch = createEventDispatcher();
	const forwardEvents = createEventForwarder(get_current_component(), ["expand", "collapse"]);
	const headerId = uid("fds-expander-header-");
	const contentId = uid("fds-expander-content-");

	function handleKeydown({ key }) {
		if (key === "Enter" || key === " ") {
			event.preventDefault();
			$$invalidate(0, expanded = !expanded);
		}
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			headerElement = $$value;
			$$invalidate(2, headerElement);
		});
	}

	const click_handler = () => $$invalidate(0, expanded = !expanded);

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			contentElement = $$value;
			$$invalidate(3, contentElement);
		});
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			containerElement = $$value;
			$$invalidate(1, containerElement);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('expanded' in $$new_props) $$invalidate(0, expanded = $$new_props.expanded);
		if ('direction' in $$new_props) $$invalidate(4, direction = $$new_props.direction);
		if ('headingLevel' in $$new_props) $$invalidate(12, headingLevel = $$new_props.headingLevel);
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('containerElement' in $$new_props) $$invalidate(1, containerElement = $$new_props.containerElement);
		if ('headerElement' in $$new_props) $$invalidate(2, headerElement = $$new_props.headerElement);
		if ('contentElement' in $$new_props) $$invalidate(3, contentElement = $$new_props.contentElement);
		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		get_current_component,
		createEventForwarder,
		uid,
		expanded,
		direction,
		headingLevel,
		className,
		containerElement,
		headerElement,
		contentElement,
		dispatch,
		forwardEvents,
		headerId,
		contentId,
		handleKeydown
	});

	$$self.$inject_state = $$new_props => {
		if ('expanded' in $$props) $$invalidate(0, expanded = $$new_props.expanded);
		if ('direction' in $$props) $$invalidate(4, direction = $$new_props.direction);
		if ('headingLevel' in $$props) $$invalidate(12, headingLevel = $$new_props.headingLevel);
		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
		if ('containerElement' in $$props) $$invalidate(1, containerElement = $$new_props.containerElement);
		if ('headerElement' in $$props) $$invalidate(2, headerElement = $$new_props.headerElement);
		if ('contentElement' in $$props) $$invalidate(3, contentElement = $$new_props.contentElement);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*expanded*/ 1) {
			$: if (expanded) {
				dispatch("expand");
			} else {
				dispatch("collapse");
			}
		}
	};

	return [
		expanded,
		containerElement,
		headerElement,
		contentElement,
		direction,
		className,
		forwardEvents,
		headerId,
		contentId,
		handleKeydown,
		$$restProps,
		$$slots,
		headingLevel,
		$$scope,
		slots,
		div_binding,
		click_handler,
		div1_binding,
		div3_binding
	];
}

class Expander extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				expanded: 0,
				direction: 4,
				headingLevel: 12,
				class: 5,
				containerElement: 1,
				headerElement: 2,
				contentElement: 3
			},
			add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Expander",
			options,
			id: create_fragment.name
		});
	}

	get expanded() {
		throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expanded(value) {
		throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get direction() {
		throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set direction(value) {
		throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get headingLevel() {
		throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set headingLevel(value) {
		throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get containerElement() {
		throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set containerElement(value) {
		throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get headerElement() {
		throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set headerElement(value) {
		throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get contentElement() {
		throw new Error("<Expander>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set contentElement(value) {
		throw new Error("<Expander>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Expander;