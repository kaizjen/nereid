/* InfoBar.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	action_destroyer,
	add_location,
	add_render_callback,
	add_resize_listener,
	append_dev,
	append_styles,
	assign,
	attr_dev,
	binding_callbacks,
	check_outros,
	compute_rest_props,
	compute_slots,
	create_component,
	create_slot,
	destroy_component,
	detach_dev,
	dispatch_dev,
	element as element_1,
	empty,
	exclude_internal_props,
	get_all_dirty_from_scope,
	get_slot_changes,
	get_spread_update,
	group_outros,
	init,
	insert_dev,
	listen_dev,
	mount_component,
	noop,
	safe_not_equal,
	set_attributes,
	set_data_dev,
	space,
	svg_element,
	text,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base,
	validate_slots
} from "nereid://.svelte/internal/index.mjs";

import { createEventDispatcher } from "nereid://.svelte/index.mjs";
import { get_current_component } from "nereid://.svelte/internal/index.mjs";
import { createEventForwarder } from "../internal.js";
import InfoBadge from "../InfoBadge/InfoBadge.svelte.js";
const file = "InfoBar.svelte";

function add_css(target) {
	append_styles(target, "svelte-fp4fp6", ".info-bar.svelte-fp4fp6.svelte-fp4fp6{-webkit-padding-start:15px;align-items:center;background-clip:padding-box;border:1px solid var(--fds-card-stroke-default);border-radius:var(--fds-control-corner-radius);box-sizing:border-box;display:flex;font-family:var(--fds-font-family-text);min-block-size:48px;padding-inline-start:15px;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.info-bar.severity-information.svelte-fp4fp6.svelte-fp4fp6{background-color:var(--fds-card-background-secondary)}.info-bar.severity-success.svelte-fp4fp6.svelte-fp4fp6{background-color:var(--fds-system-background-success)}.info-bar.severity-caution.svelte-fp4fp6.svelte-fp4fp6{background-color:var(--fds-system-background-caution)}.info-bar.severity-critical.svelte-fp4fp6.svelte-fp4fp6{background-color:var(--fds-system-background-critical)}.info-bar.severity-attention.svelte-fp4fp6.svelte-fp4fp6{background-color:var(--fds-system-background-attention)}.info-bar-icon.svelte-fp4fp6.svelte-fp4fp6{-webkit-margin-before:16px;align-self:flex-start;display:flex;flex:0 0 auto;margin-block-start:16px}.info-bar-content.svelte-fp4fp6.svelte-fp4fp6{-webkit-margin-start:13px;-webkit-margin-before:7px;-webkit-margin-after:7px;align-items:center;box-sizing:border-box;display:flex;flex:1 1 auto;flex-wrap:wrap;margin-block-end:7px;margin-block-start:7px;margin-inline-start:13px;position:relative}.info-bar-content.action-wrapped.svelte-fp4fp6.svelte-fp4fp6,.info-bar-content.message-wrapped.svelte-fp4fp6.svelte-fp4fp6{-webkit-margin-before:13px;-webkit-margin-after:15px;margin-block-end:15px;margin-block-start:13px}.info-bar-content.message-wrapped.svelte-fp4fp6 h5.svelte-fp4fp6,.info-bar-content.message-wrapped.svelte-fp4fp6 p.svelte-fp4fp6{align-self:flex-start}.info-bar-content.message-wrapped.svelte-fp4fp6 .info-bar-action.svelte-fp4fp6{-webkit-margin-end:50%;margin-inline-end:50%}.info-bar-content.action-wrapped.svelte-fp4fp6 .info-bar-action.svelte-fp4fp6{-webkit-padding-before:16px;padding-block-start:16px}.info-bar.svelte-fp4fp6 h5.svelte-fp4fp6,.info-bar.svelte-fp4fp6 p.svelte-fp4fp6{color:var(--fds-text-primary);font-size:var(--fds-body-font-size);font-weight:400;line-height:20px;margin:0}.info-bar.svelte-fp4fp6 h5.svelte-fp4fp6{-webkit-margin-end:12px;font-weight:600;margin-inline-end:12px}.info-bar.svelte-fp4fp6 p.svelte-fp4fp6{-webkit-margin-end:15px;flex:1 1 auto;margin-inline-end:15px}.info-bar-action.svelte-fp4fp6.svelte-fp4fp6{-webkit-margin-end:4px;margin-inline-end:4px}.info-bar-action.svelte-fp4fp6.svelte-fp4fp6,.info-bar-close-button.svelte-fp4fp6.svelte-fp4fp6{align-items:center;align-self:flex-start;display:flex}.info-bar-close-button.svelte-fp4fp6.svelte-fp4fp6{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--fds-subtle-fill-transparent);block-size:38px;border:none;border-radius:var(--fds-control-corner-radius);color:var(--fds-text-primary);flex:0 0 auto;inline-size:38px;justify-content:center;margin:4px;outline:none;transition:var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing)}.info-bar-close-button.svelte-fp4fp6.svelte-fp4fp6:focus-visible{box-shadow:var(--fds-focus-stroke)}.info-bar-close-button.svelte-fp4fp6.svelte-fp4fp6:hover{background-color:var(--fds-subtle-fill-secondary)}.info-bar-close-button.svelte-fp4fp6.svelte-fp4fp6:active{background-color:var(--fds-subtle-fill-tertiary);color:var(--fds-text-secondary)}.info-bar-close-button.svelte-fp4fp6 svg.svelte-fp4fp6{fill:currentColor;block-size:12px;inline-size:12px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5mb0Jhci5zdmVsdGUiLCJzb3VyY2VzIjpbIkluZm9CYXIuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQgPmltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcclxuaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSBcInN2ZWx0ZS9pbnRlcm5hbFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVFdmVudEZvcndhcmRlciB9IGZyb20gXCIuLi9pbnRlcm5hbFwiO1xyXG5pbXBvcnQgSW5mb0JhZGdlIGZyb20gXCIuLi9JbmZvQmFkZ2UvSW5mb0JhZGdlLnN2ZWx0ZVwiO1xyXG4vKiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBiYXIgaXMgb3BlbiAocmVuZGVyZWQpLiAqL1xyXG5leHBvcnQgbGV0IG9wZW4gPSB0cnVlO1xyXG4vKiogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjbG9zZSBidXR0b24gaXMgdXNlZCBvciBub3QuICovXHJcbmV4cG9ydCBsZXQgY2xvc2FibGUgPSB0cnVlO1xyXG4vKiogSW5kaWNhdGVzIHRoZSBzZXZlcml0eSBjb2xvciBvZiB0aGUgYmFyLiAqL1xyXG5leHBvcnQgbGV0IHNldmVyaXR5ID0gXCJpbmZvcm1hdGlvblwiO1xyXG4vKiogVGl0bGUgb2YgdGhlIEluZm9iYXIuICovXHJcbmV4cG9ydCBsZXQgdGl0bGUgPSBcIlwiO1xyXG4vKiogRGVzY3JpcHRpb24gdGV4dCBzaG93biBuZXh0IHRvIG9yIGJlbG93IHRoZSB0aXRsZS4gKi9cclxuZXhwb3J0IGxldCBtZXNzYWdlID0gXCJcIjtcclxuLyoqIFNwZWNpZmllcyBhIGN1c3RvbSBjbGFzcyBuYW1lIGZvciB0aGUgYmFyLiAqL1xyXG5sZXQgY2xhc3NOYW1lID0gXCJcIjtcclxuZXhwb3J0IHsgY2xhc3NOYW1lIGFzIGNsYXNzIH07XHJcbi8qKiBPYnRhaW5zIGEgYm91bmQgRE9NIHJlZmVyZW5jZSB0byB0aGUgYmFyJ3MgY29udGFpbmVyIGVsZW1lbnQuICovXHJcbmV4cG9ydCBsZXQgZWxlbWVudCA9IG51bGw7XHJcbi8qKiBPYnRhaW5zIGEgYm91bmQgRE9NIHJlZmVyZW5jZSB0byB0aGUgYmFyJ3MgdGl0bGUgZWxlbWVudC4gKi9cclxuZXhwb3J0IGxldCB0aXRsZUVsZW1lbnQgPSBudWxsO1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIGJhcidzIG1lc3NhZ2UgKHBhcmFncmFwaCkgZWxlbWVudC4gKi9cclxuZXhwb3J0IGxldCBtZXNzYWdlRWxlbWVudCA9IG51bGw7XHJcbi8qKiBPYnRhaW5zIGEgYm91bmQgRE9NIHJlZmVyZW5jZSB0byB0aGUgYmFyJ3MgYWN0aW9uIHdyYXBwZXIgZWxlbWVudC4gKi9cclxuZXhwb3J0IGxldCBhY3Rpb25FbGVtZW50ID0gbnVsbDtcclxuLyoqIE9idGFpbnMgYSBib3VuZCBET00gcmVmZXJlbmNlIHRvIHRoZSBiYXIncyBjbG9zZSBidXR0b24gZWxlbWVudC4gKi9cclxuZXhwb3J0IGxldCBjbG9zZUJ1dHRvbkVsZW1lbnQgPSBudWxsO1xyXG5sZXQgd3JhcHBlZCA9IGZhbHNlO1xyXG5sZXQgY2xpZW50SGVpZ2h0ID0gMDtcclxuY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcclxuY29uc3QgZm9yd2FyZEV2ZW50cyA9IGNyZWF0ZUV2ZW50Rm9yd2FyZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpKTtcclxuJDogYWN0aW9uV3JhcHBlZCA9IGNsaWVudEhlaWdodCAmJiAoYWN0aW9uRWxlbWVudCA9PT0gbnVsbCB8fCBhY3Rpb25FbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3Rpb25FbGVtZW50Lm9mZnNldFRvcCkgPiAwO1xyXG4kOiBtZXNzYWdlV3JhcHBlZCA9IGNsaWVudEhlaWdodCAmJiAobWVzc2FnZUVsZW1lbnQgPT09IG51bGwgfHwgbWVzc2FnZUVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2VFbGVtZW50Lm9mZnNldFRvcCkgPiAodGl0bGVFbGVtZW50ID09PSBudWxsIHx8IHRpdGxlRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGl0bGVFbGVtZW50Lm9mZnNldFRvcCk7XHJcbiQ6IGlmIChvcGVuKSB7XHJcbiAgICBkaXNwYXRjaChcIm9wZW5cIik7XHJcbn1cclxuZWxzZSB7XHJcbiAgICBkaXNwYXRjaChcImNsb3NlXCIpO1xyXG59XHJcbjwvc2NyaXB0PlxuXG48IS0tXG5AY29tcG9uZW50XG5UaGUgSW5mb0JhciBjb250cm9sIGlzIGZvciBkaXNwbGF5aW5nIGFwcC13aWRlIHN0YXR1cyBtZXNzYWdlcyB0byB1c2VycyB0aGF0IGFyZSBoaWdobHkgdmlzaWJsZSB5ZXQgbm9uLWludHJ1c2l2ZS4gVGhlcmUgYXJlIGJ1aWx0LWluIHNlY3VyaXR5IGxldmVscyB0byBlYXNpbHkgaW5kaWNhdGUgdGhlIHR5cGUgb2YgbWVzc2FnZSBzaG93biBhcyB3ZWxsIGFzIHRoZSBvcHRpb24gdG8gaW5jbHVkZSB5b3VyIG93biBjYWxsIHRvIGFjdGlvbiBvciBoeXBlcmxpbmsgYnV0dG9uLiBbRG9jc10oaHR0cHM6Ly9mbHVlbnQtc3ZlbHRlLnZlcmNlbC5hcHAvZG9jcy9jb21wb25lbnRzL2luZm9iYXIpXG4tIFVzYWdlOlxuICAgIGBgYHRzeFxuICAgIDxJbmZvQmFyIHRpdGxlPVwiVGl0bGVcIiBtZXNzYWdlPVwiTWVzc2FnZVwiPlxuICAgICAgICA8QnV0dG9uIHNsb3Q9XCJhY3Rpb25cIj5BY3Rpb248L0J1dHRvbj5cbiAgICA8L0luZm9CYXI+XG4gICAgYGBgXG4tLT5cbnsjaWYgb3Blbn1cblx0PGRpdlxuXHRcdHVzZTpmb3J3YXJkRXZlbnRzXG5cdFx0YmluZDp0aGlzPXtlbGVtZW50fVxuXHRcdGJpbmQ6Y2xpZW50SGVpZ2h0XG5cdFx0Y2xhc3M9XCJpbmZvLWJhciBzZXZlcml0eS17c2V2ZXJpdHl9IHtjbGFzc05hbWV9XCJcblx0XHRyb2xlPVwiYWxlcnRcIlxuXHRcdHsuLi4kJHJlc3RQcm9wc31cblx0PlxuXHRcdDxkaXYgY2xhc3M9XCJpbmZvLWJhci1pY29uXCI+XG5cdFx0XHQ8c2xvdCBuYW1lPVwiaWNvblwiPlxuXHRcdFx0XHQ8SW5mb0JhZGdlIHtzZXZlcml0eX0gLz5cblx0XHRcdDwvc2xvdD5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2XG5cdFx0XHRjbGFzcz1cImluZm8tYmFyLWNvbnRlbnRcIlxuXHRcdFx0Y2xhc3M6d3JhcHBlZFxuXHRcdFx0Y2xhc3M6YWN0aW9uLXZpc2libGU9eyQkc2xvdHMuYWN0aW9ufVxuXHRcdFx0Y2xhc3M6YWN0aW9uLXdyYXBwZWQ9e2FjdGlvbldyYXBwZWR9XG5cdFx0XHRjbGFzczptZXNzYWdlLXdyYXBwZWQ9e21lc3NhZ2VXcmFwcGVkfVxuXHRcdD5cblx0XHRcdHsjaWYgdGl0bGV9XG5cdFx0XHRcdDxoNSBiaW5kOnRoaXM9e3RpdGxlRWxlbWVudH0+XG5cdFx0XHRcdFx0e3RpdGxlfVxuXHRcdFx0XHQ8L2g1PlxuXHRcdFx0ey9pZn1cblx0XHRcdHsjaWYgbWVzc2FnZSB8fCAkJHNsb3RzLmRlZmF1bHR9XG5cdFx0XHRcdDxwIGJpbmQ6dGhpcz17bWVzc2FnZUVsZW1lbnR9PlxuXHRcdFx0XHRcdHttZXNzYWdlfVxuXHRcdFx0XHRcdDxzbG90IC8+XG5cdFx0XHRcdDwvcD5cblx0XHRcdHsvaWZ9XG5cdFx0XHR7I2lmICQkc2xvdHMuYWN0aW9ufVxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaW5mby1iYXItYWN0aW9uXCIgYmluZDp0aGlzPXthY3Rpb25FbGVtZW50fT5cblx0XHRcdFx0XHQ8c2xvdCBuYW1lPVwiYWN0aW9uXCIgLz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR7L2lmfVxuXHRcdDwvZGl2PlxuXHRcdHsjaWYgY2xvc2FibGV9XG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGNsYXNzPVwiaW5mby1iYXItY2xvc2UtYnV0dG9uXCJcblx0XHRcdFx0dHlwZT1cImJ1dHRvblwiXG5cdFx0XHRcdGFyaWEtbGFiZWw9XCJDbG9zZVwiXG5cdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiAob3BlbiA9IGZhbHNlKX1cblx0XHRcdFx0YmluZDp0aGlzPXtjbG9zZUJ1dHRvbkVsZW1lbnR9XG5cdFx0XHQ+XG5cdFx0XHRcdDxzdmdcblx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIlxuXHRcdFx0XHRcdHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuXHRcdFx0XHRcdHdpZHRoPVwiMTJcIlxuXHRcdFx0XHRcdGhlaWdodD1cIjEyXCJcblx0XHRcdFx0XHR2aWV3Qm94PVwiMCAwIDEwMjQgMTAyNFwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8cGF0aFxuXHRcdFx0XHRcdFx0ZmlsbD1cImN1cnJlbnRDb2xvclwiXG5cdFx0XHRcdFx0XHRkPVwiTTUxMiw1ODQuNUw4Ny41LDEwMDlDNzcuNSwxMDE5IDY1LjUsMTAyNCA1MS41LDEwMjRDMzYuODMzMywxMDI0IDI0LjU4MzMsMTAxOS4wOCAxNC43NSwxMDA5LjI1QzQuOTE2NjcsOTk5LjQxNyAwLDk4Ny4xNjcgMCw5NzIuNUMwLDk1OC41IDUsOTQ2LjUgMTUsOTM2LjVMNDM5LjUsNTEyTDE1LDg3LjVDNSw3Ny41IDAsNjUuMzMzNCAwLDUxQzAsNDQgMS4zMzMzMywzNy4zMzM0IDQsMzFDNi42NjY2NywyNC42NjY3IDEwLjMzMzMsMTkuMjUgMTUsMTQuNzVDMTkuNjY2NywxMC4yNSAyNS4xNjY3LDYuNjY2NjkgMzEuNSw0QzM3LjgzMzMsMS4zMzMzNyA0NC41LDAgNTEuNSwwQzY1LjUsMCA3Ny41LDUgODcuNSwxNUw1MTIsNDM5LjVMOTM2LjUsMTVDOTQ2LjUsNSA5NTguNjY3LDAgOTczLDBDOTgwLDAgOTg2LjU4MywxLjMzMzM3IDk5Mi43NSw0Qzk5OC45MTcsNi42NjY2OSAxMDA0LjMzLDEwLjMzMzQgMTAwOSwxNUMxMDEzLjY3LDE5LjY2NjcgMTAxNy4zMywyNS4wODM0IDEwMjAsMzEuMjVDMTAyMi42NywzNy40MTY3IDEwMjQsNDQgMTAyNCw1MUMxMDI0LDY1LjMzMzQgMTAxOSw3Ny41IDEwMDksODcuNUw1ODQuNSw1MTJMMTAwOSw5MzYuNUMxMDE5LDk0Ni41IDEwMjQsOTU4LjUgMTAyNCw5NzIuNUMxMDI0LDk3OS41IDEwMjIuNjcsOTg2LjE2NyAxMDIwLDk5Mi41QzEwMTcuMzMsOTk4LjgzMyAxMDEzLjc1LDEwMDQuMzMgMTAwOS4yNSwxMDA5QzEwMDQuNzUsMTAxMy42NyA5OTkuMzMzLDEwMTcuMzMgOTkzLDEwMjBDOTg2LjY2NywxMDIyLjY3IDk4MCwxMDI0IDk3MywxMDI0Qzk1OC42NjcsMTAyNCA5NDYuNSwxMDE5IDkzNi41LDEwMDlaXCJcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L3N2Zz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdHsvaWZ9XG5cdDwvZGl2Plxuey9pZn1cblxuPHN0eWxlID4uaW5mby1iYXJ7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OjE1cHg7YWxpZ24taXRlbXM6Y2VudGVyO2JhY2tncm91bmQtY2xpcDpwYWRkaW5nLWJveDtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZkcy1jYXJkLXN0cm9rZS1kZWZhdWx0KTtib3JkZXItcmFkaXVzOnZhcigtLWZkcy1jb250cm9sLWNvcm5lci1yYWRpdXMpO2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmZsZXg7Zm9udC1mYW1pbHk6dmFyKC0tZmRzLWZvbnQtZmFtaWx5LXRleHQpO21pbi1ibG9jay1zaXplOjQ4cHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6MTVweDtwb3NpdGlvbjpyZWxhdGl2ZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LmluZm8tYmFyLnNldmVyaXR5LWluZm9ybWF0aW9ue2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLWNhcmQtYmFja2dyb3VuZC1zZWNvbmRhcnkpfS5pbmZvLWJhci5zZXZlcml0eS1zdWNjZXNze2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLXN5c3RlbS1iYWNrZ3JvdW5kLXN1Y2Nlc3MpfS5pbmZvLWJhci5zZXZlcml0eS1jYXV0aW9ue2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLXN5c3RlbS1iYWNrZ3JvdW5kLWNhdXRpb24pfS5pbmZvLWJhci5zZXZlcml0eS1jcml0aWNhbHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZkcy1zeXN0ZW0tYmFja2dyb3VuZC1jcml0aWNhbCl9LmluZm8tYmFyLnNldmVyaXR5LWF0dGVudGlvbntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZkcy1zeXN0ZW0tYmFja2dyb3VuZC1hdHRlbnRpb24pfS5pbmZvLWJhci1pY29uey13ZWJraXQtbWFyZ2luLWJlZm9yZToxNnB4O2FsaWduLXNlbGY6ZmxleC1zdGFydDtkaXNwbGF5OmZsZXg7ZmxleDowIDAgYXV0bzttYXJnaW4tYmxvY2stc3RhcnQ6MTZweH0uaW5mby1iYXItY29udGVudHstd2Via2l0LW1hcmdpbi1zdGFydDoxM3B4Oy13ZWJraXQtbWFyZ2luLWJlZm9yZTo3cHg7LXdlYmtpdC1tYXJnaW4tYWZ0ZXI6N3B4O2FsaWduLWl0ZW1zOmNlbnRlcjtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpmbGV4O2ZsZXg6MSAxIGF1dG87ZmxleC13cmFwOndyYXA7bWFyZ2luLWJsb2NrLWVuZDo3cHg7bWFyZ2luLWJsb2NrLXN0YXJ0OjdweDttYXJnaW4taW5saW5lLXN0YXJ0OjEzcHg7cG9zaXRpb246cmVsYXRpdmV9LmluZm8tYmFyLWNvbnRlbnQuYWN0aW9uLXdyYXBwZWQsLmluZm8tYmFyLWNvbnRlbnQubWVzc2FnZS13cmFwcGVkey13ZWJraXQtbWFyZ2luLWJlZm9yZToxM3B4Oy13ZWJraXQtbWFyZ2luLWFmdGVyOjE1cHg7bWFyZ2luLWJsb2NrLWVuZDoxNXB4O21hcmdpbi1ibG9jay1zdGFydDoxM3B4fS5pbmZvLWJhci1jb250ZW50Lm1lc3NhZ2Utd3JhcHBlZCBoNSwuaW5mby1iYXItY29udGVudC5tZXNzYWdlLXdyYXBwZWQgcHthbGlnbi1zZWxmOmZsZXgtc3RhcnR9LmluZm8tYmFyLWNvbnRlbnQubWVzc2FnZS13cmFwcGVkIC5pbmZvLWJhci1hY3Rpb257LXdlYmtpdC1tYXJnaW4tZW5kOjUwJTttYXJnaW4taW5saW5lLWVuZDo1MCV9LmluZm8tYmFyLWNvbnRlbnQuYWN0aW9uLXdyYXBwZWQgLmluZm8tYmFyLWFjdGlvbnstd2Via2l0LXBhZGRpbmctYmVmb3JlOjE2cHg7cGFkZGluZy1ibG9jay1zdGFydDoxNnB4fS5pbmZvLWJhciBoNSwuaW5mby1iYXIgcHtjb2xvcjp2YXIoLS1mZHMtdGV4dC1wcmltYXJ5KTtmb250LXNpemU6dmFyKC0tZmRzLWJvZHktZm9udC1zaXplKTtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MjBweDttYXJnaW46MH0uaW5mby1iYXIgaDV7LXdlYmtpdC1tYXJnaW4tZW5kOjEycHg7Zm9udC13ZWlnaHQ6NjAwO21hcmdpbi1pbmxpbmUtZW5kOjEycHh9LmluZm8tYmFyIHB7LXdlYmtpdC1tYXJnaW4tZW5kOjE1cHg7ZmxleDoxIDEgYXV0bzttYXJnaW4taW5saW5lLWVuZDoxNXB4fS5pbmZvLWJhci1hY3Rpb257LXdlYmtpdC1tYXJnaW4tZW5kOjRweDttYXJnaW4taW5saW5lLWVuZDo0cHh9LmluZm8tYmFyLWFjdGlvbiwuaW5mby1iYXItY2xvc2UtYnV0dG9ue2FsaWduLWl0ZW1zOmNlbnRlcjthbGlnbi1zZWxmOmZsZXgtc3RhcnQ7ZGlzcGxheTpmbGV4fS5pbmZvLWJhci1jbG9zZS1idXR0b257LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7LW1vei1hcHBlYXJhbmNlOm5vbmU7YXBwZWFyYW5jZTpub25lO2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLXN1YnRsZS1maWxsLXRyYW5zcGFyZW50KTtibG9jay1zaXplOjM4cHg7Ym9yZGVyOm5vbmU7Ym9yZGVyLXJhZGl1czp2YXIoLS1mZHMtY29udHJvbC1jb3JuZXItcmFkaXVzKTtjb2xvcjp2YXIoLS1mZHMtdGV4dC1wcmltYXJ5KTtmbGV4OjAgMCBhdXRvO2lubGluZS1zaXplOjM4cHg7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW46NHB4O291dGxpbmU6bm9uZTt0cmFuc2l0aW9uOnZhcigtLWZkcy1jb250cm9sLWZhc3QtZHVyYXRpb24pIHZhcigtLWZkcy1jb250cm9sLWZhc3Qtb3V0LXNsb3ctaW4tZWFzaW5nKX0uaW5mby1iYXItY2xvc2UtYnV0dG9uOmZvY3VzLXZpc2libGV7Ym94LXNoYWRvdzp2YXIoLS1mZHMtZm9jdXMtc3Ryb2tlKX0uaW5mby1iYXItY2xvc2UtYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLXN1YnRsZS1maWxsLXNlY29uZGFyeSl9LmluZm8tYmFyLWNsb3NlLWJ1dHRvbjphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtc3VidGxlLWZpbGwtdGVydGlhcnkpO2NvbG9yOnZhcigtLWZkcy10ZXh0LXNlY29uZGFyeSl9LmluZm8tYmFyLWNsb3NlLWJ1dHRvbiBzdmd7ZmlsbDpjdXJyZW50Q29sb3I7YmxvY2stc2l6ZToxMnB4O2lubGluZS1zaXplOjEycHh9PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrSFEscUNBQVMsQ0FBQyxzQkFBc0IsSUFBSSxDQUFDLFlBQVksTUFBTSxDQUFDLGdCQUFnQixXQUFXLENBQUMsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUkseUJBQXlCLENBQUMsQ0FBQyxjQUFjLElBQUksMkJBQTJCLENBQUMsQ0FBQyxXQUFXLFVBQVUsQ0FBQyxRQUFRLElBQUksQ0FBQyxZQUFZLElBQUksc0JBQXNCLENBQUMsQ0FBQyxlQUFlLElBQUksQ0FBQyxxQkFBcUIsSUFBSSxDQUFDLFNBQVMsUUFBUSxDQUFDLG9CQUFvQixJQUFJLENBQUMsaUJBQWlCLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLFNBQVMsaURBQXFCLENBQUMsaUJBQWlCLElBQUksK0JBQStC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 */");
}

const get_action_slot_changes = dirty => ({});
const get_action_slot_context = ctx => ({});
const get_icon_slot_changes = dirty => ({});
const get_icon_slot_context = ctx => ({});

// (52:0) {#if open}
function create_if_block(ctx) {
	let div2;
	let div0;
	let t0;
	let div1;
	let t1;
	let t2;
	let t3;
	let div2_class_value;
	let forwardEvents_action;
	let div2_resize_listener;
	let current;
	let mounted;
	let dispose;
	const icon_slot_template = /*#slots*/ ctx[19].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[18], get_icon_slot_context);
	const icon_slot_or_fallback = icon_slot || fallback_block(ctx);
	let if_block0 = /*title*/ ctx[8] && create_if_block_4(ctx);
	let if_block1 = (/*message*/ ctx[9] || /*$$slots*/ ctx[17].default) && create_if_block_3(ctx);
	let if_block2 = /*$$slots*/ ctx[17].action && create_if_block_2(ctx);
	let if_block3 = /*closable*/ ctx[6] && create_if_block_1(ctx);

	let div2_levels = [
		{
			class: div2_class_value = "info-bar severity-" + /*severity*/ ctx[7] + " " + /*className*/ ctx[10]
		},
		{ role: "alert" },
		/*$$restProps*/ ctx[16]
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element_1("div");
			div0 = element_1("div");
			if (icon_slot_or_fallback) icon_slot_or_fallback.c();
			t0 = space();
			div1 = element_1("div");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (if_block3) if_block3.c();
			attr_dev(div0, "class", "info-bar-icon svelte-fp4fp6");
			add_location(div0, file, 60, 2, 2510);
			attr_dev(div1, "class", "info-bar-content svelte-fp4fp6");
			toggle_class(div1, "wrapped", /*wrapped*/ ctx[14]);
			toggle_class(div1, "action-visible", /*$$slots*/ ctx[17].action);
			toggle_class(div1, "action-wrapped", /*actionWrapped*/ ctx[13]);
			toggle_class(div1, "message-wrapped", /*messageWrapped*/ ctx[12]);
			add_location(div1, file, 65, 2, 2611);
			set_attributes(div2, div2_data);
			add_render_callback(() => /*div2_elementresize_handler*/ ctx[26].call(div2));
			toggle_class(div2, "svelte-fp4fp6", true);
			add_location(div2, file, 52, 1, 2353);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);

			if (icon_slot_or_fallback) {
				icon_slot_or_fallback.m(div0, null);
			}

			append_dev(div2, t0);
			append_dev(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			if (if_block2) if_block2.m(div1, null);
			append_dev(div2, t3);
			if (if_block3) if_block3.m(div2, null);
			/*div2_binding*/ ctx[25](div2);
			div2_resize_listener = add_resize_listener(div2, /*div2_elementresize_handler*/ ctx[26].bind(div2));
			current = true;

			if (!mounted) {
				dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[15].call(null, div2));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					update_slot_base(
						icon_slot,
						icon_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: get_slot_changes(icon_slot_template, /*$$scope*/ ctx[18], dirty, get_icon_slot_changes),
						get_icon_slot_context
					);
				}
			} else {
				if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*severity*/ 128)) {
					icon_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (/*title*/ ctx[8]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*message*/ ctx[9] || /*$$slots*/ ctx[17].default) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*message, $$slots*/ 131584) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*$$slots*/ ctx[17].action) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*$$slots*/ 131072) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_2(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (dirty & /*$$slots*/ 131072) {
				toggle_class(div1, "action-visible", /*$$slots*/ ctx[17].action);
			}

			if (dirty & /*actionWrapped*/ 8192) {
				toggle_class(div1, "action-wrapped", /*actionWrapped*/ ctx[13]);
			}

			if (dirty & /*messageWrapped*/ 4096) {
				toggle_class(div1, "message-wrapped", /*messageWrapped*/ ctx[12]);
			}

			if (/*closable*/ ctx[6]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_1(ctx);
					if_block3.c();
					if_block3.m(div2, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty & /*severity, className*/ 1152 && div2_class_value !== (div2_class_value = "info-bar severity-" + /*severity*/ ctx[7] + " " + /*className*/ ctx[10])) && { class: div2_class_value },
				{ role: "alert" },
				dirty & /*$$restProps*/ 65536 && /*$$restProps*/ ctx[16]
			]));

			toggle_class(div2, "svelte-fp4fp6", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_slot_or_fallback, local);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_slot_or_fallback, local);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			/*div2_binding*/ ctx[25](null);
			div2_resize_listener();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(52:0) {#if open}",
		ctx
	});

	return block;
}

// (62:21)      
function fallback_block(ctx) {
	let infobadge;
	let current;

	infobadge = new InfoBadge({
			props: { severity: /*severity*/ ctx[7] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(infobadge.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(infobadge, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const infobadge_changes = {};
			if (dirty & /*severity*/ 128) infobadge_changes.severity = /*severity*/ ctx[7];
			infobadge.$set(infobadge_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(infobadge.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(infobadge.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(infobadge, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(62:21)      ",
		ctx
	});

	return block;
}

// (73:3) {#if title}
function create_if_block_4(ctx) {
	let h5;
	let t;

	const block = {
		c: function create() {
			h5 = element_1("h5");
			t = text(/*title*/ ctx[8]);
			attr_dev(h5, "class", "svelte-fp4fp6");
			add_location(h5, file, 73, 4, 2807);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h5, anchor);
			append_dev(h5, t);
			/*h5_binding*/ ctx[20](h5);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 256) set_data_dev(t, /*title*/ ctx[8]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h5);
			/*h5_binding*/ ctx[20](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(73:3) {#if title}",
		ctx
	});

	return block;
}

// (78:3) {#if message || $$slots.default}
function create_if_block_3(ctx) {
	let p;
	let t0;
	let t1;
	let current;
	const default_slot_template = /*#slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

	const block = {
		c: function create() {
			p = element_1("p");
			t0 = text(/*message*/ ctx[9]);
			t1 = space();
			if (default_slot) default_slot.c();
			attr_dev(p, "class", "svelte-fp4fp6");
			add_location(p, file, 78, 4, 2909);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);

			if (default_slot) {
				default_slot.m(p, null);
			}

			/*p_binding*/ ctx[21](p);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*message*/ 512) set_data_dev(t0, /*message*/ ctx[9]);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (default_slot) default_slot.d(detaching);
			/*p_binding*/ ctx[21](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(78:3) {#if message || $$slots.default}",
		ctx
	});

	return block;
}

// (84:3) {#if $$slots.action}
function create_if_block_2(ctx) {
	let div;
	let current;
	const action_slot_template = /*#slots*/ ctx[19].action;
	const action_slot = create_slot(action_slot_template, ctx, /*$$scope*/ ctx[18], get_action_slot_context);

	const block = {
		c: function create() {
			div = element_1("div");
			if (action_slot) action_slot.c();
			attr_dev(div, "class", "info-bar-action svelte-fp4fp6");
			add_location(div, file, 84, 4, 3015);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (action_slot) {
				action_slot.m(div, null);
			}

			/*div_binding*/ ctx[22](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (action_slot) {
				if (action_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					update_slot_base(
						action_slot,
						action_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: get_slot_changes(action_slot_template, /*$$scope*/ ctx[18], dirty, get_action_slot_changes),
						get_action_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(action_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(action_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (action_slot) action_slot.d(detaching);
			/*div_binding*/ ctx[22](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(84:3) {#if $$slots.action}",
		ctx
	});

	return block;
}

// (90:2) {#if closable}
function create_if_block_1(ctx) {
	let button;
	let svg;
	let path;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element_1("button");
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", "M512,584.5L87.5,1009C77.5,1019 65.5,1024 51.5,1024C36.8333,1024 24.5833,1019.08 14.75,1009.25C4.91667,999.417 0,987.167 0,972.5C0,958.5 5,946.5 15,936.5L439.5,512L15,87.5C5,77.5 0,65.3334 0,51C0,44 1.33333,37.3334 4,31C6.66667,24.6667 10.3333,19.25 15,14.75C19.6667,10.25 25.1667,6.66669 31.5,4C37.8333,1.33337 44.5,0 51.5,0C65.5,0 77.5,5 87.5,15L512,439.5L936.5,15C946.5,5 958.667,0 973,0C980,0 986.583,1.33337 992.75,4C998.917,6.66669 1004.33,10.3334 1009,15C1013.67,19.6667 1017.33,25.0834 1020,31.25C1022.67,37.4167 1024,44 1024,51C1024,65.3334 1019,77.5 1009,87.5L584.5,512L1009,936.5C1019,946.5 1024,958.5 1024,972.5C1024,979.5 1022.67,986.167 1020,992.5C1017.33,998.833 1013.75,1004.33 1009.25,1009C1004.75,1013.67 999.333,1017.33 993,1020C986.667,1022.67 980,1024 973,1024C958.667,1024 946.5,1019 936.5,1009Z");
			add_location(path, file, 104, 5, 3453);
			attr_dev(svg, "aria-hidden", "true");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "12");
			attr_dev(svg, "height", "12");
			attr_dev(svg, "viewBox", "0 0 1024 1024");
			attr_dev(svg, "class", "svelte-fp4fp6");
			add_location(svg, file, 97, 4, 3311);
			attr_dev(button, "class", "info-bar-close-button svelte-fp4fp6");
			attr_dev(button, "type", "button");
			attr_dev(button, "aria-label", "Close");
			add_location(button, file, 90, 3, 3148);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, svg);
			append_dev(svg, path);
			/*button_binding*/ ctx[24](button);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[23], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			/*button_binding*/ ctx[24](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(90:2) {#if closable}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*open*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*open*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*open*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let actionWrapped;
	let messageWrapped;

	const omit_props_names = [
		"open","closable","severity","title","message","class","element","titleElement","messageElement","actionElement","closeButtonElement"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('InfoBar', slots, ['icon','default','action']);
	const $$slots = compute_slots(slots);
	let { open = true } = $$props;
	let { closable = true } = $$props;
	let { severity = "information" } = $$props;
	let { title = "" } = $$props;
	let { message = "" } = $$props;
	let { class: className = "" } = $$props;
	let { element = null } = $$props;
	let { titleElement = null } = $$props;
	let { messageElement = null } = $$props;
	let { actionElement = null } = $$props;
	let { closeButtonElement = null } = $$props;
	let wrapped = false;
	let clientHeight = 0;
	const dispatch = createEventDispatcher();
	const forwardEvents = createEventForwarder(get_current_component());

	function h5_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			titleElement = $$value;
			$$invalidate(1, titleElement);
		});
	}

	function p_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			messageElement = $$value;
			$$invalidate(2, messageElement);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			actionElement = $$value;
			$$invalidate(3, actionElement);
		});
	}

	const click_handler = () => $$invalidate(0, open = false);

	function button_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			closeButtonElement = $$value;
			$$invalidate(5, closeButtonElement);
		});
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(4, element);
		});
	}

	function div2_elementresize_handler() {
		clientHeight = this.clientHeight;
		$$invalidate(11, clientHeight);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('open' in $$new_props) $$invalidate(0, open = $$new_props.open);
		if ('closable' in $$new_props) $$invalidate(6, closable = $$new_props.closable);
		if ('severity' in $$new_props) $$invalidate(7, severity = $$new_props.severity);
		if ('title' in $$new_props) $$invalidate(8, title = $$new_props.title);
		if ('message' in $$new_props) $$invalidate(9, message = $$new_props.message);
		if ('class' in $$new_props) $$invalidate(10, className = $$new_props.class);
		if ('element' in $$new_props) $$invalidate(4, element = $$new_props.element);
		if ('titleElement' in $$new_props) $$invalidate(1, titleElement = $$new_props.titleElement);
		if ('messageElement' in $$new_props) $$invalidate(2, messageElement = $$new_props.messageElement);
		if ('actionElement' in $$new_props) $$invalidate(3, actionElement = $$new_props.actionElement);
		if ('closeButtonElement' in $$new_props) $$invalidate(5, closeButtonElement = $$new_props.closeButtonElement);
		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		get_current_component,
		createEventForwarder,
		InfoBadge,
		open,
		closable,
		severity,
		title,
		message,
		className,
		element,
		titleElement,
		messageElement,
		actionElement,
		closeButtonElement,
		wrapped,
		clientHeight,
		dispatch,
		forwardEvents,
		messageWrapped,
		actionWrapped
	});

	$$self.$inject_state = $$new_props => {
		if ('open' in $$props) $$invalidate(0, open = $$new_props.open);
		if ('closable' in $$props) $$invalidate(6, closable = $$new_props.closable);
		if ('severity' in $$props) $$invalidate(7, severity = $$new_props.severity);
		if ('title' in $$props) $$invalidate(8, title = $$new_props.title);
		if ('message' in $$props) $$invalidate(9, message = $$new_props.message);
		if ('className' in $$props) $$invalidate(10, className = $$new_props.className);
		if ('element' in $$props) $$invalidate(4, element = $$new_props.element);
		if ('titleElement' in $$props) $$invalidate(1, titleElement = $$new_props.titleElement);
		if ('messageElement' in $$props) $$invalidate(2, messageElement = $$new_props.messageElement);
		if ('actionElement' in $$props) $$invalidate(3, actionElement = $$new_props.actionElement);
		if ('closeButtonElement' in $$props) $$invalidate(5, closeButtonElement = $$new_props.closeButtonElement);
		if ('wrapped' in $$props) $$invalidate(14, wrapped = $$new_props.wrapped);
		if ('clientHeight' in $$props) $$invalidate(11, clientHeight = $$new_props.clientHeight);
		if ('messageWrapped' in $$props) $$invalidate(12, messageWrapped = $$new_props.messageWrapped);
		if ('actionWrapped' in $$props) $$invalidate(13, actionWrapped = $$new_props.actionWrapped);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*clientHeight, actionElement*/ 2056) {
			$: $$invalidate(13, actionWrapped = clientHeight && (actionElement === null || actionElement === void 0
			? void 0
			: actionElement.offsetTop) > 0);
		}

		if ($$self.$$.dirty & /*clientHeight, messageElement, titleElement*/ 2054) {
			$: $$invalidate(12, messageWrapped = clientHeight && (messageElement === null || messageElement === void 0
			? void 0
			: messageElement.offsetTop) > (titleElement === null || titleElement === void 0
			? void 0
			: titleElement.offsetTop));
		}

		if ($$self.$$.dirty & /*open*/ 1) {
			$: if (open) {
				dispatch("open");
			} else {
				dispatch("close");
			}
		}
	};

	return [
		open,
		titleElement,
		messageElement,
		actionElement,
		element,
		closeButtonElement,
		closable,
		severity,
		title,
		message,
		className,
		clientHeight,
		messageWrapped,
		actionWrapped,
		wrapped,
		forwardEvents,
		$$restProps,
		$$slots,
		$$scope,
		slots,
		h5_binding,
		p_binding,
		div_binding,
		click_handler,
		button_binding,
		div2_binding,
		div2_elementresize_handler
	];
}

class InfoBar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				open: 0,
				closable: 6,
				severity: 7,
				title: 8,
				message: 9,
				class: 10,
				element: 4,
				titleElement: 1,
				messageElement: 2,
				actionElement: 3,
				closeButtonElement: 5
			},
			add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InfoBar",
			options,
			id: create_fragment.name
		});
	}

	get open() {
		throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closable() {
		throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closable(value) {
		throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get severity() {
		throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set severity(value) {
		throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get message() {
		throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set message(value) {
		throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get element() {
		throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set element(value) {
		throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get titleElement() {
		throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set titleElement(value) {
		throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get messageElement() {
		throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set messageElement(value) {
		throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get actionElement() {
		throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set actionElement(value) {
		throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeButtonElement() {
		throw new Error("<InfoBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeButtonElement(value) {
		throw new Error("<InfoBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default InfoBar;