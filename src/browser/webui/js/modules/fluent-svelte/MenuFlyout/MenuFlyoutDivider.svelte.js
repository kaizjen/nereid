/* MenuFlyoutDivider.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	add_location,
	append_styles,
	assign,
	binding_callbacks,
	compute_rest_props,
	detach_dev,
	dispatch_dev,
	element as element_1,
	exclude_internal_props,
	get_spread_update,
	init,
	insert_dev,
	noop,
	safe_not_equal,
	set_attributes,
	toggle_class,
	validate_slots
} from "nereid://.svelte/internal/index.mjs";

const file = "MenuFlyoutDivider.svelte";

function add_css(target) {
	append_styles(target, "svelte-1fs8gxj", ".menu-flyout-divider.svelte-1fs8gxj{-webkit-border-before:1px solid var(--fds-divider-stroke-default);block-size:1px;border:none;border-block-start:1px solid var(--fds-divider-stroke-default);inline-size:100%;margin-block:2px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVudUZseW91dERpdmlkZXIuc3ZlbHRlIiwic291cmNlcyI6WyJNZW51Rmx5b3V0RGl2aWRlci5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCA+LyoqIFNwZWNpZmllcyBhIGN1c3RvbSBjbGFzcyBuYW1lIGZvciB0aGUgZGl2aWRlci4gKi9cclxubGV0IGNsYXNzTmFtZSA9IFwiXCI7XHJcbmV4cG9ydCB7IGNsYXNzTmFtZSBhcyBjbGFzcyB9O1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIGRpdmlkZXIncyBlbGVtZW50LiAqL1xyXG5leHBvcnQgbGV0IGVsZW1lbnQgPSBudWxsO1xyXG48L3NjcmlwdD5cblxuPGhyIGNsYXNzPVwibWVudS1mbHlvdXQtZGl2aWRlciB7Y2xhc3NOYW1lfVwiIGJpbmQ6dGhpcz17ZWxlbWVudH0gey4uLiQkcmVzdFByb3BzfSAvPlxuXG48c3R5bGUgPi5tZW51LWZseW91dC1kaXZpZGVyey13ZWJraXQtYm9yZGVyLWJlZm9yZToxcHggc29saWQgdmFyKC0tZmRzLWRpdmlkZXItc3Ryb2tlLWRlZmF1bHQpO2Jsb2NrLXNpemU6MXB4O2JvcmRlcjpub25lO2JvcmRlci1ibG9jay1zdGFydDoxcHggc29saWQgdmFyKC0tZmRzLWRpdmlkZXItc3Ryb2tlLWRlZmF1bHQpO2lubGluZS1zaXplOjEwMCU7bWFyZ2luLWJsb2NrOjJweH08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVNRLG1DQUFvQixDQUFDLHNCQUFzQixHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksNEJBQTRCLENBQUMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxPQUFPLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLDRCQUE0QixDQUFDLENBQUMsWUFBWSxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMifQ== */");
}

function create_fragment(ctx) {
	let hr;
	let hr_class_value;

	let hr_levels = [
		{
			class: hr_class_value = "menu-flyout-divider " + /*className*/ ctx[1]
		},
		/*$$restProps*/ ctx[2]
	];

	let hr_data = {};

	for (let i = 0; i < hr_levels.length; i += 1) {
		hr_data = assign(hr_data, hr_levels[i]);
	}

	const block = {
		c: function create() {
			hr = element_1("hr");
			set_attributes(hr, hr_data);
			toggle_class(hr, "svelte-1fs8gxj", true);
			add_location(hr, file, 7, 0, 220);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, hr, anchor);
			/*hr_binding*/ ctx[3](hr);
		},
		p: function update(ctx, [dirty]) {
			set_attributes(hr, hr_data = get_spread_update(hr_levels, [
				dirty & /*className*/ 2 && hr_class_value !== (hr_class_value = "menu-flyout-divider " + /*className*/ ctx[1]) && { class: hr_class_value },
				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
			]));

			toggle_class(hr, "svelte-1fs8gxj", true);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(hr);
			/*hr_binding*/ ctx[3](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","element"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MenuFlyoutDivider', slots, []);
	let { class: className = "" } = $$props;
	let { element = null } = $$props;

	function hr_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
	};

	$$self.$capture_state = () => ({ className, element });

	$$self.$inject_state = $$new_props => {
		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [element, className, $$restProps, hr_binding];
}

class MenuFlyoutDivider extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { class: 1, element: 0 }, add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MenuFlyoutDivider",
			options,
			id: create_fragment.name
		});
	}

	get class() {
		throw new Error("<MenuFlyoutDivider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<MenuFlyoutDivider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get element() {
		throw new Error("<MenuFlyoutDivider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set element(value) {
		throw new Error("<MenuFlyoutDivider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default MenuFlyoutDivider;