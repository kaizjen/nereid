/* MenuFlyoutItem.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	action_destroyer,
	add_flush_callback,
	add_location,
	append_dev,
	append_styles,
	assign,
	attr_dev,
	bind,
	binding_callbacks,
	bubble,
	check_outros,
	compute_rest_props,
	compute_slots,
	create_component,
	create_slot,
	destroy_component,
	detach_dev,
	dispatch_dev,
	element as element_1,
	empty,
	exclude_internal_props,
	get_all_dirty_from_scope,
	get_binding_group_value,
	get_slot_changes,
	get_spread_update,
	group_outros,
	init,
	insert_dev,
	listen_dev,
	mount_component,
	prop_dev,
	run_all,
	safe_not_equal,
	set_attributes,
	set_data_dev,
	set_input_value,
	space,
	svg_element,
	text,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base,
	validate_slots
} from "nereid://.svelte/internal/index.mjs";

import { createEventDispatcher, getContext } from "nereid://.svelte/index.mjs";
import { get_current_component } from "nereid://.svelte/internal/index.mjs";
import { arrowNavigation, uid, createEventForwarder } from "../internal.js";
import { tabbable } from "../../tabbable/dist/index.esm.js";
import MenuFlyoutSurface from "../MenuFlyout/MenuFlyoutSurface.svelte.js";
import TextBlock from "../TextBlock/TextBlock.svelte.js";
const file = "MenuFlyoutItem.svelte";

function add_css(target) {
	append_styles(target, "svelte-s7v067", ".menu-flyout-item.svelte-s7v067.svelte-s7v067{align-items:center;background-color:var(--fds-subtle-fill-transparent);block-size:28px;border-radius:var(--fds-control-corner-radius);box-sizing:border-box;color:var(--fds-text-primary);cursor:default;display:flex;flex:0 0 auto;font-family:var(--fds-font-family-text);font-size:var(--fds-body-font-size);font-weight:400;inline-size:calc(100% - 8px);line-height:20px;margin:2px 4px;outline:none;padding-inline:12px;position:relative;text-decoration:none;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.menu-flyout-item.svelte-s7v067.svelte-s7v067:before{background-color:var(--fds-accent-default);block-size:0;border-radius:3px;content:\"\";inline-size:3px;inset-inline-start:0;opacity:0;position:absolute;transition:transform var(--fds-control-fast-duration) var(--fds-control-fast-out-slow-in-easing)}.menu-flyout-item.svelte-s7v067.svelte-s7v067:focus-visible{box-shadow:var(--fds-focus-stroke)}.menu-flyout-item.selected.svelte-s7v067.svelte-s7v067,.menu-flyout-item.svelte-s7v067.svelte-s7v067:hover,.menu-flyout-item[aria-expanded=true].svelte-s7v067.svelte-s7v067{background-color:var(--fds-subtle-fill-secondary)}.menu-flyout-item.checked.svelte-s7v067 .menu-flyout-item-bullet,.menu-flyout-item.checked.svelte-s7v067 .menu-flyout-item-checkmark{visibility:visible}.menu-flyout-item.svelte-s7v067.svelte-s7v067:active{background-color:var(--fds-subtle-fill-tertiary)}.menu-flyout-item.svelte-s7v067.svelte-s7v067:active:before{transform:scaleY(.625)}.menu-flyout-item.disabled.svelte-s7v067.svelte-s7v067{background-color:var(--fds-subtle-fill-transparent);color:var(--fds-text-disabled);pointer-events:none}.menu-flyout-item.disabled.selected.svelte-s7v067.svelte-s7v067{background-color:var(--fds-subtle-fill-secondary)}.menu-flyout-item.disabled.selected.svelte-s7v067.svelte-s7v067:before{background-color:var(--fds-accent-disabled)}.menu-flyout-item.disabled.svelte-s7v067>.menu-flyout-item-hint{color:var(--fds-text-disabled)}.menu-flyout-item.selected.svelte-s7v067.svelte-s7v067:before{block-size:16px;opacity:1}.menu-flyout-item.indented.svelte-s7v067.svelte-s7v067{-webkit-padding-start:40px;padding-inline-start:40px}.menu-flyout-item-bullet.svelte-s7v067.svelte-s7v067,.menu-flyout-item-checkmark.svelte-s7v067.svelte-s7v067{visibility:hidden}.menu-flyout-item.svelte-s7v067 .menu-flyout-item-arrow.svelte-s7v067{-webkit-margin-end:0;-webkit-margin-start:auto;-webkit-padding-start:24px;block-size:12px;box-sizing:content-box;inline-size:12px;margin-inline-end:0;margin-inline-start:auto;padding-inline-start:24px}.menu-flyout-item-checkmark.svelte-s7v067.svelte-s7v067{-webkit-margin-start:2px;-webkit-margin-end:14px;align-items:center;block-size:12px;display:flex;inline-size:12px;justify-content:center;margin-inline-end:14px;margin-inline-start:2px}.menu-flyout-item-bullet.svelte-s7v067.svelte-s7v067{-webkit-margin-start:6px;-webkit-margin-end:18px;background-color:currentColor;block-size:4px;border-radius:4px;inline-size:4px;margin-inline-end:18px;margin-inline-start:6px}.menu-flyout-item-input-label.svelte-s7v067.svelte-s7v067{display:contents}.menu-flyout-item.svelte-s7v067>svg{fill:currentColor;-webkit-margin-end:12px;block-size:auto;inline-size:16px;margin-inline-end:12px}.menu-flyout-item.svelte-s7v067>.menu-flyout-item-hint{color:var(--fds-text-secondary);flex:1 1 auto;overflow:hidden;padding-left:24px;text-align:end;text-overflow:ellipsis}.menu-flyout-submenu-anchor.svelte-s7v067.svelte-s7v067{--fds-menu-flyout-transition-offset:-50%;inset-block-start:0;inset-inline-start:100%;position:absolute;z-index:10000}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVudUZseW91dEl0ZW0uc3ZlbHRlIiwic291cmNlcyI6WyJNZW51Rmx5b3V0SXRlbS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCA+aW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBnZXRDb250ZXh0IH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG5pbXBvcnQgeyBnZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tIFwic3ZlbHRlL2ludGVybmFsXCI7XHJcbmltcG9ydCB7IGFycm93TmF2aWdhdGlvbiwgdWlkLCBjcmVhdGVFdmVudEZvcndhcmRlciB9IGZyb20gXCIuLi9pbnRlcm5hbFwiO1xyXG5pbXBvcnQgeyB0YWJiYWJsZSB9IGZyb20gXCJ0YWJiYWJsZVwiO1xyXG5pbXBvcnQgTWVudUZseW91dFN1cmZhY2UgZnJvbSBcIi4uL01lbnVGbHlvdXQvTWVudUZseW91dFN1cmZhY2Uuc3ZlbHRlXCI7XHJcbmltcG9ydCBUZXh0QmxvY2sgZnJvbSBcIi4uL1RleHRCbG9jay9UZXh0QmxvY2suc3ZlbHRlXCI7XHJcbi8qKiBTcGVjaWZpZXMgYW4gaW5wdXQgdHlwZSBmb3IgdGhlIGl0ZW0uICovXHJcbmV4cG9ydCBsZXQgdmFyaWFudCA9IFwic3RhbmRhcmRcIjtcclxuLyoqIE1hcmtzIHRoZSBpdGVtIGFzIGhhdmluZyBhIGNhc2NhZGluZyBzdWJtZW51IGF0dGFjaGVkIHRvIGl0LCBhbmQgbWFrZXMgdGhlIGBmbHlvdXRgIHNsb3QgYXZhaWxhYmxlLiAqL1xyXG5leHBvcnQgbGV0IGNhc2NhZGluZyA9IGZhbHNlO1xyXG4vKiogU2Vjb25kYXJ5IGhpbnQgdGV4dCBkaXNwbGF5ZWQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBpdGVtLiBVc2VmdWwgZm9yIGRpc3BsYXlpbmcga2V5Ym9hcmQgYWNjZWxlcmF0b3JzLiAqL1xyXG5leHBvcnQgbGV0IGhpbnQgPSB1bmRlZmluZWQ7XHJcbi8qKiBTcGVjaWZpZXMgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIHN0eWxlZCBhcyBzZWxlY3RlZCBieSB0aGUgdXNlci4gKi9cclxuZXhwb3J0IGxldCBzZWxlY3RlZCA9IGZhbHNlO1xyXG4vKiogTWFya3MgYSByYWRpbyBvciB0b2dnbGUgdmFyaWFudCBpdGVtIGFzIGNoZWNrZWQuICovXHJcbmV4cG9ydCBsZXQgY2hlY2tlZCA9IGZhbHNlO1xyXG4vKiogSW5kZW50cyB0aGUgbGVmdCBwYWRkaW5nIG9mIHRoZSBpdGVtIG1ha2luZyBpdCdzIHRleHQgaW5saW5lIHdpdGggdGhlIGFkZGVkIGljb25zIG9mIG90aGVyIGl0ZW1zLiAqL1xyXG5leHBvcnQgbGV0IGluZGVudGVkID0gZmFsc2U7XHJcbi8qKiBTcGVjaWZpZXMgYSByYWRpbyBpbnB1dCBncm91cCB0aGF0IHRoZSBpdGVtIHNob3VsZCBiZSBib3VuZCB0by4gT25seSB2YWxpZCBpZiBgdmFyaWFudGAgaXMgc2V0IHRvIGByYWRpb2AuICovXHJcbmV4cG9ydCBsZXQgZ3JvdXAgPSBbXTtcclxuLyoqIFNwZWNpZmllcyBhIGZvcm0gaW5wdXQgdmFsdWUgYXR0cmlidXRlIGlmIGB2YXJpYW50YCBpcyBzZXQgdG8gYHRvZ2dsZWAgb3IgYHJhZGlvYC4gKi9cclxuZXhwb3J0IGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcclxuLyoqIENvbnRyb2xzIHdoZXRoZXIgdGhlIGl0ZW0gaXMgaW50ZW5kZWQgZm9yIHVzZXIgaW50ZXJhY3Rpb24sIGFuZCBzdHlsZXMgaXQgYWNjb3JkaW5nbHkuICovXHJcbmV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcclxuLyoqIFRoZSBjdXJyZW50IHZpc2liaWxpdHkgc3RhdGUgb2YgYSBjYXNjYWRpbmcgc3VibWVudS4gT25seSB2YWxpZCBpcyBgY2FzY2FkaW5nYCBpcyB0cnVlLiAqL1xyXG5leHBvcnQgbGV0IG9wZW4gPSBmYWxzZTtcclxuLyoqIElOVEVSTkFMIFVTRSBPTkxZOiBDb21tdW5pY2F0ZXMgdG8gdGhlIHdyYXBwZWQgPHN2ZWx0ZTpzZWxmIC8+IGluc3RhbmNlIHRoYXQgdGhlIGl0ZW0gdmFyaWFudCBzaG91bGQgbm90IGJlIHJlY3Vyc2l2ZWx5IHJlbmRlcmVkLiAqL1xyXG5leHBvcnQgbGV0IF9fZGVwdGggPSBmYWxzZTtcclxuLyoqIFNwZWNpZmllcyBhIGN1c3RvbSBjbGFzcyBuYW1lIGZvciB0aGUgaXRlbS4gKi9cclxubGV0IGNsYXNzTmFtZSA9IFwiXCI7XHJcbmV4cG9ydCB7IGNsYXNzTmFtZSBhcyBjbGFzcyB9O1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIGl0ZW0ncyBtYWluIGNvbnRhaW5lci4gKi9cclxuZXhwb3J0IGxldCBlbGVtZW50ID0gbnVsbDtcclxuLyoqIE9idGFpbnMgYSBib3VuZCBET00gcmVmZXJlbmNlIHRvIHRoZSBpdGVtJ3MgaW5wdXQgZWxlbWVudCwgd2hpY2ggaXMgcHJlc2VudCBpZiBgdmFyaWFudGAgaXMgc2V0IHRvIGB0b2dnbGVgIG9yIGByYWRpb2AuICovXHJcbmV4cG9ydCBsZXQgaW5wdXRFbGVtZW50ID0gbnVsbDtcclxuLyoqIE9idGFpbnMgYSBib3VuZCBET00gcmVmZXJlbmNlIHRvIHRoZSBpdGVtJ3Mgb3V0ZXIgbGFiZWwsIHdoaWNoIGlzIHByZXNlbnQgaWYgYHZhcmlhbnRgIGlzIHNldCB0byBgdG9nZ2xlYCBvciBgcmFkaW9gLiAqL1xyXG5leHBvcnQgbGV0IGlucHV0TGFiZWxFbGVtZW50ID0gbnVsbDtcclxuLyoqIE9idGFpbnMgYSBib3VuZCBET00gcmVmZXJlbmNlIHRvIHRoZSBpdGVtJ3Mgc3VibWVudSBhbmNob3IgZWxlbWVudCwgd2hpY2ggaXMgcHJlc2VudCBpZiB0aGUgaXRlbSBpcyBjYXNjYWRpbmcgYW5kIHRoZSBzdWJtZW51IGlzIHZpc2libGUuICovXHJcbmV4cG9ydCBsZXQgc3ViTWVudUFuY2hvckVsZW1lbnQgPSBudWxsO1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIHN1Ym1lbnVtZW51IGVsZW1lbnQsIHdoaWNoIGlzIHByZXNlbnQgaWYgdGhlIGl0ZW0gaXMgY2FzY2FkaW5nIGFuZCB0aGUgc3VibWVudSBpcyB2aXNpYmxlLiAqL1xyXG5leHBvcnQgbGV0IHN1Yk1lbnVFbGVtZW50ID0gbnVsbDtcclxuY29uc3QgZm9yd2FyZEV2ZW50cyA9IGNyZWF0ZUV2ZW50Rm9yd2FyZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpKTtcclxuY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcclxuY29uc3QgY2xvc2VGbHlvdXQgPSBnZXRDb250ZXh0KFwiY2xvc2VGbHlvdXRcIik7XHJcbmNvbnN0IG1lbnVJZCA9IHVpZChcImZkcy1tZW51LWZseW91dC1zdWJtZW51LVwiKTtcclxubGV0IG1lbnUgPSBudWxsO1xyXG5sZXQgc3ViTWVudVF1ZXVlID0ge1xyXG4gICAgb3BlbjogZmFsc2UsXHJcbiAgICBjbG9zZTogZmFsc2VcclxufTtcclxuJDogZGlzcGF0Y2gob3BlbiA/IFwib3BlblwiIDogXCJjbG9zZVwiKTtcclxuJDogaWYgKG9wZW4gJiYgbWVudSAmJiB0YWJiYWJsZShzdWJNZW51RWxlbWVudCkubGVuZ3RoID4gMClcclxuICAgIHRhYmJhYmxlKHN1Yk1lbnVFbGVtZW50KVswXS5mb2N1cygpO1xyXG5mdW5jdGlvbiBjbG9zZShldmVudCkge1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjYXNjYWRpbmcgJiYgY2xvc2VGbHlvdXQpXHJcbiAgICAgICAgICAgIGNsb3NlRmx5b3V0KGV2ZW50KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcclxuICAgIGNvbnN0IHsga2V5LCB0YXJnZXQgfSA9IGV2ZW50O1xyXG4gICAgaWYgKGtleSA9PT0gXCJFbnRlclwiIHx8IGtleSA9PT0gXCIgXCIpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHRhcmdldC5jbGljaygpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNhc2NhZGluZykge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiQXJyb3dSaWdodFwiKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBvcGVuID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3BlbiAmJiBrZXkgPT09IFwiQXJyb3dMZWZ0XCIpIHtcclxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIG9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgZWxlbWVudC5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYW5kbGVNb3VzZUVudGVyKCkge1xyXG4gICAgc3ViTWVudVF1ZXVlLmNsb3NlID0gZmFsc2U7XHJcbiAgICBzdWJNZW51UXVldWUub3BlbiA9IHRydWU7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAoc3ViTWVudVF1ZXVlLm9wZW4pXHJcbiAgICAgICAgICAgIG9wZW4gPSB0cnVlO1xyXG4gICAgfSwgNTAwKTtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVNb3VzZUxlYXZlKCkge1xyXG4gICAgc3ViTWVudVF1ZXVlLmNsb3NlID0gdHJ1ZTtcclxuICAgIHN1Yk1lbnVRdWV1ZS5vcGVuID0gZmFsc2U7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAoc3ViTWVudVF1ZXVlLmNsb3NlKVxyXG4gICAgICAgICAgICBvcGVuID0gZmFsc2U7XHJcbiAgICB9LCA1MDApO1xyXG59XHJcbjwvc2NyaXB0PlxuXG57I2lmIHZhcmlhbnQgPT09IFwic3RhbmRhcmRcIiB8fCBfX2RlcHRofVxuXHQ8bGlcblx0XHR0YWJpbmRleD17ZGlzYWJsZWQgPyAtMSA6IDB9XG5cdFx0cm9sZT1cIm1lbnVpdGVtXCJcblx0XHRhcmlhLWV4cGFuZGVkPXskJHNsb3RzLmZseW91dCAmJiAhZGlzYWJsZWQgJiYgb3Blbn1cblx0XHRhcmlhLWhhc3BvcHVwPXskJHNsb3RzLmZseW91dCAmJiAhZGlzYWJsZWQgJiYgb3Blbn1cblx0XHRhcmlhLWNvbnRyb2xzPXskJHNsb3RzLmZseW91dCAmJiAhZGlzYWJsZWQgJiYgbWVudUlkfVxuXHRcdGFyaWEtc2VsZWN0ZWQ9e3NlbGVjdGVkIHx8IGNoZWNrZWR9XG5cdFx0Y2xhc3M9XCJtZW51LWZseW91dC1pdGVtIHR5cGUte3ZhcmlhbnR9IHtjbGFzc05hbWV9XCJcblx0XHRjbGFzczpjYXNjYWRpbmdcblx0XHRjbGFzczpzZWxlY3RlZFxuXHRcdGNsYXNzOmNoZWNrZWRcblx0XHRjbGFzczpkaXNhYmxlZFxuXHRcdGNsYXNzOmluZGVudGVkXG5cdFx0dXNlOmZvcndhcmRFdmVudHNcblx0XHRiaW5kOnRoaXM9e2VsZW1lbnR9XG5cdFx0b246Y2xpY2s9e2Nsb3NlfVxuXHRcdG9uOm1vdXNlZW50ZXI9e2hhbmRsZU1vdXNlRW50ZXJ9XG5cdFx0b246bW91c2VsZWF2ZT17aGFuZGxlTW91c2VMZWF2ZX1cblx0XHRvbjprZXlkb3duPXtoYW5kbGVLZXlEb3dufVxuXHRcdHsuLi4kJHJlc3RQcm9wc31cblx0PlxuXHRcdDxzbG90IG5hbWU9XCJpY29uXCIgLz5cblx0XHQ8c2xvdCAvPlxuXHRcdHsjaWYgaGludH1cblx0XHRcdDxUZXh0QmxvY2sgY2xhc3M9XCJtZW51LWZseW91dC1pdGVtLWhpbnRcIiB2YXJpYW50PVwiY2FwdGlvblwiPntoaW50fTwvVGV4dEJsb2NrPlxuXHRcdHsvaWZ9XG5cdFx0eyNpZiBjYXNjYWRpbmd9XG5cdFx0XHQ8c3ZnXG5cdFx0XHRcdGNsYXNzPVwibWVudS1mbHlvdXQtaXRlbS1hcnJvd1wiXG5cdFx0XHRcdHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuXHRcdFx0XHR3aWR0aD1cIjEyXCJcblx0XHRcdFx0aGVpZ2h0PVwiMTJcIlxuXHRcdFx0XHR2aWV3Qm94PVwiMCAwIDEyIDEyXCJcblx0XHRcdFx0ZmlsbD1cIm5vbmVcIlxuXHRcdFx0PlxuXHRcdFx0XHQ8cGF0aFxuXHRcdFx0XHRcdGQ9XCJNNC42NDY0NSAyLjE0NjQ1QzQuNDUxMTggMi4zNDE3MSA0LjQ1MTE4IDIuNjU4MjkgNC42NDY0NSAyLjg1MzU1TDcuNzkyODkgNkw0LjY0NjQ1IDkuMTQ2NDVDNC40NTExOCA5LjM0MTcxIDQuNDUxMTggOS42NTgyOSA0LjY0NjQ1IDkuODUzNTVDNC44NDE3MSAxMC4wNDg4IDUuMTU4MjkgMTAuMDQ4OCA1LjM1MzU1IDkuODUzNTVMOC44NTM1NSA2LjM1MzU1QzkuMDQ4ODIgNi4xNTgyOSA5LjA0ODgyIDUuODQxNzEgOC44NTM1NSA1LjY0NjQ1TDUuMzUzNTUgMi4xNDY0NUM1LjE1ODI5IDEuOTUxMTggNC44NDE3MSAxLjk1MTE4IDQuNjQ2NDUgMi4xNDY0NVpcIlxuXHRcdFx0XHRcdGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuXHRcdFx0XHQvPlxuXHRcdFx0PC9zdmc+XG5cdFx0XHR7I2lmIG9wZW4gJiYgJCRzbG90cy5mbHlvdXQgJiYgIWRpc2FibGVkfVxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0dXNlOmFycm93TmF2aWdhdGlvbj17eyBwcmV2ZW50VGFiOiB0cnVlLCBzdG9wUHJvcGFnYXRpb246IHRydWUgfX1cblx0XHRcdFx0XHRiaW5kOnRoaXM9e3N1Yk1lbnVBbmNob3JFbGVtZW50fVxuXHRcdFx0XHRcdGlkPXttZW51SWR9XG5cdFx0XHRcdFx0Y2xhc3M9XCJtZW51LWZseW91dC1zdWJtZW51LWFuY2hvclwiXG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8TWVudUZseW91dFN1cmZhY2UgYmluZDplbGVtZW50PXtzdWJNZW51RWxlbWVudH0gYmluZDp0aGlzPXttZW51fT5cblx0XHRcdFx0XHRcdDxzbG90IG5hbWU9XCJmbHlvdXRcIiAvPlxuXHRcdFx0XHRcdDwvTWVudUZseW91dFN1cmZhY2U+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0ey9pZn1cblx0XHR7L2lmfVxuXHQ8L2xpPlxuezplbHNlIGlmIHZhcmlhbnQgPT09IFwicmFkaW9cIiB8fCB2YXJpYW50ID09PSBcInRvZ2dsZVwifVxuXHQ8IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeS1sYWJlbC1oYXMtYXNzb2NpYXRlZC1jb250cm9sIC0tPlxuXHQ8bGFiZWwgYmluZDp0aGlzPXtpbnB1dExhYmVsRWxlbWVudH0gY2xhc3M9XCJtZW51LWZseW91dC1pdGVtLWlucHV0LWxhYmVsXCI+XG5cdFx0PHN2ZWx0ZTpzZWxmXG5cdFx0XHRjaGVja2VkPXtjaGVja2VkIHx8IGdyb3VwID09PSB2YWx1ZX1cblx0XHRcdHtzZWxlY3RlZH1cblx0XHRcdHt2YXJpYW50fVxuXHRcdFx0e2luZGVudGVkfVxuXHRcdFx0e2dyb3VwfVxuXHRcdFx0e2Rpc2FibGVkfVxuXHRcdFx0X19kZXB0aFxuXHRcdD5cblx0XHRcdDxzbG90IG5hbWU9XCJpY29uXCIgc2xvdD1cImljb25cIiAvPlxuXHRcdFx0PGRpdiBjbGFzcz1cIm1lbnUtZmx5b3V0LWl0ZW0te3ZhcmlhbnQgPT09ICdyYWRpbycgPyAnYnVsbGV0JyA6ICdjaGVja21hcmsnfVwiPlxuXHRcdFx0XHR7I2lmIHZhcmlhbnQgPT09IFwidG9nZ2xlXCJ9XG5cdFx0XHRcdFx0PHN2Z1xuXHRcdFx0XHRcdFx0d2lkdGg9XCIxMlwiXG5cdFx0XHRcdFx0XHRoZWlnaHQ9XCIxMlwiXG5cdFx0XHRcdFx0XHR2aWV3Qm94PVwiMCAwIDEyIDEyXCJcblx0XHRcdFx0XHRcdGZpbGw9XCJub25lXCJcblx0XHRcdFx0XHRcdHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxwYXRoXG5cdFx0XHRcdFx0XHRcdGQ9XCJNOS44NTM1NSAzLjE0NjQ1QzEwLjA0ODggMy4zNDE3MSAxMC4wNDg4IDMuNjU4MjkgOS44NTM1NSAzLjg1MzU1TDUuMzUzNTUgOC4zNTM1NUM1LjE1ODI5IDguNTQ4ODIgNC44NDE3MSA4LjU0ODgyIDQuNjQ2NDUgOC4zNTM1NUwyLjY0NjQ1IDYuMzUzNTVDMi40NTExOCA2LjE1ODI5IDIuNDUxMTggNS44NDE3MSAyLjY0NjQ1IDUuNjQ2NDVDMi44NDE3MSA1LjQ1MTE4IDMuMTU4MjkgNS40NTExOCAzLjM1MzU1IDUuNjQ2NDVMNSA3LjI5Mjg5TDkuMTQ2NDUgMy4xNDY0NUM5LjM0MTcxIDIuOTUxMTggOS42NTgyOSAyLjk1MTE4IDkuODUzNTUgMy4xNDY0NVpcIlxuXHRcdFx0XHRcdFx0XHRmaWxsPVwiY3VycmVudENvbG9yXCJcblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9zdmc+XG5cdFx0XHRcdHsvaWZ9XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxzbG90IC8+XG5cdFx0PC9zdmVsdGU6c2VsZj5cblxuXHRcdHsjaWYgdmFyaWFudCA9PT0gXCJyYWRpb1wifVxuXHRcdFx0PGlucHV0XG5cdFx0XHRcdHR5cGU9XCJyYWRpb1wiXG5cdFx0XHRcdGhpZGRlblxuXHRcdFx0XHRvbjpjaGFuZ2Vcblx0XHRcdFx0b246aW5wdXRcblx0XHRcdFx0b246YmVmb3JlaW5wdXRcblx0XHRcdFx0YmluZDpncm91cFxuXHRcdFx0XHRiaW5kOnRoaXM9e2lucHV0RWxlbWVudH1cblx0XHRcdFx0e3ZhbHVlfVxuXHRcdFx0XHR7Y2hlY2tlZH1cblx0XHRcdFx0e2Rpc2FibGVkfVxuXHRcdFx0Lz5cblx0XHR7OmVsc2V9XG5cdFx0XHQ8aW5wdXRcblx0XHRcdFx0dHlwZT1cImNoZWNrYm94XCJcblx0XHRcdFx0aGlkZGVuXG5cdFx0XHRcdG9uOmNoYW5nZVxuXHRcdFx0XHRvbjppbnB1dFxuXHRcdFx0XHRvbjpiZWZvcmVpbnB1dFxuXHRcdFx0XHRiaW5kOnRoaXM9e2lucHV0RWxlbWVudH1cblx0XHRcdFx0YmluZDpncm91cFxuXHRcdFx0XHRiaW5kOmNoZWNrZWRcblx0XHRcdFx0YmluZDp2YWx1ZVxuXHRcdFx0XHR7ZGlzYWJsZWR9XG5cdFx0XHQvPlxuXHRcdHsvaWZ9XG5cdDwvbGFiZWw+XG57L2lmfVxuXG48c3R5bGUgPi5tZW51LWZseW91dC1pdGVte2FsaWduLWl0ZW1zOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZkcy1zdWJ0bGUtZmlsbC10cmFuc3BhcmVudCk7YmxvY2stc2l6ZToyOHB4O2JvcmRlci1yYWRpdXM6dmFyKC0tZmRzLWNvbnRyb2wtY29ybmVyLXJhZGl1cyk7Ym94LXNpemluZzpib3JkZXItYm94O2NvbG9yOnZhcigtLWZkcy10ZXh0LXByaW1hcnkpO2N1cnNvcjpkZWZhdWx0O2Rpc3BsYXk6ZmxleDtmbGV4OjAgMCBhdXRvO2ZvbnQtZmFtaWx5OnZhcigtLWZkcy1mb250LWZhbWlseS10ZXh0KTtmb250LXNpemU6dmFyKC0tZmRzLWJvZHktZm9udC1zaXplKTtmb250LXdlaWdodDo0MDA7aW5saW5lLXNpemU6Y2FsYygxMDAlIC0gOHB4KTtsaW5lLWhlaWdodDoyMHB4O21hcmdpbjoycHggNHB4O291dGxpbmU6bm9uZTtwYWRkaW5nLWlubGluZToxMnB4O3Bvc2l0aW9uOnJlbGF0aXZlO3RleHQtZGVjb3JhdGlvbjpub25lO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3doaXRlLXNwYWNlOm5vd3JhcH0ubWVudS1mbHlvdXQtaXRlbTpiZWZvcmV7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtYWNjZW50LWRlZmF1bHQpO2Jsb2NrLXNpemU6MDtib3JkZXItcmFkaXVzOjNweDtjb250ZW50OlwiXCI7aW5saW5lLXNpemU6M3B4O2luc2V0LWlubGluZS1zdGFydDowO29wYWNpdHk6MDtwb3NpdGlvbjphYnNvbHV0ZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSB2YXIoLS1mZHMtY29udHJvbC1mYXN0LWR1cmF0aW9uKSB2YXIoLS1mZHMtY29udHJvbC1mYXN0LW91dC1zbG93LWluLWVhc2luZyl9Lm1lbnUtZmx5b3V0LWl0ZW06Zm9jdXMtdmlzaWJsZXtib3gtc2hhZG93OnZhcigtLWZkcy1mb2N1cy1zdHJva2UpfS5tZW51LWZseW91dC1pdGVtLnNlbGVjdGVkLC5tZW51LWZseW91dC1pdGVtOmhvdmVyLC5tZW51LWZseW91dC1pdGVtW2FyaWEtZXhwYW5kZWQ9dHJ1ZV17YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtc3VidGxlLWZpbGwtc2Vjb25kYXJ5KX0ubWVudS1mbHlvdXQtaXRlbS5jaGVja2VkIDpnbG9iYWwoLm1lbnUtZmx5b3V0LWl0ZW0tYnVsbGV0KSwubWVudS1mbHlvdXQtaXRlbS5jaGVja2VkIDpnbG9iYWwoLm1lbnUtZmx5b3V0LWl0ZW0tY2hlY2ttYXJrKXt2aXNpYmlsaXR5OnZpc2libGV9Lm1lbnUtZmx5b3V0LWl0ZW06YWN0aXZle2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLXN1YnRsZS1maWxsLXRlcnRpYXJ5KX0ubWVudS1mbHlvdXQtaXRlbTphY3RpdmU6YmVmb3Jle3RyYW5zZm9ybTpzY2FsZVkoLjYyNSl9Lm1lbnUtZmx5b3V0LWl0ZW0uZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mZHMtc3VidGxlLWZpbGwtdHJhbnNwYXJlbnQpO2NvbG9yOnZhcigtLWZkcy10ZXh0LWRpc2FibGVkKTtwb2ludGVyLWV2ZW50czpub25lfS5tZW51LWZseW91dC1pdGVtLmRpc2FibGVkLnNlbGVjdGVke2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLXN1YnRsZS1maWxsLXNlY29uZGFyeSl9Lm1lbnUtZmx5b3V0LWl0ZW0uZGlzYWJsZWQuc2VsZWN0ZWQ6YmVmb3Jle2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmRzLWFjY2VudC1kaXNhYmxlZCl9Lm1lbnUtZmx5b3V0LWl0ZW0uZGlzYWJsZWQ+Omdsb2JhbCgubWVudS1mbHlvdXQtaXRlbS1oaW50KXtjb2xvcjp2YXIoLS1mZHMtdGV4dC1kaXNhYmxlZCl9Lm1lbnUtZmx5b3V0LWl0ZW0uc2VsZWN0ZWQ6YmVmb3Jle2Jsb2NrLXNpemU6MTZweDtvcGFjaXR5OjF9Lm1lbnUtZmx5b3V0LWl0ZW0uaW5kZW50ZWR7LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OjQwcHg7cGFkZGluZy1pbmxpbmUtc3RhcnQ6NDBweH0ubWVudS1mbHlvdXQtaXRlbS1idWxsZXQsLm1lbnUtZmx5b3V0LWl0ZW0tY2hlY2ttYXJre3Zpc2liaWxpdHk6aGlkZGVufS5tZW51LWZseW91dC1pdGVtIC5tZW51LWZseW91dC1pdGVtLWFycm93ey13ZWJraXQtbWFyZ2luLWVuZDowOy13ZWJraXQtbWFyZ2luLXN0YXJ0OmF1dG87LXdlYmtpdC1wYWRkaW5nLXN0YXJ0OjI0cHg7YmxvY2stc2l6ZToxMnB4O2JveC1zaXppbmc6Y29udGVudC1ib3g7aW5saW5lLXNpemU6MTJweDttYXJnaW4taW5saW5lLWVuZDowO21hcmdpbi1pbmxpbmUtc3RhcnQ6YXV0bztwYWRkaW5nLWlubGluZS1zdGFydDoyNHB4fS5tZW51LWZseW91dC1pdGVtLWNoZWNrbWFya3std2Via2l0LW1hcmdpbi1zdGFydDoycHg7LXdlYmtpdC1tYXJnaW4tZW5kOjE0cHg7YWxpZ24taXRlbXM6Y2VudGVyO2Jsb2NrLXNpemU6MTJweDtkaXNwbGF5OmZsZXg7aW5saW5lLXNpemU6MTJweDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbi1pbmxpbmUtZW5kOjE0cHg7bWFyZ2luLWlubGluZS1zdGFydDoycHh9Lm1lbnUtZmx5b3V0LWl0ZW0tYnVsbGV0ey13ZWJraXQtbWFyZ2luLXN0YXJ0OjZweDstd2Via2l0LW1hcmdpbi1lbmQ6MThweDtiYWNrZ3JvdW5kLWNvbG9yOmN1cnJlbnRDb2xvcjtibG9jay1zaXplOjRweDtib3JkZXItcmFkaXVzOjRweDtpbmxpbmUtc2l6ZTo0cHg7bWFyZ2luLWlubGluZS1lbmQ6MThweDttYXJnaW4taW5saW5lLXN0YXJ0OjZweH0ubWVudS1mbHlvdXQtaXRlbS1pbnB1dC1sYWJlbHtkaXNwbGF5OmNvbnRlbnRzfS5tZW51LWZseW91dC1pdGVtPjpnbG9iYWwoc3ZnKXtmaWxsOmN1cnJlbnRDb2xvcjstd2Via2l0LW1hcmdpbi1lbmQ6MTJweDtibG9jay1zaXplOmF1dG87aW5saW5lLXNpemU6MTZweDttYXJnaW4taW5saW5lLWVuZDoxMnB4fS5tZW51LWZseW91dC1pdGVtPjpnbG9iYWwoLm1lbnUtZmx5b3V0LWl0ZW0taGludCl7Y29sb3I6dmFyKC0tZmRzLXRleHQtc2Vjb25kYXJ5KTtmbGV4OjEgMSBhdXRvO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nLWxlZnQ6MjRweDt0ZXh0LWFsaWduOmVuZDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5tZW51LWZseW91dC1zdWJtZW51LWFuY2hvcnstLWZkcy1tZW51LWZseW91dC10cmFuc2l0aW9uLW9mZnNldDotNTAlO2luc2V0LWJsb2NrLXN0YXJ0OjA7aW5zZXQtaW5saW5lLXN0YXJ0OjEwMCU7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoxMDAwMH08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9OUSw2Q0FBaUIsQ0FBQyxZQUFZLE1BQU0sQ0FBQyxpQkFBaUIsSUFBSSw2QkFBNkIsQ0FBQyxDQUFDLFdBQVcsSUFBSSxDQUFDLGNBQWMsSUFBSSwyQkFBMkIsQ0FBQyxDQUFDLFdBQVcsVUFBVSxDQUFDLE1BQU0sSUFBSSxrQkFBa0IsQ0FBQyxDQUFDLE9BQU8sT0FBTyxDQUFDLFFBQVEsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxJQUFJLHNCQUFzQixDQUFDLENBQUMsVUFBVSxJQUFJLG9CQUFvQixDQUFDLENBQUMsWUFBWSxHQUFHLENBQUMsWUFBWSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsWUFBWSxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLFFBQVEsSUFBSSxDQUFDLGVBQWUsSUFBSSxDQUFDLFNBQVMsUUFBUSxDQUFDLGdCQUFnQixJQUFJLENBQUMsY0FBYyxRQUFRLENBQUMsb0JBQW9CLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxDQUFDLGdCQUFnQixJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsWUFBWSxNQUFNLENBQUMsNkNBQWlCLE9BQU8sQ0FBQyxpQkFBaUIsSUFBSSxvQkFBb0IsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLGNBQWMsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDLFlBQVksR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsU0FBUyxRQUFRLENBQUMsV0FBVyxTQUFTLENBQUMsSUFBSSwyQkFBMkIsQ0FBQyxDQUFDLElBQUkscUNBQXFDLENBQUMsQ0FBQyw2Q0FBaUIsY0FBYyxDQUFDLFdBQVcsSUFBSSxrQkFBa0IsQ0FBQyxDQUFDLGlCQUFpQixxQ0FBUyxDQUFDLDZDQUFpQixNQUFNLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLElBQUksNkJBQUMsQ0FBQyxpQkFBaUIsSUFBSSwyQkFBMkIsQ0FBQyxDQUFDLGlCQUFpQixzQkFBUSxDQUFDLEFBQVEsd0JBQXdCLEFBQUMsQ0FBQyxpQkFBaUIsc0JBQVEsQ0FBQyxBQUFRLDJCQUEyQixBQUFDLENBQUMsV0FBVyxPQUFPLENBQUMsNkNBQWlCLE9BQU8sQ0FBQyxpQkFBaUIsSUFBSSwwQkFBMEIsQ0FBQyxDQUFDLDZDQUFpQixPQUFPLE9BQU8sQ0FBQyxVQUFVLE9BQU8sSUFBSSxDQUFDLENBQUMsaUJBQWlCLHFDQUFTLENBQUMsaUJBQWlCLElBQUksNkJBQTZCLENBQUMsQ0FBQyxNQUFNLElBQUksbUJBQW1CLENBQUMsQ0FBQyxlQUFlLElBQUksQ0FBQyxpQkFBaUIsU0FBUyxxQ0FBUyxDQUFDLGlCQUFpQixJQUFJLDJCQUEyQixDQUFDLENBQUMsaUJBQWlCLFNBQVMscUNBQVMsT0FBTyxDQUFDLGlCQUFpQixJQUFJLHFCQUFxQixDQUFDLENBQUMsaUJBQWlCLHVCQUFTLENBQUMsQUFBUSxzQkFBc0IsQUFBQyxDQUFDLE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxDQUFDLGlCQUFpQixxQ0FBUyxPQUFPLENBQUMsV0FBVyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsaUJBQWlCLHFDQUFTLENBQUMsc0JBQXNCLElBQUksQ0FBQyxxQkFBcUIsSUFBSSxDQUFDLG9EQUF3QixDQUFDLHVEQUEyQixDQUFDLFdBQVcsTUFBTSxDQUFDLCtCQUFpQixDQUFDLHFDQUF1QixDQUFDLG1CQUFtQixDQUFDLENBQUMscUJBQXFCLElBQUksQ0FBQyxzQkFBc0IsSUFBSSxDQUFDLFdBQVcsSUFBSSxDQUFDLFdBQVcsV0FBVyxDQUFDLFlBQVksSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsb0JBQW9CLElBQUksQ0FBQyxxQkFBcUIsSUFBSSxDQUFDLHVEQUEyQixDQUFDLHFCQUFxQixHQUFHLENBQUMsbUJBQW1CLElBQUksQ0FBQyxZQUFZLE1BQU0sQ0FBQyxXQUFXLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxnQkFBZ0IsTUFBTSxDQUFDLGtCQUFrQixJQUFJLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxvREFBd0IsQ0FBQyxxQkFBcUIsR0FBRyxDQUFDLG1CQUFtQixJQUFJLENBQUMsaUJBQWlCLFlBQVksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxjQUFjLEdBQUcsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxrQkFBa0IsSUFBSSxDQUFDLG9CQUFvQixHQUFHLENBQUMseURBQTZCLENBQUMsUUFBUSxRQUFRLENBQUMsK0JBQWlCLENBQUMsQUFBUSxHQUFHLEFBQUMsQ0FBQyxLQUFLLFlBQVksQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLFdBQVcsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLGtCQUFrQixJQUFJLENBQUMsK0JBQWlCLENBQUMsQUFBUSxzQkFBc0IsQUFBQyxDQUFDLE1BQU0sSUFBSSxvQkFBb0IsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxNQUFNLENBQUMsYUFBYSxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsY0FBYyxRQUFRLENBQUMsdURBQTJCLENBQUMsb0NBQW9DLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLG1CQUFtQixJQUFJLENBQUMsU0FBUyxRQUFRLENBQUMsUUFBUSxLQUFLLENBQUMifQ== */");
}

const get_icon_slot_changes_1 = dirty => ({});
const get_icon_slot_context_1 = ctx => ({ slot: "icon" });
const get_flyout_slot_changes = dirty => ({});
const get_flyout_slot_context = ctx => ({});
const get_icon_slot_changes = dirty => ({});
const get_icon_slot_context = ctx => ({});

// (151:54) 
function create_if_block_4(ctx) {
	let label;
	let menuflyoutitem;
	let t;
	let current;

	menuflyoutitem = new MenuFlyoutItem({
			props: {
				checked: /*checked*/ ctx[2] || /*group*/ ctx[3] === /*value*/ ctx[4],
				selected: /*selected*/ ctx[12],
				variant: /*variant*/ ctx[9],
				indented: /*indented*/ ctx[13],
				group: /*group*/ ctx[3],
				disabled: /*disabled*/ ctx[14],
				__depth: true,
				$$slots: {
					icon: [create_icon_slot],
					default: [create_default_slot_2]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	function select_block_type_1(ctx, dirty) {
		if (/*variant*/ ctx[9] === "radio") return create_if_block_5;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx, [-1, -1]);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			label = element_1("label");
			create_component(menuflyoutitem.$$.fragment);
			t = space();
			if_block.c();
			attr_dev(label, "class", "menu-flyout-item-input-label svelte-s7v067");
			add_location(label, file, 152, 1, 5868);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			mount_component(menuflyoutitem, label, null);
			append_dev(label, t);
			if_block.m(label, null);
			/*label_binding*/ ctx[42](label);
			current = true;
		},
		p: function update(ctx, dirty) {
			const menuflyoutitem_changes = {};
			if (dirty[0] & /*checked, group, value*/ 28) menuflyoutitem_changes.checked = /*checked*/ ctx[2] || /*group*/ ctx[3] === /*value*/ ctx[4];
			if (dirty[0] & /*selected*/ 4096) menuflyoutitem_changes.selected = /*selected*/ ctx[12];
			if (dirty[0] & /*variant*/ 512) menuflyoutitem_changes.variant = /*variant*/ ctx[9];
			if (dirty[0] & /*indented*/ 8192) menuflyoutitem_changes.indented = /*indented*/ ctx[13];
			if (dirty[0] & /*group*/ 8) menuflyoutitem_changes.group = /*group*/ ctx[3];
			if (dirty[0] & /*disabled*/ 16384) menuflyoutitem_changes.disabled = /*disabled*/ ctx[14];

			if (dirty[0] & /*variant*/ 512 | dirty[1] & /*$$scope*/ 4096) {
				menuflyoutitem_changes.$$scope = { dirty, ctx };
			}

			menuflyoutitem.$set(menuflyoutitem_changes);

			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(label, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menuflyoutitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menuflyoutitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			destroy_component(menuflyoutitem);
			if_block.d();
			/*label_binding*/ ctx[42](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(151:54) ",
		ctx
	});

	return block;
}

// (96:0) {#if variant === "standard" || __depth}
function create_if_block(ctx) {
	let li;
	let t0;
	let t1;
	let t2;
	let li_tabindex_value;
	let li_aria_expanded_value;
	let li_aria_haspopup_value;
	let li_aria_controls_value;
	let li_aria_selected_value;
	let li_class_value;
	let forwardEvents_action;
	let current;
	let mounted;
	let dispose;
	const icon_slot_template = /*#slots*/ ctx[26].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[43], get_icon_slot_context);
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);
	let if_block0 = /*hint*/ ctx[11] && create_if_block_3(ctx);
	let if_block1 = /*cascading*/ ctx[10] && create_if_block_1(ctx);

	let li_levels = [
		{
			tabindex: li_tabindex_value = /*disabled*/ ctx[14] ? -1 : 0
		},
		{ role: "menuitem" },
		{
			"aria-expanded": li_aria_expanded_value = /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && /*open*/ ctx[0]
		},
		{
			"aria-haspopup": li_aria_haspopup_value = /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && /*open*/ ctx[0]
		},
		{
			"aria-controls": li_aria_controls_value = /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && /*menuId*/ ctx[19]
		},
		{
			"aria-selected": li_aria_selected_value = /*selected*/ ctx[12] || /*checked*/ ctx[2]
		},
		{
			class: li_class_value = "menu-flyout-item type-" + /*variant*/ ctx[9] + " " + /*className*/ ctx[16]
		},
		/*$$restProps*/ ctx[25]
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element_1("li");
			if (icon_slot) icon_slot.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			set_attributes(li, li_data);
			toggle_class(li, "cascading", /*cascading*/ ctx[10]);
			toggle_class(li, "selected", /*selected*/ ctx[12]);
			toggle_class(li, "checked", /*checked*/ ctx[2]);
			toggle_class(li, "disabled", /*disabled*/ ctx[14]);
			toggle_class(li, "indented", /*indented*/ ctx[13]);
			toggle_class(li, "svelte-s7v067", true);
			add_location(li, file, 96, 1, 4101);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (icon_slot) {
				icon_slot.m(li, null);
			}

			append_dev(li, t0);

			if (default_slot) {
				default_slot.m(li, null);
			}

			append_dev(li, t1);
			if (if_block0) if_block0.m(li, null);
			append_dev(li, t2);
			if (if_block1) if_block1.m(li, null);
			/*li_binding*/ ctx[36](li);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[18].call(null, li)),
					listen_dev(li, "click", /*close*/ ctx[20], false, false, false),
					listen_dev(li, "mouseenter", /*handleMouseEnter*/ ctx[22], false, false, false),
					listen_dev(li, "mouseleave", /*handleMouseLeave*/ ctx[23], false, false, false),
					listen_dev(li, "keydown", /*handleKeyDown*/ ctx[21], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						icon_slot,
						icon_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(icon_slot_template, /*$$scope*/ ctx[43], dirty, get_icon_slot_changes),
						get_icon_slot_context
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
						null
					);
				}
			}

			if (/*hint*/ ctx[11]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*hint*/ 2048) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(li, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*cascading*/ ctx[10]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*cascading*/ 1024) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(li, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[0] & /*disabled*/ 16384 && li_tabindex_value !== (li_tabindex_value = /*disabled*/ ctx[14] ? -1 : 0)) && { tabindex: li_tabindex_value },
				{ role: "menuitem" },
				(!current || dirty[0] & /*$$slots, disabled, open*/ 16793601 && li_aria_expanded_value !== (li_aria_expanded_value = /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && /*open*/ ctx[0])) && { "aria-expanded": li_aria_expanded_value },
				(!current || dirty[0] & /*$$slots, disabled, open*/ 16793601 && li_aria_haspopup_value !== (li_aria_haspopup_value = /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && /*open*/ ctx[0])) && { "aria-haspopup": li_aria_haspopup_value },
				(!current || dirty[0] & /*$$slots, disabled*/ 16793600 && li_aria_controls_value !== (li_aria_controls_value = /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && /*menuId*/ ctx[19])) && { "aria-controls": li_aria_controls_value },
				(!current || dirty[0] & /*selected, checked*/ 4100 && li_aria_selected_value !== (li_aria_selected_value = /*selected*/ ctx[12] || /*checked*/ ctx[2])) && { "aria-selected": li_aria_selected_value },
				(!current || dirty[0] & /*variant, className*/ 66048 && li_class_value !== (li_class_value = "menu-flyout-item type-" + /*variant*/ ctx[9] + " " + /*className*/ ctx[16])) && { class: li_class_value },
				dirty[0] & /*$$restProps*/ 33554432 && /*$$restProps*/ ctx[25]
			]));

			toggle_class(li, "cascading", /*cascading*/ ctx[10]);
			toggle_class(li, "selected", /*selected*/ ctx[12]);
			toggle_class(li, "checked", /*checked*/ ctx[2]);
			toggle_class(li, "disabled", /*disabled*/ ctx[14]);
			toggle_class(li, "indented", /*indented*/ ctx[13]);
			toggle_class(li, "svelte-s7v067", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_slot, local);
			transition_in(default_slot, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_slot, local);
			transition_out(default_slot, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (icon_slot) icon_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*li_binding*/ ctx[36](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(96:0) {#if variant === \\\"standard\\\" || __depth}",
		ctx
	});

	return block;
}

// (165:4) {#if variant === "toggle"}
function create_if_block_6(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			attr_dev(path, "d", "M9.85355 3.14645C10.0488 3.34171 10.0488 3.65829 9.85355 3.85355L5.35355 8.35355C5.15829 8.54882 4.84171 8.54882 4.64645 8.35355L2.64645 6.35355C2.45118 6.15829 2.45118 5.84171 2.64645 5.64645C2.84171 5.45118 3.15829 5.45118 3.35355 5.64645L5 7.29289L9.14645 3.14645C9.34171 2.95118 9.65829 2.95118 9.85355 3.14645Z");
			attr_dev(path, "fill", "currentColor");
			add_location(path, file, 172, 6, 6370);
			attr_dev(svg, "width", "12");
			attr_dev(svg, "height", "12");
			attr_dev(svg, "viewBox", "0 0 12 12");
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			add_location(svg, file, 165, 5, 6232);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(165:4) {#if variant === \\\"toggle\\\"}",
		ctx
	});

	return block;
}

// (154:2) <svelte:self    checked={checked || group === value}    {selected}    {variant}    {indented}    {group}    {disabled}    __depth   >
function create_default_slot_2(ctx) {
	let div;
	let div_class_value;
	let t;
	let current;
	let if_block = /*variant*/ ctx[9] === "toggle" && create_if_block_6(ctx);
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);

	const block = {
		c: function create() {
			div = element_1("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			attr_dev(div, "class", div_class_value = "menu-flyout-item-" + (/*variant*/ ctx[9] === 'radio' ? 'bullet' : 'checkmark') + " svelte-s7v067");
			add_location(div, file, 163, 3, 6118);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			insert_dev(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*variant*/ ctx[9] === "toggle") {
				if (if_block) {
					
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty[0] & /*variant*/ 512 && div_class_value !== (div_class_value = "menu-flyout-item-" + (/*variant*/ ctx[9] === 'radio' ? 'bullet' : 'checkmark') + " svelte-s7v067")) {
				attr_dev(div, "class", div_class_value);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[43], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (detaching) detach_dev(t);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(154:2) <svelte:self    checked={checked || group === value}    {selected}    {variant}    {indented}    {group}    {disabled}    __depth   >",
		ctx
	});

	return block;
}

// (163:3) 
function create_icon_slot(ctx) {
	let current;
	const icon_slot_template = /*#slots*/ ctx[26].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[43], get_icon_slot_context_1);

	const block = {
		c: function create() {
			if (icon_slot) icon_slot.c();
		},
		m: function mount(target, anchor) {
			if (icon_slot) {
				icon_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						icon_slot,
						icon_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(icon_slot_template, /*$$scope*/ ctx[43], dirty, get_icon_slot_changes_1),
						get_icon_slot_context_1
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (icon_slot) icon_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_icon_slot.name,
		type: "slot",
		source: "(163:3) ",
		ctx
	});

	return block;
}

// (196:2) {:else}
function create_else_block(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element_1("input");
			attr_dev(input, "type", "checkbox");
			input.hidden = true;
			input.disabled = /*disabled*/ ctx[14];
			/*$$binding_groups*/ ctx[38][0].push(input);
			add_location(input, file, 196, 3, 7017);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			/*input_binding_1*/ ctx[40](input);
			input.checked = ~/*group*/ ctx[3].indexOf(input.__value);
			input.checked = /*checked*/ ctx[2];
			set_input_value(input, /*value*/ ctx[4]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*change_handler_1*/ ctx[30], false, false, false),
					listen_dev(input, "input", /*input_handler_1*/ ctx[31], false, false, false),
					listen_dev(input, "beforeinput", /*beforeinput_handler_1*/ ctx[32], false, false, false),
					listen_dev(input, "change", /*input_change_handler_1*/ ctx[41])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 16384) {
				prop_dev(input, "disabled", /*disabled*/ ctx[14]);
			}

			if (dirty[0] & /*group*/ 8) {
				input.checked = ~/*group*/ ctx[3].indexOf(input.__value);
			}

			if (dirty[0] & /*checked*/ 4) {
				input.checked = /*checked*/ ctx[2];
			}

			if (dirty[0] & /*value*/ 16) {
				set_input_value(input, /*value*/ ctx[4]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			/*input_binding_1*/ ctx[40](null);
			/*$$binding_groups*/ ctx[38][0].splice(/*$$binding_groups*/ ctx[38][0].indexOf(input), 1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(196:2) {:else}",
		ctx
	});

	return block;
}

// (183:2) {#if variant === "radio"}
function create_if_block_5(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element_1("input");
			attr_dev(input, "type", "radio");
			input.hidden = true;
			input.__value = /*value*/ ctx[4];
			input.value = input.__value;
			input.checked = /*checked*/ ctx[2];
			input.disabled = /*disabled*/ ctx[14];
			/*$$binding_groups*/ ctx[38][0].push(input);
			add_location(input, file, 183, 3, 6832);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			input.checked = input.__value === /*group*/ ctx[3];
			/*input_binding*/ ctx[39](input);

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*change_handler*/ ctx[27], false, false, false),
					listen_dev(input, "input", /*input_handler*/ ctx[28], false, false, false),
					listen_dev(input, "beforeinput", /*beforeinput_handler*/ ctx[29], false, false, false),
					listen_dev(input, "change", /*input_change_handler*/ ctx[37])
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value*/ 16) {
				prop_dev(input, "__value", /*value*/ ctx[4]);
				input.value = input.__value;
			}

			if (dirty[0] & /*checked*/ 4) {
				prop_dev(input, "checked", /*checked*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 16384) {
				prop_dev(input, "disabled", /*disabled*/ ctx[14]);
			}

			if (dirty[0] & /*group*/ 8) {
				input.checked = input.__value === /*group*/ ctx[3];
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			/*$$binding_groups*/ ctx[38][0].splice(/*$$binding_groups*/ ctx[38][0].indexOf(input), 1);
			/*input_binding*/ ctx[39](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(183:2) {#if variant === \\\"radio\\\"}",
		ctx
	});

	return block;
}

// (120:2) {#if hint}
function create_if_block_3(ctx) {
	let textblock;
	let current;

	textblock = new TextBlock({
			props: {
				class: "menu-flyout-item-hint",
				variant: "caption",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(textblock.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(textblock, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const textblock_changes = {};

			if (dirty[0] & /*hint*/ 2048 | dirty[1] & /*$$scope*/ 4096) {
				textblock_changes.$$scope = { dirty, ctx };
			}

			textblock.$set(textblock_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(textblock.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(textblock.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(textblock, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(120:2) {#if hint}",
		ctx
	});

	return block;
}

// (121:3) <TextBlock class="menu-flyout-item-hint" variant="caption">
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*hint*/ ctx[11]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*hint*/ 2048) set_data_dev(t, /*hint*/ ctx[11]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(121:3) <TextBlock class=\\\"menu-flyout-item-hint\\\" variant=\\\"caption\\\">",
		ctx
	});

	return block;
}

// (123:2) {#if cascading}
function create_if_block_1(ctx) {
	let svg;
	let path;
	let t;
	let if_block_anchor;
	let current;
	let if_block = /*open*/ ctx[0] && /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14] && create_if_block_2(ctx);

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr_dev(path, "d", "M4.64645 2.14645C4.45118 2.34171 4.45118 2.65829 4.64645 2.85355L7.79289 6L4.64645 9.14645C4.45118 9.34171 4.45118 9.65829 4.64645 9.85355C4.84171 10.0488 5.15829 10.0488 5.35355 9.85355L8.85355 6.35355C9.04882 6.15829 9.04882 5.84171 8.85355 5.64645L5.35355 2.14645C5.15829 1.95118 4.84171 1.95118 4.64645 2.14645Z");
			attr_dev(path, "fill", "currentColor");
			add_location(path, file, 131, 4, 4993);
			attr_dev(svg, "class", "menu-flyout-item-arrow svelte-s7v067");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "width", "12");
			attr_dev(svg, "height", "12");
			attr_dev(svg, "viewBox", "0 0 12 12");
			attr_dev(svg, "fill", "none");
			add_location(svg, file, 123, 3, 4834);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*open*/ ctx[0] && /*$$slots*/ ctx[24].flyout && !/*disabled*/ ctx[14]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*open, $$slots, disabled*/ 16793601) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(123:2) {#if cascading}",
		ctx
	});

	return block;
}

// (137:3) {#if open && $$slots.flyout && !disabled}
function create_if_block_2(ctx) {
	let div;
	let menuflyoutsurface;
	let updating_element;
	let arrowNavigation_action;
	let current;
	let mounted;
	let dispose;

	function menuflyoutsurface_element_binding(value) {
		/*menuflyoutsurface_element_binding*/ ctx[33](value);
	}

	let menuflyoutsurface_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*subMenuElement*/ ctx[1] !== void 0) {
		menuflyoutsurface_props.element = /*subMenuElement*/ ctx[1];
	}

	menuflyoutsurface = new MenuFlyoutSurface({
			props: menuflyoutsurface_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(menuflyoutsurface, 'element', menuflyoutsurface_element_binding));
	/*menuflyoutsurface_binding*/ ctx[34](menuflyoutsurface);

	const block = {
		c: function create() {
			div = element_1("div");
			create_component(menuflyoutsurface.$$.fragment);
			attr_dev(div, "id", /*menuId*/ ctx[19]);
			attr_dev(div, "class", "menu-flyout-submenu-anchor svelte-s7v067");
			add_location(div, file, 137, 4, 5415);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(menuflyoutsurface, div, null);
			/*div_binding*/ ctx[35](div);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(arrowNavigation_action = arrowNavigation.call(null, div, { preventTab: true, stopPropagation: true }));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const menuflyoutsurface_changes = {};

			if (dirty[1] & /*$$scope*/ 4096) {
				menuflyoutsurface_changes.$$scope = { dirty, ctx };
			}

			if (!updating_element && dirty[0] & /*subMenuElement*/ 2) {
				updating_element = true;
				menuflyoutsurface_changes.element = /*subMenuElement*/ ctx[1];
				add_flush_callback(() => updating_element = false);
			}

			menuflyoutsurface.$set(menuflyoutsurface_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menuflyoutsurface.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menuflyoutsurface.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*menuflyoutsurface_binding*/ ctx[34](null);
			destroy_component(menuflyoutsurface);
			/*div_binding*/ ctx[35](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(137:3) {#if open && $$slots.flyout && !disabled}",
		ctx
	});

	return block;
}

// (144:5) <MenuFlyoutSurface bind:element={subMenuElement} bind:this={menu}>
function create_default_slot(ctx) {
	let current;
	const flyout_slot_template = /*#slots*/ ctx[26].flyout;
	const flyout_slot = create_slot(flyout_slot_template, ctx, /*$$scope*/ ctx[43], get_flyout_slot_context);

	const block = {
		c: function create() {
			if (flyout_slot) flyout_slot.c();
		},
		m: function mount(target, anchor) {
			if (flyout_slot) {
				flyout_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (flyout_slot) {
				if (flyout_slot.p && (!current || dirty[1] & /*$$scope*/ 4096)) {
					update_slot_base(
						flyout_slot,
						flyout_slot_template,
						ctx,
						/*$$scope*/ ctx[43],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[43])
						: get_slot_changes(flyout_slot_template, /*$$scope*/ ctx[43], dirty, get_flyout_slot_changes),
						get_flyout_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(flyout_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(flyout_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (flyout_slot) flyout_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(144:5) <MenuFlyoutSurface bind:element={subMenuElement} bind:this={menu}>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_if_block_4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*variant*/ ctx[9] === "standard" || /*__depth*/ ctx[15]) return 0;
		if (/*variant*/ ctx[9] === "radio" || /*variant*/ ctx[9] === "toggle") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"variant","cascading","hint","selected","checked","indented","group","value","disabled","open","__depth","class","element","inputElement","inputLabelElement","subMenuAnchorElement","subMenuElement"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MenuFlyoutItem', slots, ['icon','default','flyout']);
	const $$slots = compute_slots(slots);
	let { variant = "standard" } = $$props;
	let { cascading = false } = $$props;
	let { hint = undefined } = $$props;
	let { selected = false } = $$props;
	let { checked = false } = $$props;
	let { indented = false } = $$props;
	let { group = [] } = $$props;
	let { value = undefined } = $$props;
	let { disabled = false } = $$props;
	let { open = false } = $$props;
	let { __depth = false } = $$props;
	let { class: className = "" } = $$props;
	let { element = null } = $$props;
	let { inputElement = null } = $$props;
	let { inputLabelElement = null } = $$props;
	let { subMenuAnchorElement = null } = $$props;
	let { subMenuElement = null } = $$props;
	const forwardEvents = createEventForwarder(get_current_component());
	const dispatch = createEventDispatcher();
	const closeFlyout = getContext("closeFlyout");
	const menuId = uid("fds-menu-flyout-submenu-");
	let menu = null;
	let subMenuQueue = { open: false, close: false };

	function close(event) {
		setTimeout(() => {
			if (!cascading && closeFlyout) closeFlyout(event);
		});
	}

	function handleKeyDown(event) {
		const { key, target } = event;

		if (key === "Enter" || key === " ") {
			event.preventDefault();
			target.click();
		}

		if (cascading) {
			if (key === "ArrowRight") {
				event.stopPropagation();
				$$invalidate(0, open = true);
			} else if (open && key === "ArrowLeft") {
				event.stopPropagation();
				$$invalidate(0, open = false);
				element.focus();
			}
		}
	}

	function handleMouseEnter() {
		subMenuQueue.close = false;
		subMenuQueue.open = true;

		setTimeout(
			() => {
				if (subMenuQueue.open) $$invalidate(0, open = true);
			},
			500
		);
	}

	function handleMouseLeave() {
		subMenuQueue.close = true;
		subMenuQueue.open = false;

		setTimeout(
			() => {
				if (subMenuQueue.close) $$invalidate(0, open = false);
			},
			500
		);
	}

	const $$binding_groups = [[]];

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeinput_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function beforeinput_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function menuflyoutsurface_element_binding(value) {
		subMenuElement = value;
		$$invalidate(1, subMenuElement);
	}

	function menuflyoutsurface_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			menu = $$value;
			$$invalidate(17, menu);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			subMenuAnchorElement = $$value;
			$$invalidate(8, subMenuAnchorElement);
		});
	}

	function li_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(5, element);
		});
	}

	function input_change_handler() {
		group = this.__value;
		$$invalidate(3, group);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputElement = $$value;
			$$invalidate(6, inputElement);
		});
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputElement = $$value;
			$$invalidate(6, inputElement);
		});
	}

	function input_change_handler_1() {
		group = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
		checked = this.checked;
		value = this.value;
		$$invalidate(3, group);
		$$invalidate(2, checked);
		$$invalidate(4, value);
	}

	function label_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			inputLabelElement = $$value;
			$$invalidate(7, inputLabelElement);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('variant' in $$new_props) $$invalidate(9, variant = $$new_props.variant);
		if ('cascading' in $$new_props) $$invalidate(10, cascading = $$new_props.cascading);
		if ('hint' in $$new_props) $$invalidate(11, hint = $$new_props.hint);
		if ('selected' in $$new_props) $$invalidate(12, selected = $$new_props.selected);
		if ('checked' in $$new_props) $$invalidate(2, checked = $$new_props.checked);
		if ('indented' in $$new_props) $$invalidate(13, indented = $$new_props.indented);
		if ('group' in $$new_props) $$invalidate(3, group = $$new_props.group);
		if ('value' in $$new_props) $$invalidate(4, value = $$new_props.value);
		if ('disabled' in $$new_props) $$invalidate(14, disabled = $$new_props.disabled);
		if ('open' in $$new_props) $$invalidate(0, open = $$new_props.open);
		if ('__depth' in $$new_props) $$invalidate(15, __depth = $$new_props.__depth);
		if ('class' in $$new_props) $$invalidate(16, className = $$new_props.class);
		if ('element' in $$new_props) $$invalidate(5, element = $$new_props.element);
		if ('inputElement' in $$new_props) $$invalidate(6, inputElement = $$new_props.inputElement);
		if ('inputLabelElement' in $$new_props) $$invalidate(7, inputLabelElement = $$new_props.inputLabelElement);
		if ('subMenuAnchorElement' in $$new_props) $$invalidate(8, subMenuAnchorElement = $$new_props.subMenuAnchorElement);
		if ('subMenuElement' in $$new_props) $$invalidate(1, subMenuElement = $$new_props.subMenuElement);
		if ('$$scope' in $$new_props) $$invalidate(43, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		getContext,
		get_current_component,
		arrowNavigation,
		uid,
		createEventForwarder,
		tabbable,
		MenuFlyoutSurface,
		TextBlock,
		variant,
		cascading,
		hint,
		selected,
		checked,
		indented,
		group,
		value,
		disabled,
		open,
		__depth,
		className,
		element,
		inputElement,
		inputLabelElement,
		subMenuAnchorElement,
		subMenuElement,
		forwardEvents,
		dispatch,
		closeFlyout,
		menuId,
		menu,
		subMenuQueue,
		close,
		handleKeyDown,
		handleMouseEnter,
		handleMouseLeave
	});

	$$self.$inject_state = $$new_props => {
		if ('variant' in $$props) $$invalidate(9, variant = $$new_props.variant);
		if ('cascading' in $$props) $$invalidate(10, cascading = $$new_props.cascading);
		if ('hint' in $$props) $$invalidate(11, hint = $$new_props.hint);
		if ('selected' in $$props) $$invalidate(12, selected = $$new_props.selected);
		if ('checked' in $$props) $$invalidate(2, checked = $$new_props.checked);
		if ('indented' in $$props) $$invalidate(13, indented = $$new_props.indented);
		if ('group' in $$props) $$invalidate(3, group = $$new_props.group);
		if ('value' in $$props) $$invalidate(4, value = $$new_props.value);
		if ('disabled' in $$props) $$invalidate(14, disabled = $$new_props.disabled);
		if ('open' in $$props) $$invalidate(0, open = $$new_props.open);
		if ('__depth' in $$props) $$invalidate(15, __depth = $$new_props.__depth);
		if ('className' in $$props) $$invalidate(16, className = $$new_props.className);
		if ('element' in $$props) $$invalidate(5, element = $$new_props.element);
		if ('inputElement' in $$props) $$invalidate(6, inputElement = $$new_props.inputElement);
		if ('inputLabelElement' in $$props) $$invalidate(7, inputLabelElement = $$new_props.inputLabelElement);
		if ('subMenuAnchorElement' in $$props) $$invalidate(8, subMenuAnchorElement = $$new_props.subMenuAnchorElement);
		if ('subMenuElement' in $$props) $$invalidate(1, subMenuElement = $$new_props.subMenuElement);
		if ('menu' in $$props) $$invalidate(17, menu = $$new_props.menu);
		if ('subMenuQueue' in $$props) subMenuQueue = $$new_props.subMenuQueue;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*open*/ 1) {
			$: dispatch(open ? "open" : "close");
		}

		if ($$self.$$.dirty[0] & /*open, menu, subMenuElement*/ 131075) {
			$: if (open && menu && tabbable(subMenuElement).length > 0) tabbable(subMenuElement)[0].focus();
		}
	};

	return [
		open,
		subMenuElement,
		checked,
		group,
		value,
		element,
		inputElement,
		inputLabelElement,
		subMenuAnchorElement,
		variant,
		cascading,
		hint,
		selected,
		indented,
		disabled,
		__depth,
		className,
		menu,
		forwardEvents,
		menuId,
		close,
		handleKeyDown,
		handleMouseEnter,
		handleMouseLeave,
		$$slots,
		$$restProps,
		slots,
		change_handler,
		input_handler,
		beforeinput_handler,
		change_handler_1,
		input_handler_1,
		beforeinput_handler_1,
		menuflyoutsurface_element_binding,
		menuflyoutsurface_binding,
		div_binding,
		li_binding,
		input_change_handler,
		$$binding_groups,
		input_binding,
		input_binding_1,
		input_change_handler_1,
		label_binding,
		$$scope
	];
}

class MenuFlyoutItem extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				variant: 9,
				cascading: 10,
				hint: 11,
				selected: 12,
				checked: 2,
				indented: 13,
				group: 3,
				value: 4,
				disabled: 14,
				open: 0,
				__depth: 15,
				class: 16,
				element: 5,
				inputElement: 6,
				inputLabelElement: 7,
				subMenuAnchorElement: 8,
				subMenuElement: 1
			},
			add_css,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MenuFlyoutItem",
			options,
			id: create_fragment.name
		});
	}

	get variant() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set variant(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get cascading() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set cascading(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hint() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hint(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indented() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indented(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get group() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set group(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get __depth() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set __depth(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get element() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set element(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputElement() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputElement(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputLabelElement() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputLabelElement(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subMenuAnchorElement() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subMenuAnchorElement(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subMenuElement() {
		throw new Error("<MenuFlyoutItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subMenuElement(value) {
		throw new Error("<MenuFlyoutItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default MenuFlyoutItem;