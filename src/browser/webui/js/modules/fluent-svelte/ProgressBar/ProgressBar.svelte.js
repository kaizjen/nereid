/* ProgressBar.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	add_location,
	append_dev,
	append_styles,
	assign,
	attr_dev,
	binding_callbacks,
	compute_rest_props,
	detach_dev,
	dispatch_dev,
	exclude_internal_props,
	get_spread_update,
	init,
	insert_dev,
	noop,
	safe_not_equal,
	set_svg_attributes,
	svg_element,
	toggle_class,
	validate_slots
} from "nereid://.svelte/internal/index.mjs";

const file = "ProgressBar.svelte";

function add_css(target) {
	append_styles(target, "svelte-1jjv56o", "@-webkit-keyframes svelte-1jjv56o-indeterminate-1{0%{opacity:1;transform:translateX(-100%)}75%{opacity:1;transform:translateX(300%)}75.01%{opacity:0}to{opacity:0;transform:translateX(300%)}}@keyframes svelte-1jjv56o-indeterminate-1{0%{opacity:1;transform:translateX(-100%)}75%{opacity:1;transform:translateX(300%)}75.01%{opacity:0}to{opacity:0;transform:translateX(300%)}}@-webkit-keyframes svelte-1jjv56o-indeterminate-2{0%{opacity:0;transform:translateX(-150%)}37.49%{opacity:0}37.5%{opacity:1;transform:translateX(-150%)}to{opacity:1;transform:translateX(166.66%)}}@keyframes svelte-1jjv56o-indeterminate-2{0%{opacity:0;transform:translateX(-150%)}37.49%{opacity:0}37.5%{opacity:1;transform:translateX(-150%)}to{opacity:1;transform:translateX(166.66%)}}.progress-bar.svelte-1jjv56o.svelte-1jjv56o{align-items:center;display:flex;min-block-size:3px;width:100%}.progress-bar-track.svelte-1jjv56o.svelte-1jjv56o{fill:var(--fds-accent-default);height:3px;max-width:50%;transition:var(--fds-control-fast-duration) linear fill}.progress-bar-rail.svelte-1jjv56o.svelte-1jjv56o{fill:var(--fds-control-strong-stroke-default);height:1px;width:100%}.progress-bar.indeterminate.svelte-1jjv56o .progress-bar-rail.svelte-1jjv56o{display:none}.progress-bar.indeterminate.svelte-1jjv56o .progress-bar-track.svelte-1jjv56o{-webkit-animation-timing-function:cubic-bezier(.4,0,.6,1);animation-timing-function:cubic-bezier(.4,0,.6,1)}.progress-bar.indeterminate.svelte-1jjv56o .progress-bar-track.svelte-1jjv56o:first-of-type{-webkit-animation:svelte-1jjv56o-indeterminate-1 2s infinite;animation:svelte-1jjv56o-indeterminate-1 2s infinite;width:40%}.progress-bar.indeterminate.svelte-1jjv56o .progress-bar-track.svelte-1jjv56o:nth-of-type(2){-webkit-animation:svelte-1jjv56o-indeterminate-2 2s infinite;animation:svelte-1jjv56o-indeterminate-2 2s infinite;width:60%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvZ3Jlc3NCYXIuc3ZlbHRlIiwic291cmNlcyI6WyJQcm9ncmVzc0Jhci5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCA+LyoqIERldGVybWluZXMgYSBjb21wbGV0aW9uIGFtb3VudCBpbiBwZXJjZW50YWdlLiBJZiBubyB2YWx1ZSBvciBhbiBpbnZhbGlkIHZhbHVlIGlzIHByb3ZpZGVkLCB0aGUgYmFyIHdpbGwgYmUgaW5kZXRlcm1pbmF0ZS4gKi9cclxuZXhwb3J0IGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcclxuLyoqIERldGVybWluZXMgdGhlIHByb2dyZXNzIGJhcidzIHZpc3VhbCBzdGF0ZS4gKi9cclxuLy8gZXhwb3J0IGxldCBzdGF0dXM6IFwicnVubmluZ1wiIHwgXCJwYXVzZWRcIiB8IFwiZXJyb3JcIiA9IFwicnVubmluZ1wiO1xyXG4vKiogU3BlY2lmaWVzIGEgY3VzdG9tIGNsYXNzIG5hbWUgZm9yIHRoZSBiYXIuICovXHJcbmxldCBjbGFzc05hbWUgPSBcIlwiO1xyXG5leHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcclxuLyoqIE9idGFpbnMgYSBib3VuZCBET00gcmVmZXJlbmNlIHRvIHRoZSBiYXIncyBTVkcgZWxlbWVudC4gKi9cclxuZXhwb3J0IGxldCBlbGVtZW50ID0gbnVsbDtcclxuLyoqIE9idGFpbnMgYSBib3VuZCBET00gcmVmZXJlbmNlIHRvIHRoZSBiYXIncyBiYWNrZ3JvdW5kIHJhaWwgZWxlbWVudC4gT25seSBhdmFpbGFibGUgaWYgdGhlIGJhciBoYXMgYSBkZXRlcm1pbmF0ZSB2YWx1ZS4gKi9cclxuZXhwb3J0IGxldCByYWlsRWxlbWVudCA9IG51bGw7XHJcbi8qKiBPYnRhaW5zIGEgYm91bmQgRE9NIHJlZmVyZW5jZSB0byB0aGUgYmFyJ3MgcHJpbWFyeSB0cmFjayBlbGVtZW50LiAqL1xyXG5leHBvcnQgbGV0IHRyYWNrRWxlbWVudCA9IG51bGw7XHJcbi8qKiBPYnRhaW5zIGEgYm91bmQgRE9NIHJlZmVyZW5jZSB0byB0aGUgYmFyJ3Mgc2Vjb25kYXJ5IHRyYWNrIGVsZW1lbnQuIE9ubHkgYXZhaWxhYmxlIGlmIHRoZSBiYXIgaXMgaW5kZXRlcm1pbmF0ZS4gKi9cclxuZXhwb3J0IGxldCBzZWNvbmRhcnlUcmFja0VsZW1lbnQgPSBudWxsO1xyXG48L3NjcmlwdD5cblxuPHN2Z1xuXHRjbGFzcz1cInByb2dyZXNzLWJhciB7Y2xhc3NOYW1lfVwiXG5cdHJvbGU9XCJwcm9ncmVzc2JhclwiXG5cdHdpZHRoPVwiMTAwJVwiXG5cdGhlaWdodD1cIjNcIlxuXHRhcmlhLXZhbHVlbWluPXt2YWx1ZSA/IDAgOiB1bmRlZmluZWR9XG5cdGFyaWEtdmFsdWVtYXg9e3ZhbHVlID8gMTAwIDogdW5kZWZpbmVkfVxuXHRhcmlhLXZhbHVlbm93PXt2YWx1ZX1cblx0Y2xhc3M6aW5kZXRlcm1pbmF0ZT17IXZhbHVlfVxuXHRiaW5kOnRoaXM9e2VsZW1lbnR9XG5cdHsuLi4kJHJlc3RQcm9wc31cbj5cblx0eyNpZiB2YWx1ZX1cblx0XHQ8cmVjdFxuXHRcdFx0YmluZDp0aGlzPXtyYWlsRWxlbWVudH1cblx0XHRcdGhlaWdodD1cIjFcIlxuXHRcdFx0cng9XCIwLjVcIlxuXHRcdFx0eT1cIjFcIlxuXHRcdFx0d2lkdGg9XCIxMDAlXCJcblx0XHRcdGNsYXNzPVwicHJvZ3Jlc3MtYmFyLXJhaWxcIlxuXHRcdC8+XG5cdHs6ZWxzZX1cblx0XHQ8cmVjdCBiaW5kOnRoaXM9e3NlY29uZGFyeVRyYWNrRWxlbWVudH0gaGVpZ2h0PVwiM1wiIHJ5PVwiM1wiIGNsYXNzPVwicHJvZ3Jlc3MtYmFyLXRyYWNrXCIgLz5cblx0ey9pZn1cblx0PHJlY3Rcblx0XHRiaW5kOnRoaXM9e3RyYWNrRWxlbWVudH1cblx0XHR3aWR0aD17dmFsdWUgPyBgJHt2YWx1ZX0lYCA6IHVuZGVmaW5lZH1cblx0XHRoZWlnaHQ9XCIzXCJcblx0XHRyeD1cIjEuNVwiXG5cdFx0Y2xhc3M9XCJwcm9ncmVzcy1iYXItdHJhY2tcIlxuXHQvPlxuPC9zdmc+XG5cbjxzdHlsZSA+QC13ZWJraXQta2V5ZnJhbWVzIGluZGV0ZXJtaW5hdGUtMXswJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpfTc1JXtvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMzAwJSl9NzUuMDEle29wYWNpdHk6MH10b3tvcGFjaXR5OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMzAwJSl9fUBrZXlmcmFtZXMgaW5kZXRlcm1pbmF0ZS0xezAle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSl9NzUle29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgzMDAlKX03NS4wMSV7b3BhY2l0eTowfXRve29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlWCgzMDAlKX19QC13ZWJraXQta2V5ZnJhbWVzIGluZGV0ZXJtaW5hdGUtMnswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTE1MCUpfTM3LjQ5JXtvcGFjaXR5OjB9MzcuNSV7b3BhY2l0eToxO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xNTAlKX10b3tvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTY2LjY2JSl9fUBrZXlmcmFtZXMgaW5kZXRlcm1pbmF0ZS0yezAle29wYWNpdHk6MDt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTUwJSl9MzcuNDkle29wYWNpdHk6MH0zNy41JXtvcGFjaXR5OjE7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTE1MCUpfXRve29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgxNjYuNjYlKX19LnByb2dyZXNzLWJhcnthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4O21pbi1ibG9jay1zaXplOjNweDt3aWR0aDoxMDAlfS5wcm9ncmVzcy1iYXItdHJhY2t7ZmlsbDp2YXIoLS1mZHMtYWNjZW50LWRlZmF1bHQpO2hlaWdodDozcHg7bWF4LXdpZHRoOjUwJTt0cmFuc2l0aW9uOnZhcigtLWZkcy1jb250cm9sLWZhc3QtZHVyYXRpb24pIGxpbmVhciBmaWxsfS5wcm9ncmVzcy1iYXItcmFpbHtmaWxsOnZhcigtLWZkcy1jb250cm9sLXN0cm9uZy1zdHJva2UtZGVmYXVsdCk7aGVpZ2h0OjFweDt3aWR0aDoxMDAlfS5wcm9ncmVzcy1iYXIuaW5kZXRlcm1pbmF0ZSAucHJvZ3Jlc3MtYmFyLXJhaWx7ZGlzcGxheTpub25lfS5wcm9ncmVzcy1iYXIuaW5kZXRlcm1pbmF0ZSAucHJvZ3Jlc3MtYmFyLXRyYWNrey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjQsMCwuNiwxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguNCwwLC42LDEpfS5wcm9ncmVzcy1iYXIuaW5kZXRlcm1pbmF0ZSAucHJvZ3Jlc3MtYmFyLXRyYWNrOmZpcnN0LW9mLXR5cGV7LXdlYmtpdC1hbmltYXRpb246aW5kZXRlcm1pbmF0ZS0xIDJzIGluZmluaXRlO2FuaW1hdGlvbjppbmRldGVybWluYXRlLTEgMnMgaW5maW5pdGU7d2lkdGg6NDAlfS5wcm9ncmVzcy1iYXIuaW5kZXRlcm1pbmF0ZSAucHJvZ3Jlc3MtYmFyLXRyYWNrOm50aC1vZi10eXBlKDIpey13ZWJraXQtYW5pbWF0aW9uOmluZGV0ZXJtaW5hdGUtMiAycyBpbmZpbml0ZTthbmltYXRpb246aW5kZXRlcm1pbmF0ZS0yIDJzIGluZmluaXRlO3dpZHRoOjYwJX08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtEUSxtQkFBbUIsOEJBQWUsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsVUFBVSxXQUFXLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxVQUFVLFdBQVcsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxVQUFVLFdBQVcsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLDhCQUFlLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFVBQVUsV0FBVyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsVUFBVSxXQUFXLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsVUFBVSxXQUFXLElBQUksQ0FBQyxDQUFDLENBQUMsbUJBQW1CLDhCQUFlLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFVBQVUsV0FBVyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFVBQVUsV0FBVyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsVUFBVSxXQUFXLE9BQU8sQ0FBQyxDQUFDLENBQUMsV0FBVyw4QkFBZSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxVQUFVLFdBQVcsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxVQUFVLFdBQVcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFVBQVUsV0FBVyxPQUFPLENBQUMsQ0FBQyxDQUFDLDJDQUFhLENBQUMsWUFBWSxNQUFNLENBQUMsUUFBUSxJQUFJLENBQUMsZUFBZSxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsaURBQW1CLENBQUMsS0FBSyxJQUFJLG9CQUFvQixDQUFDLENBQUMsT0FBTyxHQUFHLENBQUMsVUFBVSxHQUFHLENBQUMsV0FBVyxJQUFJLDJCQUEyQixDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxnREFBa0IsQ0FBQyxLQUFLLElBQUksbUNBQW1DLENBQUMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxhQUFhLDZCQUFjLENBQUMsaUNBQWtCLENBQUMsUUFBUSxJQUFJLENBQUMsYUFBYSw2QkFBYyxDQUFDLGtDQUFtQixDQUFDLGtDQUFrQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLDBCQUEwQixhQUFhLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsNkJBQWMsQ0FBQyxrQ0FBbUIsY0FBYyxDQUFDLGtCQUFrQiw4QkFBZSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsVUFBVSw4QkFBZSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsYUFBYSw2QkFBYyxDQUFDLGtDQUFtQixhQUFhLENBQUMsQ0FBQyxDQUFDLGtCQUFrQiw4QkFBZSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsVUFBVSw4QkFBZSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMifQ== */");
}

// (39:1) {:else}
function create_else_block(ctx) {
	let rect;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			attr_dev(rect, "height", "3");
			attr_dev(rect, "ry", "3");
			attr_dev(rect, "class", "progress-bar-track svelte-1jjv56o");
			add_location(rect, file, 39, 2, 1327);
		},
		m: function mount(target, anchor) {
			insert_dev(target, rect, anchor);
			/*rect_binding_1*/ ctx[8](rect);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			/*rect_binding_1*/ ctx[8](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(39:1) {:else}",
		ctx
	});

	return block;
}

// (30:1) {#if value}
function create_if_block(ctx) {
	let rect;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			attr_dev(rect, "height", "1");
			attr_dev(rect, "rx", "0.5");
			attr_dev(rect, "y", "1");
			attr_dev(rect, "width", "100%");
			attr_dev(rect, "class", "progress-bar-rail svelte-1jjv56o");
			add_location(rect, file, 30, 2, 1198);
		},
		m: function mount(target, anchor) {
			insert_dev(target, rect, anchor);
			/*rect_binding*/ ctx[7](rect);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			/*rect_binding*/ ctx[7](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(30:1) {#if value}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let svg;
	let rect;
	let rect_width_value;
	let svg_class_value;
	let svg_aria_valuemin_value;
	let svg_aria_valuemax_value;

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[4]) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	let svg_levels = [
		{
			class: svg_class_value = "progress-bar " + /*className*/ ctx[5]
		},
		{ role: "progressbar" },
		{ width: "100%" },
		{ height: "3" },
		{
			"aria-valuemin": svg_aria_valuemin_value = /*value*/ ctx[4] ? 0 : undefined
		},
		{
			"aria-valuemax": svg_aria_valuemax_value = /*value*/ ctx[4] ? 100 : undefined
		},
		{ "aria-valuenow": /*value*/ ctx[4] },
		/*$$restProps*/ ctx[6]
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if_block.c();
			rect = svg_element("rect");
			attr_dev(rect, "width", rect_width_value = /*value*/ ctx[4] ? `${/*value*/ ctx[4]}%` : undefined);
			attr_dev(rect, "height", "3");
			attr_dev(rect, "rx", "1.5");
			attr_dev(rect, "class", "progress-bar-track svelte-1jjv56o");
			add_location(rect, file, 41, 1, 1423);
			set_svg_attributes(svg, svg_data);
			toggle_class(svg, "indeterminate", !/*value*/ ctx[4]);
			toggle_class(svg, "svelte-1jjv56o", true);
			add_location(svg, file, 17, 0, 924);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			if_block.m(svg, null);
			append_dev(svg, rect);
			/*rect_binding_2*/ ctx[9](rect);
			/*svg_binding*/ ctx[10](svg);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(svg, rect);
				}
			}

			if (dirty & /*value*/ 16 && rect_width_value !== (rect_width_value = /*value*/ ctx[4] ? `${/*value*/ ctx[4]}%` : undefined)) {
				attr_dev(rect, "width", rect_width_value);
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
				dirty & /*className*/ 32 && svg_class_value !== (svg_class_value = "progress-bar " + /*className*/ ctx[5]) && { class: svg_class_value },
				{ role: "progressbar" },
				{ width: "100%" },
				{ height: "3" },
				dirty & /*value*/ 16 && svg_aria_valuemin_value !== (svg_aria_valuemin_value = /*value*/ ctx[4] ? 0 : undefined) && { "aria-valuemin": svg_aria_valuemin_value },
				dirty & /*value*/ 16 && svg_aria_valuemax_value !== (svg_aria_valuemax_value = /*value*/ ctx[4] ? 100 : undefined) && { "aria-valuemax": svg_aria_valuemax_value },
				dirty & /*value*/ 16 && { "aria-valuenow": /*value*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6]
			]));

			toggle_class(svg, "indeterminate", !/*value*/ ctx[4]);
			toggle_class(svg, "svelte-1jjv56o", true);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			if_block.d();
			/*rect_binding_2*/ ctx[9](null);
			/*svg_binding*/ ctx[10](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = ["value","class","element","railElement","trackElement","secondaryTrackElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ProgressBar', slots, []);
	let { value = undefined } = $$props;
	let { class: className = "" } = $$props;
	let { element = null } = $$props;
	let { railElement = null } = $$props;
	let { trackElement = null } = $$props;
	let { secondaryTrackElement = null } = $$props;

	function rect_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			railElement = $$value;
			$$invalidate(1, railElement);
		});
	}

	function rect_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			secondaryTrackElement = $$value;
			$$invalidate(3, secondaryTrackElement);
		});
	}

	function rect_binding_2($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			trackElement = $$value;
			$$invalidate(2, trackElement);
		});
	}

	function svg_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('value' in $$new_props) $$invalidate(4, value = $$new_props.value);
		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
		if ('railElement' in $$new_props) $$invalidate(1, railElement = $$new_props.railElement);
		if ('trackElement' in $$new_props) $$invalidate(2, trackElement = $$new_props.trackElement);
		if ('secondaryTrackElement' in $$new_props) $$invalidate(3, secondaryTrackElement = $$new_props.secondaryTrackElement);
	};

	$$self.$capture_state = () => ({
		value,
		className,
		element,
		railElement,
		trackElement,
		secondaryTrackElement
	});

	$$self.$inject_state = $$new_props => {
		if ('value' in $$props) $$invalidate(4, value = $$new_props.value);
		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
		if ('railElement' in $$props) $$invalidate(1, railElement = $$new_props.railElement);
		if ('trackElement' in $$props) $$invalidate(2, trackElement = $$new_props.trackElement);
		if ('secondaryTrackElement' in $$props) $$invalidate(3, secondaryTrackElement = $$new_props.secondaryTrackElement);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		element,
		railElement,
		trackElement,
		secondaryTrackElement,
		value,
		className,
		$$restProps,
		rect_binding,
		rect_binding_1,
		rect_binding_2,
		svg_binding
	];
}

class ProgressBar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				value: 4,
				class: 5,
				element: 0,
				railElement: 1,
				trackElement: 2,
				secondaryTrackElement: 3
			},
			add_css
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ProgressBar",
			options,
			id: create_fragment.name
		});
	}

	get value() {
		throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get element() {
		throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set element(value) {
		throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get railElement() {
		throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set railElement(value) {
		throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get trackElement() {
		throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set trackElement(value) {
		throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get secondaryTrackElement() {
		throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set secondaryTrackElement(value) {
		throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default ProgressBar;