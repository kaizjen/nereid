/* TextBlock.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponentDev,
	add_location,
	append_styles,
	assign,
	binding_callbacks,
	compute_rest_props,
	create_slot,
	detach_dev,
	dispatch_dev,
	element as element_1,
	empty,
	exclude_internal_props,
	get_all_dirty_from_scope,
	get_slot_changes,
	get_spread_update,
	init,
	insert_dev,
	safe_not_equal,
	set_attributes,
	toggle_class,
	transition_in,
	transition_out,
	update_slot_base,
	validate_dynamic_element,
	validate_slots,
	validate_void_dynamic_element
} from "nereid://.svelte/internal/index.mjs";

const file = "TextBlock.svelte";

function add_css(target) {
	append_styles(target, "svelte-zxj483", ".text-block.svelte-zxj483{color:currentColor;display:inline-block;margin:0;padding:0}.text-block.type-display.svelte-zxj483,.text-block.type-subtitle.svelte-zxj483,.text-block.type-title.svelte-zxj483,.text-block.type-title-large.svelte-zxj483{font-family:var(--fds-font-family-display);font-weight:600}.text-block.type-body.svelte-zxj483,.text-block.type-body-large.svelte-zxj483,.text-block.type-body-strong.svelte-zxj483{font-family:var(--fds-font-family-text)}.text-block.type-caption.svelte-zxj483{font-family:var(--fds-font-family-small);font-size:var(--fds-caption-font-size);font-weight:400;line-height:16px}.text-block.type-body.svelte-zxj483,.text-block.type-body-large.svelte-zxj483,.text-block.type-body-strong.svelte-zxj483{font-size:var(--fds-body-font-size);font-weight:400;line-height:20px}.text-block.type-body-strong.svelte-zxj483{font-weight:600}.text-block.type-body-large.svelte-zxj483{font-size:var(--fds-body-large-font-size);line-height:24px}.text-block.type-subtitle.svelte-zxj483{font-size:var(--fds-subtitle-font-size);line-height:28px}.text-block.type-title.svelte-zxj483{font-size:var(--fds-title-font-size);line-height:36px}.text-block.type-title-large.svelte-zxj483{font-size:var(--fds-title-large-font-size);line-height:52px}.text-block.type-display.svelte-zxj483{font-size:var(--fds-display-font-size);line-height:92px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGV4dEJsb2NrLnN2ZWx0ZSIsInNvdXJjZXMiOlsiVGV4dEJsb2NrLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0ID4vKiogRGV0ZXJtaW5lcyB3aGljaCBwcmVzZXQgdGV4dCBzdHlsZSBzaG91bGQgYmUgdXNlZC4gKi9cclxuZXhwb3J0IGxldCB2YXJpYW50ID0gXCJib2R5XCI7XHJcbi8qKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgSFRNTCB0YWcgb2YgdGhlIGJsb2NrJ3MgZWxlbWVudCB3aXRoIHlvdXIgb3duIHRhZy4gKi9cclxuZXhwb3J0IGxldCB0YWcgPSB1bmRlZmluZWQ7XHJcbi8qKiBTcGVjaWZpZXMgYSBjdXN0b20gY2xhc3MgbmFtZSBmb3IgdGhlIHRleHQgYmxvY2sgKi9cclxubGV0IGNsYXNzTmFtZSA9IFwiXCI7XHJcbmV4cG9ydCB7IGNsYXNzTmFtZSBhcyBjbGFzcyB9O1xyXG4vKiogT2J0YWlucyBhIGJvdW5kIERPTSByZWZlcmVuY2UgdG8gdGhlIHRleHQncyBlbGVtZW50LiAqL1xyXG5leHBvcnQgbGV0IGVsZW1lbnQgPSBudWxsO1xyXG5jb25zdCBtYXAgPSB7XHJcbiAgICBjYXB0aW9uOiB7XHJcbiAgICAgICAgdGFnOiBcInNwYW5cIixcclxuICAgICAgICBuYW1lOiBcImNhcHRpb25cIlxyXG4gICAgfSxcclxuICAgIGJvZHk6IHtcclxuICAgICAgICB0YWc6IFwic3BhblwiLFxyXG4gICAgICAgIG5hbWU6IFwiYm9keVwiXHJcbiAgICB9LFxyXG4gICAgYm9keVN0cm9uZzoge1xyXG4gICAgICAgIHRhZzogXCJoNVwiLFxyXG4gICAgICAgIG5hbWU6IFwiYm9keS1zdHJvbmdcIlxyXG4gICAgfSxcclxuICAgIGJvZHlMYXJnZToge1xyXG4gICAgICAgIHRhZzogXCJoNVwiLFxyXG4gICAgICAgIG5hbWU6IFwiYm9keS1sYXJnZVwiXHJcbiAgICB9LFxyXG4gICAgc3VidGl0bGU6IHtcclxuICAgICAgICB0YWc6IFwiaDRcIixcclxuICAgICAgICBuYW1lOiBcInN1YnRpdGxlXCJcclxuICAgIH0sXHJcbiAgICB0aXRsZToge1xyXG4gICAgICAgIHRhZzogXCJoM1wiLFxyXG4gICAgICAgIG5hbWU6IFwidGl0bGVcIlxyXG4gICAgfSxcclxuICAgIHRpdGxlTGFyZ2U6IHtcclxuICAgICAgICB0YWc6IFwiaDJcIixcclxuICAgICAgICBuYW1lOiBcInRpdGxlLWxhcmdlXCJcclxuICAgIH0sXHJcbiAgICBkaXNwbGF5OiB7XHJcbiAgICAgICAgdGFnOiBcImgxXCIsXHJcbiAgICAgICAgbmFtZTogXCJkaXNwbGF5XCJcclxuICAgIH1cclxufTtcclxuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6ZWxlbWVudFxuXHR0aGlzPXt0YWcgPyB0YWcgOiBtYXBbdmFyaWFudF0udGFnfVxuXHRjbGFzcz1cInRleHQtYmxvY2sgdHlwZS17bWFwW3ZhcmlhbnRdLm5hbWV9IHtjbGFzc05hbWV9XCJcblx0YmluZDp0aGlzPXtlbGVtZW50fVxuXHR7Li4uJCRyZXN0UHJvcHN9XG4+XG5cdDxzbG90IC8+XG48L3N2ZWx0ZTplbGVtZW50PlxuXG48c3R5bGUgPi50ZXh0LWJsb2Nre2NvbG9yOmN1cnJlbnRDb2xvcjtkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW46MDtwYWRkaW5nOjB9LnRleHQtYmxvY2sudHlwZS1kaXNwbGF5LC50ZXh0LWJsb2NrLnR5cGUtc3VidGl0bGUsLnRleHQtYmxvY2sudHlwZS10aXRsZSwudGV4dC1ibG9jay50eXBlLXRpdGxlLWxhcmdle2ZvbnQtZmFtaWx5OnZhcigtLWZkcy1mb250LWZhbWlseS1kaXNwbGF5KTtmb250LXdlaWdodDo2MDB9LnRleHQtYmxvY2sudHlwZS1ib2R5LC50ZXh0LWJsb2NrLnR5cGUtYm9keS1sYXJnZSwudGV4dC1ibG9jay50eXBlLWJvZHktc3Ryb25ne2ZvbnQtZmFtaWx5OnZhcigtLWZkcy1mb250LWZhbWlseS10ZXh0KX0udGV4dC1ibG9jay50eXBlLWNhcHRpb257Zm9udC1mYW1pbHk6dmFyKC0tZmRzLWZvbnQtZmFtaWx5LXNtYWxsKTtmb250LXNpemU6dmFyKC0tZmRzLWNhcHRpb24tZm9udC1zaXplKTtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MTZweH0udGV4dC1ibG9jay50eXBlLWJvZHksLnRleHQtYmxvY2sudHlwZS1ib2R5LWxhcmdlLC50ZXh0LWJsb2NrLnR5cGUtYm9keS1zdHJvbmd7Zm9udC1zaXplOnZhcigtLWZkcy1ib2R5LWZvbnQtc2l6ZSk7Zm9udC13ZWlnaHQ6NDAwO2xpbmUtaGVpZ2h0OjIwcHh9LnRleHQtYmxvY2sudHlwZS1ib2R5LXN0cm9uZ3tmb250LXdlaWdodDo2MDB9LnRleHQtYmxvY2sudHlwZS1ib2R5LWxhcmdle2ZvbnQtc2l6ZTp2YXIoLS1mZHMtYm9keS1sYXJnZS1mb250LXNpemUpO2xpbmUtaGVpZ2h0OjI0cHh9LnRleHQtYmxvY2sudHlwZS1zdWJ0aXRsZXtmb250LXNpemU6dmFyKC0tZmRzLXN1YnRpdGxlLWZvbnQtc2l6ZSk7bGluZS1oZWlnaHQ6MjhweH0udGV4dC1ibG9jay50eXBlLXRpdGxle2ZvbnQtc2l6ZTp2YXIoLS1mZHMtdGl0bGUtZm9udC1zaXplKTtsaW5lLWhlaWdodDozNnB4fS50ZXh0LWJsb2NrLnR5cGUtdGl0bGUtbGFyZ2V7Zm9udC1zaXplOnZhcigtLWZkcy10aXRsZS1sYXJnZS1mb250LXNpemUpO2xpbmUtaGVpZ2h0OjUycHh9LnRleHQtYmxvY2sudHlwZS1kaXNwbGF5e2ZvbnQtc2l6ZTp2YXIoLS1mZHMtZGlzcGxheS1mb250LXNpemUpO2xpbmUtaGVpZ2h0OjkycHh9PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFzRFEseUJBQVcsQ0FBQyxNQUFNLFlBQVksQ0FBQyxRQUFRLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxXQUFXLDJCQUFhLENBQUMsV0FBVyw0QkFBYyxDQUFDLFdBQVcseUJBQVcsQ0FBQyxXQUFXLCtCQUFpQixDQUFDLFlBQVksSUFBSSx5QkFBeUIsQ0FBQyxDQUFDLFlBQVksR0FBRyxDQUFDLFdBQVcsd0JBQVUsQ0FBQyxXQUFXLDhCQUFnQixDQUFDLFdBQVcsK0JBQWlCLENBQUMsWUFBWSxJQUFJLHNCQUFzQixDQUFDLENBQUMsV0FBVywyQkFBYSxDQUFDLFlBQVksSUFBSSx1QkFBdUIsQ0FBQyxDQUFDLFVBQVUsSUFBSSx1QkFBdUIsQ0FBQyxDQUFDLFlBQVksR0FBRyxDQUFDLFlBQVksSUFBSSxDQUFDLFdBQVcsd0JBQVUsQ0FBQyxXQUFXLDhCQUFnQixDQUFDLFdBQVcsK0JBQWlCLENBQUMsVUFBVSxJQUFJLG9CQUFvQixDQUFDLENBQUMsWUFBWSxHQUFHLENBQUMsWUFBWSxJQUFJLENBQUMsV0FBVywrQkFBaUIsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxXQUFXLDhCQUFnQixDQUFDLFVBQVUsSUFBSSwwQkFBMEIsQ0FBQyxDQUFDLFlBQVksSUFBSSxDQUFDLFdBQVcsNEJBQWMsQ0FBQyxVQUFVLElBQUksd0JBQXdCLENBQUMsQ0FBQyxZQUFZLElBQUksQ0FBQyxXQUFXLHlCQUFXLENBQUMsVUFBVSxJQUFJLHFCQUFxQixDQUFDLENBQUMsWUFBWSxJQUFJLENBQUMsV0FBVywrQkFBaUIsQ0FBQyxVQUFVLElBQUksMkJBQTJCLENBQUMsQ0FBQyxZQUFZLElBQUksQ0FBQyxXQUFXLDJCQUFhLENBQUMsVUFBVSxJQUFJLHVCQUF1QixDQUFDLENBQUMsWUFBWSxJQUFJLENBQUMifQ== */");
}

// (46:0) <svelte:element  this={tag ? tag : map[variant].tag}  class="text-block type-{map[variant].name} {className}"  bind:this={element}  {...$$restProps} >
function create_dynamic_element(ctx) {
	let svelte_element;
	let svelte_element_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	let svelte_element_levels = [
		{
			class: svelte_element_class_value = "text-block type-" + /*map*/ ctx[4][/*variant*/ ctx[1]].name + " " + /*className*/ ctx[3]
		},
		/*$$restProps*/ ctx[5]
	];

	let svelte_element_data = {};

	for (let i = 0; i < svelte_element_levels.length; i += 1) {
		svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
	}

	const block = {
		c: function create() {
			svelte_element = element_1(/*tag*/ ctx[2]
			? /*tag*/ ctx[2]
			: /*map*/ ctx[4][/*variant*/ ctx[1]].tag);

			if (default_slot) default_slot.c();
			set_attributes(svelte_element, svelte_element_data);
			toggle_class(svelte_element, "svelte-zxj483", true);
			add_location(svelte_element, file, 45, 0, 1003);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svelte_element, anchor);

			if (default_slot) {
				default_slot.m(svelte_element, null);
			}

			/*svelte_element_binding*/ ctx[8](svelte_element);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}

			set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
				(!current || dirty & /*variant, className*/ 10 && svelte_element_class_value !== (svelte_element_class_value = "text-block type-" + /*map*/ ctx[4][/*variant*/ ctx[1]].name + " " + /*className*/ ctx[3])) && { class: svelte_element_class_value },
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5]
			]));

			toggle_class(svelte_element, "svelte-zxj483", true);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svelte_element);
			if (default_slot) default_slot.d(detaching);
			/*svelte_element_binding*/ ctx[8](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_dynamic_element.name,
		type: "child_dynamic_element",
		source: "(46:0) <svelte:element  this={tag ? tag : map[variant].tag}  class=\\\"text-block type-{map[variant].name} {className}\\\"  bind:this={element}  {...$$restProps} >",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let previous_tag = /*tag*/ ctx[2]
	? /*tag*/ ctx[2]
	: /*map*/ ctx[4][/*variant*/ ctx[1]].tag;

	let svelte_element_anchor;
	let current;

	validate_dynamic_element(/*tag*/ ctx[2]
	? /*tag*/ ctx[2]
	: /*map*/ ctx[4][/*variant*/ ctx[1]].tag);

	validate_void_dynamic_element(/*tag*/ ctx[2]
	? /*tag*/ ctx[2]
	: /*map*/ ctx[4][/*variant*/ ctx[1]].tag);

	let svelte_element = (/*tag*/ ctx[2]
	? /*tag*/ ctx[2]
	: /*map*/ ctx[4][/*variant*/ ctx[1]].tag) && create_dynamic_element(ctx);

	const block = {
		c: function create() {
			if (svelte_element) svelte_element.c();
			svelte_element_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (svelte_element) svelte_element.m(target, anchor);
			insert_dev(target, svelte_element_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*tag*/ ctx[2]
			? /*tag*/ ctx[2]
			: /*map*/ ctx[4][/*variant*/ ctx[1]].tag) {
				if (!previous_tag) {
					svelte_element = create_dynamic_element(ctx);
					svelte_element.c();
					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
				} else if (safe_not_equal(previous_tag, /*tag*/ ctx[2]
				? /*tag*/ ctx[2]
				: /*map*/ ctx[4][/*variant*/ ctx[1]].tag)) {
					svelte_element.d(1);

					validate_dynamic_element(/*tag*/ ctx[2]
					? /*tag*/ ctx[2]
					: /*map*/ ctx[4][/*variant*/ ctx[1]].tag);

					validate_void_dynamic_element(/*tag*/ ctx[2]
					? /*tag*/ ctx[2]
					: /*map*/ ctx[4][/*variant*/ ctx[1]].tag);

					svelte_element = create_dynamic_element(ctx);
					svelte_element.c();
					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
				} else {
					svelte_element.p(ctx, dirty);
				}
			} else if (previous_tag) {
				svelte_element.d(1);
				svelte_element = null;
			}

			previous_tag = /*tag*/ ctx[2]
			? /*tag*/ ctx[2]
			: /*map*/ ctx[4][/*variant*/ ctx[1]].tag;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(svelte_element);
			current = true;
		},
		o: function outro(local) {
			transition_out(svelte_element);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svelte_element_anchor);
			if (svelte_element) svelte_element.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = ["variant","tag","class","element"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('TextBlock', slots, ['default']);
	let { variant = "body" } = $$props;
	let { tag = undefined } = $$props;
	let { class: className = "" } = $$props;
	let { element = null } = $$props;

	const map = {
		caption: { tag: "span", name: "caption" },
		body: { tag: "span", name: "body" },
		bodyStrong: { tag: "h5", name: "body-strong" },
		bodyLarge: { tag: "h5", name: "body-large" },
		subtitle: { tag: "h4", name: "subtitle" },
		title: { tag: "h3", name: "title" },
		titleLarge: { tag: "h2", name: "title-large" },
		display: { tag: "h1", name: "display" }
	};

	function svelte_element_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			element = $$value;
			$$invalidate(0, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('variant' in $$new_props) $$invalidate(1, variant = $$new_props.variant);
		if ('tag' in $$new_props) $$invalidate(2, tag = $$new_props.tag);
		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ('element' in $$new_props) $$invalidate(0, element = $$new_props.element);
		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ variant, tag, className, element, map });

	$$self.$inject_state = $$new_props => {
		if ('variant' in $$props) $$invalidate(1, variant = $$new_props.variant);
		if ('tag' in $$props) $$invalidate(2, tag = $$new_props.tag);
		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
		if ('element' in $$props) $$invalidate(0, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		element,
		variant,
		tag,
		className,
		map,
		$$restProps,
		$$scope,
		slots,
		svelte_element_binding
	];
}

class TextBlock extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { variant: 1, tag: 2, class: 3, element: 0 }, add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TextBlock",
			options,
			id: create_fragment.name
		});
	}

	get variant() {
		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set variant(value) {
		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tag() {
		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get element() {
		throw new Error("<TextBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set element(value) {
		throw new Error("<TextBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default TextBlock;